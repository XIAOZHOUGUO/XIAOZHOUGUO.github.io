<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计算属性：相比普通函数好在哪里？ | We Are ALL Made Of Star Stuff</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <meta name="description" content="start from zero">
  
  
  
    <link rel="alternate" href="/atom.xml" title="We Are ALL Made Of Star Stuff" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
    
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">We Are ALL Made Of Star Stuff</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">steps-by-steps</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> 关于</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> 订阅</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-vue3/computed" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计算属性：相比普通函数好在哪里？
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2022-07-04T07:17:47.000Z" itemprop="datePublished">2022年07月04日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/Vue3/">Vue3</a>
  </div>

      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>

      
      
<a href="/2022/07/04/vue3/computed/#comments" class="article-comment-link">
  
    
    
    
    
    
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上一篇文章，我们学习了响应式的实现原理，这次我们将学习一个非常常用的响应式 API——<strong>计算属性</strong>。</p>
<span id="more"></span>

<p>计算属性是 Vue.js 开发中一个非常实用的 API ，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。当依赖发生变化时，计算属性可以自动重新计算获取新值，所以使用起来非常方便。</p>
<p>在 Vue.js 2.x 中，相信你对计算属性的应用已经如数家珍了，我们可以在组件对象中定义 computed 属性。到了 Vue.js 3.0 ，虽然也可以在组件中沿用 Vue.js 2.x 的使用方式，但是我们也可以单独使用计算属性 API。</p>
<p>计算属性本质上还是对依赖的计算，那么为什么我们不直接用函数呢？在 Vue.js 3.0 中计算属性的 API 又是如何实现呢？接下来，就请你带着这些疑问，随我一起深入其实现原理的学习吧。</p>
<h3 id="计算属性-API：-computed"><a href="#计算属性-API：-computed" class="headerlink" title="计算属性 API： computed"></a>计算属性 API： computed</h3><p>Vue.js 3.0 提供了一个 computed 函数作为计算属性 API，我们先来看看它是如何使用的。</p>
<p>我们举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span>) <span class="comment">// 2 </span></span><br><span class="line">plusOne.<span class="property">value</span>++ <span class="comment">// error </span></span><br><span class="line">count.<span class="property">value</span>++ </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne，它的值是 count.value + 1，当我们修改 count.value 的时候， plusOne.value 就会自动发生变化。</p>
<p>注意，这里我们直接修改 plusOne.value 会报一个错误，这是因为如果我们传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。</p>
<p>在 getter 函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个响应式对象，就是计算属性的依赖。</p>
<p>当然，有时候我们也希望能够直接修改 computed 的返回值，那么我们可以给 computed 传入一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(&#123; </span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>, </span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="params">val</span> =&gt;</span> &#123; </span><br><span class="line">    count.<span class="property">value</span> = val - <span class="number">1</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br><span class="line">plusOne.<span class="property">value</span> = <span class="number">1</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，结合上述代码可以看到，我们给 computed 函数传入了一个拥有 getter 函数和 setter 函数的对象，getter 函数和之前一样，还是返回 count.value + 1；而 setter 函数，请注意，这里我们修改 plusOne.value 的值就会触发 setter 函数，其实 setter 函数内部实际上会根据传入的参数修改计算属性的依赖值 count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍 getter，所以这样获取的值也就发生了变化。</p>
<p>好了，我们现在已经知道了 computed API 的两种使用方式了，接下来就看看它是怎样实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOrOptions</span>) &#123; </span><br><span class="line">  <span class="comment">// getter 函数 </span></span><br><span class="line">  <span class="keyword">let</span> getter </span><br><span class="line">  <span class="comment">// setter 函数 </span></span><br><span class="line">  <span class="keyword">let</span> setter </span><br><span class="line">  <span class="comment">// 标准化参数 </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isFunction</span>(getterOrOptions)) &#123; </span><br><span class="line">    <span class="comment">// 表面传入的是 getter 函数，不能修改计算属性的值 </span></span><br><span class="line">    getter = getterOrOptions </span><br><span class="line">    setter = (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) </span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>) </span><br><span class="line">      &#125; </span><br><span class="line">      : <span class="variable constant_">NOOP</span> </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span> </span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span> </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 数据是否脏的 </span></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span> </span><br><span class="line">  <span class="comment">// 计算结果 </span></span><br><span class="line">  <span class="keyword">let</span> value </span><br><span class="line">  <span class="keyword">let</span> computed </span><br><span class="line">  <span class="comment">// 创建副作用函数 </span></span><br><span class="line">  <span class="keyword">const</span> runner = <span class="title function_">effect</span>(getter, &#123; </span><br><span class="line">    <span class="comment">// 延时执行 </span></span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 </span></span><br><span class="line">    <span class="attr">computed</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 调度执行的实现 </span></span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123; </span><br><span class="line">        dirty = <span class="literal">true</span> </span><br><span class="line">        <span class="comment">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span><br><span class="line">        <span class="title function_">trigger</span>(computed, <span class="string">&quot;set&quot;</span> <span class="comment">/* SET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="comment">// 创建 computed 对象 </span></span><br><span class="line">  computed = &#123; </span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 暴露 effect 对象以便计算属性可以停止计算 </span></span><br><span class="line">    <span class="attr">effect</span>: runner, </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123; </span><br><span class="line">      <span class="comment">// 计算属性的 getter </span></span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123; </span><br><span class="line">        <span class="comment">// 只有数据为脏的时候才会重新计算 </span></span><br><span class="line">        value = <span class="title function_">runner</span>() </span><br><span class="line">        dirty = <span class="literal">false</span> </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span><br><span class="line">      <span class="title function_">track</span>(computed, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">      <span class="keyword">return</span> value </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123; </span><br><span class="line">      <span class="comment">// 计算属性的 setter </span></span><br><span class="line">      <span class="title function_">setter</span>(newValue) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> computed </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，computed 函数的流程主要做了三件事情：<strong>标准化参数，创建副作用函数和创建 computed 对象</strong>。我们来详细分析一下这几个步骤。</p>
<p>首先是<strong>标准化参数</strong>。computed 函数接受两种类型的参数，一个是 getter 函数，一个是拥有 getter 和 setter 函数的对象，通过判断参数的类型，我们初始化了函数内部定义的 getter 和 setter 函数。</p>
<p>接着是<strong>创建副作用函数 runner</strong>。computed 内部通过 effect 创建了一个副作用函数，它是对 getter 函数做的一层封装，另外我们这里要注意第二个参数，也就是 effect 函数的配置对象。其中 lazy 为 true 表示 effect 函数返回的 runner 并不会立即执行；computed 为 true 用于表示这是一个 computed effect，用于 trigger 阶段的优先级排序，我们稍后会分析；scheduler 表示它的调度运行的方式，我们也稍后分析。</p>
<p>最后是<strong>创建 computed 对象并返回</strong>，这个对象也拥有 getter 和 setter 函数。当 computed 对象被访问的时候会触发 getter，然后会判断是否 dirty，如果是就执行 runner，然后做依赖收集；当我们直接设置 computed 对象时会触发 setter，即执行 computed 函数内部定义的 setter 函数。</p>
<h4 id="计算属性的运行机制"><a href="#计算属性的运行机制" class="headerlink" title="计算属性的运行机制"></a>计算属性的运行机制</h4><p>computed 函数的逻辑会有一点绕，不过不要紧，我们可以结合一个应用 computed 计算属性的例子，来理解整个计算属性的运行机制。分析之前我们需要记住 computed 内部两个重要的变量，第一个 dirty 表示一个计算属性的值是否是“脏的”，用来判断需不需要重新计算，第二个 value 表示计算属性每次计算后的结果。</p>
<p>现在，我们来看这个示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">    &#123;&#123; plusOne &#125;&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;plus&quot;</span>&gt;</span>plus<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> count.<span class="property">value</span> + <span class="number">1</span> </span></span><br><span class="line"><span class="language-javascript">      &#125;) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">plus</span> = (<span class="params"></span>)=&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">          count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          plusOne,</span></span><br><span class="line"><span class="language-javascript">          plus</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在这个例子中我们利用 computed API 创建了计算属性对象 plusOne，它传入的是一个 getter 函数，为了和后面计算属性对象的 getter 函数区分，我们把它称作 computed getter。另外，组件模板中引用了 plusOne 变量和 plus 函数。</p>
<p>组件渲染阶段会访问 plusOne，也就触发了 plusOne 对象的 getter 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123; </span><br><span class="line">  <span class="comment">// 计算属性的 getter </span></span><br><span class="line">  <span class="keyword">if</span> (dirty) &#123; </span><br><span class="line">    <span class="comment">// 只有数据为脏的时候才会重新计算 </span></span><br><span class="line">    value = <span class="title function_">runner</span>() </span><br><span class="line">    dirty = <span class="literal">false</span> </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span><br><span class="line">  <span class="title function_">track</span>(computed, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">  <span class="keyword">return</span> value </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于默认 dirty 是 true，所以这个时候会执行 runner 函数，并进一步执行 computed getter，也就是 count.value + 1，因为访问了 count 的值，并且由于 count 也是一个响应式对象，所以就会触发 count 对象的依赖收集过程。</p>
<p>请注意，由于是在 runner 执行的时候访问 count，所以这个时候的 activeEffect 是 runner 函数。runner 函数执行完毕，会把 dirty 设置为 false，并进一步执行 track（computed,”get”,’value’) 函数做依赖收集，这个时候 runner 已经执行完了，所以 activeEffect 是组件副作用渲染函数。</p>
<p>然后当我们点击按钮的时候，会执行 plus 函数，函数内部通过 count.value++ 修改 count 的值，并派发通知。请注意，这里不是直接调用 runner 函数，而是把 runner 作为参数去执行 scheduler 函数。我们来回顾一下 trigger 函数内部对于 effect 函数的执行方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect</span>) =&gt; &#123; </span><br><span class="line">  <span class="comment">// 调度执行 </span></span><br><span class="line">  <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123; </span><br><span class="line">    effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 直接运行 </span></span><br><span class="line">    <span class="title function_">effect</span>() </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>computed API 内部创建副作用函数时，已经配置了 scheduler 函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (!dirty) &#123; </span><br><span class="line">    dirty = <span class="literal">true</span> </span><br><span class="line">    <span class="comment">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span><br><span class="line">    <span class="title function_">trigger</span>(computed, <span class="string">&quot;set&quot;</span> <span class="comment">/* SET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它并没有对计算属性求新值，而仅仅是把 dirty 设置为 true，再执行 trigger(computed, “set” , ‘value’)，去通知执行 plusOne 依赖的组件渲染副作用函数，即触发组件的重新渲染。</p>
<p>在组件重新渲染的时候，会再次访问 plusOne，我们发现这个时候 dirty 为 true，然后会再次执行 computed getter，此时才会执行 count.value + 1 求得新值。这就是虽然组件没有直接访问 count，但是当我们修改 count 的值的时候，组件仍然会重新渲染的原因。</p>
<p>为了更加直观展示上述过程，我画了一张图：</p>
<p><img src="/computed/Ciqc1F8nv6SAMiYhAAJ4vcrA7pg591.png"></p>
<p>通过以上分析，我们可以看出 computed 计算属性有两个特点：</p>
<ol>
<li><strong>延时计算</strong>，只有当我们访问计算属性的时候，它才会真正运行 computed getter 函数计算；</li>
<li><strong>缓存</strong>，它的内部会缓存上次的计算结果 value，而且只有 dirty 为 true 时才会重新计算。如果访问计算属性时 dirty 为 false，那么直接返回这个 value。</li>
</ol>
<p>现在，我们就可以回答开头提的问题了。和单纯使用普通函数相比，计算属性的优势是：<strong>只要依赖不变化</strong>，<strong>就可以使用缓存的 value 而不用每次在渲染组件的时候都执行函数去计算</strong>，这是典型的空间换时间的优化思想。</p>
<h4 id="嵌套计算属性"><a href="#嵌套计算属性" class="headerlink" title="嵌套计算属性"></a>嵌套计算属性</h4><p>计算属性也支持嵌套，我们可以针对上述例子做个小修改，即不在渲染函数中访问 plusOne，而在另一个计算属性中访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">count</span> <span class="operator">=</span> ref(<span class="number">0</span>) </span><br><span class="line"><span class="type">const</span> <span class="variable">plusOne</span> <span class="operator">=</span> computed(() =&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> count.value + <span class="number">1</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="type">const</span> <span class="variable">plusTwo</span> <span class="operator">=</span> computed(() =&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> plusOne.value + <span class="number">1</span> </span><br><span class="line">&#125;) </span><br><span class="line">console.log(plusTwo.value)</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，当我们访问 plusTwo 的时候，过程和前面都差不多，同样也是两个依赖收集的过程。对于 plusOne 来说，它收集的依赖是 plusTwo 内部的 runner 函数；对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</p>
<p>接着当我们修改 count 的值时，它会派发通知，先运行 plusOne 内部的 scheduler 函数，把 plusOne 内部的 dirty 变为 true，然后执行 trigger 函数再次派发通知，接着运行 plusTwo 内部的 scheduler 函数，把 plusTwo 内部的 dirty 设置为 true。</p>
<p>然后当我们再次访问 plusTwo 的值时，发现 dirty 为 true，就会执行 plusTwo 的 computed getter 函数去执行 plusOne.value + 1，进而执行 plusOne 的 computed gette 即 count.value + 1 + 1，求得最终新值 2。</p>
<p>得益于 computed 这种巧妙的设计，无论嵌套多少层计算属性都可以正常工作。</p>
<h4 id="计算属性的执行顺序"><a href="#计算属性的执行顺序" class="headerlink" title="计算属性的执行顺序"></a>计算属性的执行顺序</h4><p>我们曾提到计算属性内部创建副作用函数的时候会配置 computed 为 true，标识这是一个 computed effect，用于在 trigger 阶段的优先级排序。我们来回顾一下 trigger 函数执行 effects 的过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">effectsToAdd</span>) =&gt; &#123; </span><br><span class="line">  <span class="keyword">if</span> (effectsToAdd) &#123; </span><br><span class="line">    effectsToAdd.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (effect !== activeEffect || !shouldTrack) &#123; </span><br><span class="line">        <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">computed</span>) &#123; </span><br><span class="line">          computedRunners.<span class="title function_">add</span>(effect) </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">          effects.<span class="title function_">add</span>(effect) </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect</span>) =&gt; &#123; </span><br><span class="line">  <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123; </span><br><span class="line">    effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">effect</span>() </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">computedRunners.<span class="title function_">forEach</span>(run) </span><br><span class="line">effects.<span class="title function_">forEach</span>(run)</span><br></pre></td></tr></table></figure>

<p>在上一节课分析 trigger 函数的时候，为了方便你理解主干逻辑，我省略了 computedRunners 的分支逻辑。实际上，在添加待运行的 effects 的时候，我们会判断每一个 effect 是不是一个 computed effect，如果是的话会添加到 computedRunners 中，在后面运行的时候会优先执行 computedRunners，然后再执行普通的 effects。</p>
<p>那么为什么要这么设计呢？其实是考虑到了一些特殊场景，我们通过一个示例来说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> &#123; effect &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> count.<span class="property">value</span> + <span class="number">1</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span> + count.<span class="property">value</span>) </span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params"></span>) &#123; </span><br><span class="line">  count.<span class="property">value</span>++ </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">plus</span>()</span><br></pre></td></tr></table></figure>

<p>这个示例运行后的结果输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在执行 effect 函数时运行 console.log(plusOne.value + count.value)，所以第一次输出 1，此时 count.value 是 0，plusOne.value 是 1。</p>
<p>后面连续输出两次 3 是因为， plusOne 和 count 的依赖都是这个 effect 函数，所以当我们执行 plus 函数修改 count 的值时，会触发并执行这个 effect 函数，因为 plusOne 的 runner 也是 count 的依赖，count 值修改也会执行 plusOne 的 runner，也就会再次执行 plusOne 的依赖即 effect 函数，因此会输出两次。</p>
<p>那么为什么两次都输出 3 呢？这就跟先执行 computed runner 有关。首先，由于 plusOne 的 runner 和 effect 都是 count 的依赖，当我们修改 count 值的时候， plusOne 的 runner 和 effect 都会执行，那么此时执行顺序就很重要了。</p>
<p>这里先执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value。这个时候，由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了新值 2， 再加上 1 就得到 3。执行完 plusOne 的 runner 以及依赖更新之后，再去执行 count 的普通effect 依赖，从而去执行 plusOne.value + count.value，这个时候 plusOne dirty 为 false， 直接返回上次的计算结果 2，然后再加 1 就又得到 3。</p>
<p>如果我们把 computed runner 和 effect 的执行顺序换一下会怎样呢？我来告诉你，会输出如下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>第一次输出 1 很好理解，因为流程是一样的。第二次为什么会输出 2 呢？我们来分析一下，当我们执行 plus 函数修改 count 的值时，会触发 plusOne 的 runner 和 effect 的执行，这一次我们先让 effect 执行 plusOne.value + count.value，那么就会访问 plusOne.value，但由于 plusOne 的 runner 还没执行，所以此时 dirty 为 false，得到的值还是上一次的计算结果 1，然后再加 1 得到 2。</p>
<p>接着再执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value，这个时候由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了 2，然后再加上 1 就得到 3。</p>
<p>知道原因后，我们再回过头看例子。因为 effect 函数依赖了 plusOne 和 count，所以 plusOne 先计算会更合理，这就是为什么我们需要让 computed runner 的执行优先于普通的 effect 函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的，到这里我们这一节的学习就结束啦，我希望通过学习，你能理解计算属性的工作机制，能搞明白计算属性嵌套场景代码的执行顺序，知道计算属性的两个特点——延时计算和缓存，也希望你能够在组件的开发中合理使用计算属性。</p>
<blockquote>
<p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;reactivity&#x2F;src&#x2F;computed.ts</p>
</blockquote>

        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> 文章目录</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-API%EF%BC%9A-computed"><span class="toc-text">计算属性 API： computed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">计算属性的运行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-text">嵌套计算属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">计算属性的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div>


            </div>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://xiaozhouguo.github.io/2022/07/04/vue3/computed/">https://xiaozhouguo.github.io/2022/07/04/vue3/computed/</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/computed/" rel="tag">computed</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2022/07/01/vue3/reactive-inner/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">
        
          响应式内部的实现原理是怎样的 - 上篇
        
      </div>
    </a>
  
  
    <a href="/2022/07/05/vue3/watcher-one/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">newer</strong>
      <div class="article-nav-title">
        
          侦听器的实现原理和使用场景 - 上篇
        
      </div>
    </a>
  
</nav>

      
      
        
  <div id="comments"></div>









      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/31/vue3/ast-two/">构造AST的完整流程是怎样的？ -下篇</a>
          </li>
        
          <li>
            <a href="/2022/08/03/vue3/ast-transform-one/">AST 节点内部做了哪些转换？- 上篇</a>
          </li>
        
          <li>
            <a href="/2022/08/02/vue3/ast-one/">构造AST的完整流程是怎么样的？ - 上篇</a>
          </li>
        
          <li>
            <a href="/2022/08/01/vue3/watcher-two/">侦听器的实现原理和使用场景 - 下篇</a>
          </li>
        
          <li>
            <a href="/2022/08/01/vue3/reactive-inner-two/">响应式内部的实现原理是怎么样的？- 下篇</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AST/" style="font-size: 16.67px;">AST</a> <a href="/tags/Array/" style="font-size: 10px;">Array</a> <a href="/tags/DOM-diff/" style="font-size: 13.33px;">DOM-diff</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/computed/" style="font-size: 10px;">computed</a> <a href="/tags/life-cycle/" style="font-size: 10px;">life-cycle</a> <a href="/tags/nextTick/" style="font-size: 10px;">nextTick</a> <a href="/tags/provide/" style="font-size: 10px;">provide</a> <a href="/tags/reactive/" style="font-size: 16.67px;">reactive</a> <a href="/tags/regular-expression/" style="font-size: 10px;">regular expression</a> <a href="/tags/setup/" style="font-size: 10px;">setup</a> <a href="/tags/type-challanges/" style="font-size: 10px;">type-challanges</a> <a href="/tags/watch/" style="font-size: 13.33px;">watch</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> 分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MarkDown/">MarkDown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue2/">Vue2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue3/">Vue3</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/">前端基础进阶</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%AA%A5-javascript/">小窥 javascript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022年</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AST/" rel="tag">AST</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/" rel="tag">Array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM-diff/" rel="tag">DOM-diff</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/computed/" rel="tag">computed</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life-cycle/" rel="tag">life-cycle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nextTick/" rel="tag">nextTick</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/provide/" rel="tag">provide</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reactive/" rel="tag">reactive</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/regular-expression/" rel="tag">regular expression</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setup/" rel="tag">setup</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/type-challanges/" rel="tag">type-challanges</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/watch/" rel="tag">watch</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> 友情链接</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="http://weibo.com/u/5531933570">weibo</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">网站地图</a>
        <span> | </span><a href="/atom.xml">订阅本站</a>
        <span> | </span><a href="/about/">联系博主</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2022 guoxiaozhou.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  
    
<script src="/localshare/js/social-share.js"></script>

    
<script src="/localshare/js/qrcode.js"></script>

  
  



  
    
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

    
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

    <script>
      var gitalk = new Gitalk({
        clientID: '73caaf19e0a3f8e71ddd',
        clientSecret: 'd4447cc0909c43121bd44ccae5073305021cd6be',
        repo: 'blog',
        owner: 'XIAOZHOUGUO',
        admin: ['XIAOZHOUGUO'],
        id: md5(window.location.pathname),
        distractionFreeMode: false,
        language: 'zh-CN',
        pagerDirection: 'last'
      });
      gitalk.render('comments');
    </script>
  

  

  

  

  

  

  

  
  





</body>
</html>