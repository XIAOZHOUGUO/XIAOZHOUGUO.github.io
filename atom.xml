<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>We Are ALL Made Of Star Stuff</title>
  
  <subtitle>steps-by-steps</subtitle>
  <link href="https://xiaozhouguo.github.io/atom.xml" rel="self"/>
  
  <link href="https://xiaozhouguo.github.io/"/>
  <updated>2022-10-24T08:00:00.000Z</updated>
  <id>https://xiaozhouguo.github.io/</id>
  
  <author>
    <name>guoxiaozhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AST转换-AST节点内部做了哪些转换？ -下篇</title>
    <link href="https://xiaozhouguo.github.io/2022/10/24/vue3/ast-transform-two/"/>
    <id>https://xiaozhouguo.github.io/2022/10/24/vue3/ast-transform-two/</id>
    <published>2022-10-24T06:49:17.000Z</published>
    <updated>2022-10-24T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xiaozhouguo.github.io/2022/08/03/vue3/ast-transform-one/">上一篇文章中</a>，我们已经知道了 transform 的核心流程主要有四步：创建 transform 上下文、遍历 AST 节点、静态提升以及创建根代码生成节点。这节课我们接着分析遍历 AST 节点中的 Text 节点的转换函数。</p><span id="more"></span><h3 id="Text-节点转换函数"><a href="#Text-节点转换函数" class="headerlink" title="Text 节点转换函数"></a>Text 节点转换函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">transformText</span> = (<span class="params">node, context</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">0</span> <span class="comment">/* ROOT */</span> ||</span><br><span class="line">    node.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> ||</span><br><span class="line">    node.<span class="property">type</span> === <span class="number">11</span> <span class="comment">/* FOR */</span> ||</span><br><span class="line">    node.<span class="property">type</span> === <span class="number">10</span> <span class="comment">/* IF_BRANCH */</span>) &#123;</span><br><span class="line">    <span class="comment">// 在节点退出时执行转换，保证所有表达式都已经被处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> children = node.<span class="property">children</span></span><br><span class="line">      <span class="keyword">let</span> currentContainer = <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">let</span> hasText = <span class="literal">false</span></span><br><span class="line">      <span class="comment">// 将相邻文本节点合并</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = children[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isText</span>(child)) &#123;</span><br><span class="line">          hasText = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; children.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> next = children[j]</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isText</span>(next)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!currentContainer) &#123;</span><br><span class="line">                <span class="comment">// 创建复合表达式节点</span></span><br><span class="line">                currentContainer = children[i] = &#123;</span><br><span class="line">                  <span class="attr">type</span>: <span class="number">8</span> <span class="comment">/* COMPOUND_EXPRESSION */</span>,</span><br><span class="line">                  <span class="attr">loc</span>: child.<span class="property">loc</span>,</span><br><span class="line">                  <span class="attr">children</span>: [child]</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              currentContainer.<span class="property">children</span>.<span class="title function_">push</span>(<span class="string">` + `</span>, next)</span><br><span class="line">              children.<span class="title function_">splice</span>(j, <span class="number">1</span>)</span><br><span class="line">              j--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              currentContainer = <span class="literal">undefined</span></span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!hasText ||</span><br><span class="line">        <span class="comment">// 如果是一个带有单个文本子元素的纯元素节点，什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</span></span><br><span class="line">        (children.<span class="property">length</span> === <span class="number">1</span> &amp;&amp;</span><br><span class="line">          (node.<span class="property">type</span> === <span class="number">0</span> <span class="comment">/* ROOT */</span> ||</span><br><span class="line">            (node.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">              node.<span class="property">tagType</span> === <span class="number">0</span> <span class="comment">/* ELEMENT */</span>)))) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为子文本节点创建一个调用函数表达式的代码生成节点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = children[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isText</span>(child) || child.<span class="property">type</span> === <span class="number">8</span> <span class="comment">/* COMPOUND_EXPRESSION */</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> callArgs = []</span><br><span class="line">          <span class="comment">// 为 createTextVNode 添加执行参数</span></span><br><span class="line">          <span class="keyword">if</span> (child.<span class="property">type</span> !== <span class="number">2</span> <span class="comment">/* TEXT */</span> || child.<span class="property">content</span> !== <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            callArgs.<span class="title function_">push</span>(child)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 标记动态文本</span></span><br><span class="line">          <span class="keyword">if</span> (!context.<span class="property">ssr</span> &amp;&amp; child.<span class="property">type</span> !== <span class="number">2</span> <span class="comment">/* TEXT */</span>) &#123;</span><br><span class="line">            callArgs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;<span class="number">1</span> /* TEXT */&#125;</span> /* <span class="subst">$&#123;PatchFlagNames[<span class="number">1</span> /* TEXT */]&#125;</span> */`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          children[i] = &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="number">12</span> <span class="comment">/* TEXT_CALL */</span>,</span><br><span class="line">            <span class="attr">content</span>: child,</span><br><span class="line">            <span class="attr">loc</span>: child.<span class="property">loc</span>,</span><br><span class="line">            <span class="attr">codegenNode</span>: <span class="title function_">createCallExpression</span>(context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_TEXT</span>), callArgs)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transformText 函数只处理根节点、元素节点、 v-for 以及 v-if 分支相关的节点，它也会返回一个退出函数，因为 transformText 要保证所有表达式节点都已经被处理才执行转换逻辑。</p><p>transformText 主要的目的就是合并一些相邻的文本节点，然后为内部每一个文本节点创建一个代码生成节点。</p><p>在内部，静态文本节点和动态插值节点都被看作是一个文本节点，所以函数首先遍历节点的子节点，然后把子节点中的相邻文本节点合并成一个。</p><p>比如示例中的文本节点：<code>&lt;p&gt;hello &#123;&#123; msg + test &#125;&#125;&lt;/p&gt;</code>。</p><p>在转换之前，p 节点对应的 children 数组有两个元素，第一个是纯文本节点，第二个是一个插值节点，这个数组也是前面提到的表达式节点转换后的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: <span class="string">&quot;hello &quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.msg&quot;</span>,</span><br><span class="line">          <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot; + &quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.test&quot;</span>,</span><br><span class="line">          <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;identifiers&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>转换后，这两个文本节点被合并成一个复合表达式节点，结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;hello &quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot; + &quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="number">8</span>,</span><br><span class="line">          <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">              <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.msg&quot;</span>,</span><br><span class="line">              <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot; + &quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">              <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="string">&quot;content&quot;</span>: <span class="string">&quot;_ctx.test&quot;</span>,</span><br><span class="line">              <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;identifiers&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>合并完子文本节点后，接着判断如果是一个只带有单个文本子元素的纯元素节点，则什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</p><p>最后就是去处理节点包含文本子节点且多个子节点的情况，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  hello &#123;&#123; msg + test &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;foo&quot;</span>/&gt;</span></span><br><span class="line">  hi</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述 p 标签的子节点经过前面的文本合并流程后，还有 3 个子节点。针对这种情况，我们可以遍历子节点，找到所有的文本节点或者是复合表达式节点，然后为这些子节点通过 createCallExpression 创建一个调用函数表达式的代码生成节点。</p><p>我们来看 createCallExpression 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCallExpression</span>(<span class="params">callee, args = [], loc = locStub</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">14</span> <span class="comment">/* JS_CALL_EXPRESSION */</span>,</span><br><span class="line">    loc,</span><br><span class="line">    callee,</span><br><span class="line">    <span class="attr">arguments</span>: args</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCallExpression 的实现很简单，就是返回一个类型为 JS_CALL_EXPRESSION 的对象，它包含了执行的函数名和参数。</p><p>这里，针对我们创建的函数表达式所生成的节点，它对应的函数名是 createTextVNode，参数 callArgs 是子节点本身 child，如果是动态插值节点，那么参数还会多一个 TEXT 的 patchFlag。</p><h3 id="v-if-节点转换函数"><a href="#v-if-节点转换函数" class="headerlink" title="v-if 节点转换函数"></a>v-if 节点转换函数</h3><p>接下来，我们来看一下 v-if 节点转换函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transformIf = <span class="title function_">createStructuralDirectiveTransform</span>(<span class="regexp">/^(if|else|else-if)$/</span>, <span class="function">(<span class="params">node, dir, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">processIf</span>(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 退出回调函数，当所有子节点转换完成执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在分析函数的实现前，我们先来看一下 v-if 节点转换的目的，为了方便你的理解，我还是通过示例来说明：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello &#123;&#123; msg + test &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>static<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>static<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 parse 阶段，这个模板解析生成的 AST 节点如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;codegenNode&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">&quot;isSelfClosing&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ns&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;props&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">7</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;if&quot;</span>,</span><br><span class="line">      <span class="string">&quot;exp&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: <span class="string">&quot;flag&quot;</span>,</span><br><span class="line">        <span class="string">&quot;isConstant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;isStatic&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;arg&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;modifiers&quot;</span>: []</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tagType&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">      <span class="comment">// 子节点</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;codegenNode&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="string">&quot;isSelfClosing&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;ns&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;props&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="number">7</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;else&quot;</span>,</span><br><span class="line">      <span class="string">&quot;exp&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;arg&quot;</span>: <span class="literal">undefined</span>,</span><br><span class="line">      <span class="string">&quot;modifiers&quot;</span>: []</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tagType&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>v-if 指令用于条件性地渲染一块内容，显然上述 AST 节点对于最终去生成条件的代码而言，是不够语义化的，于是我们需要对它们做一层转换，使其成为语义化强的代码生成节点。</p><p>现在我们回过头看 transformIf 的实现，它是通过 createStructuralDirectiveTransform 函数创建的一个结构化指令的转换函数，在 Vue.js 中，v-if、v-else-if、v-else 和 v-for 这些都属于结构化指令，因为它们能影响代码的组织结构。</p><p>我们来看一下 createStructuralDirectiveTransform 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createStructuralDirectiveTransform</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> matches = <span class="title function_">isString</span>(name)</span><br><span class="line">    ? <span class="function">(<span class="params">n</span>) =&gt;</span> n === name</span><br><span class="line">    : <span class="function">(<span class="params">n</span>) =&gt;</span> name.<span class="title function_">test</span>(n)</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">node, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只处理元素节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; props &#125; = node</span><br><span class="line">      <span class="comment">// 结构化指令的转换与插槽无关，插槽相关处理逻辑在 vSlot.ts 中</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">tagType</span> === <span class="number">3</span> <span class="comment">/* TEMPLATE */</span> &amp;&amp; props.<span class="title function_">some</span>(isVSlot)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> exitFns = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> prop = props[i]</span><br><span class="line">        <span class="keyword">if</span> (prop.<span class="property">type</span> === <span class="number">7</span> <span class="comment">/* DIRECTIVE */</span> &amp;&amp; <span class="title function_">matches</span>(prop.<span class="property">name</span>)) &#123;</span><br><span class="line">          <span class="comment">// 删除结构指令以避免无限递归</span></span><br><span class="line">          props.<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">          i--</span><br><span class="line">          <span class="keyword">const</span> onExit = <span class="title function_">fn</span>(node, prop, context)</span><br><span class="line">          <span class="keyword">if</span> (onExit)</span><br><span class="line">            exitFns.<span class="title function_">push</span>(onExit)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> exitFns</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，createStructuralDirectiveTransform 接受 2 个参数，第一个 name 是指令的名称，第二个 fn 是构造转换退出函数的方法。</p><p>createStructuralDirectiveTransform 最后会返回一个函数，在我们的场景下，这个函数就是 transformIf 转换函数。</p><p>我们进一步看这个函数的实现，它只处理元素节点，这个很好理解，因为只有元素节点才会有 v-if 指令，接着会解析这个节点的 props 属性，如果发现 props 包含 if 属性，也就是节点拥有 v-if 指令，那么先从 props 删除这个结构化指令防止无限递归，然后执行 fn 获取对应的退出函数，最后将这个退出函数返回。</p><p>接着我们来看 fn 的实现，在我们这个场景下 fn 对应的是前面传入的匿名函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(node, dir, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">processIf</span>(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 退出回调函数，当所有子节点转换完成执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这个匿名函数内部执行了 processIf 函数，它会先对 v-if 和它的相邻节点做转换，然后返回一个退出函数，在它们的子节点都转换完毕后执行。</p><p>我们来看 processIf 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processIf</span>(<span class="params">node, dir, context, processCodegen</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (dir.<span class="property">name</span> === <span class="string">&#x27;if&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建分支节点</span></span><br><span class="line">    <span class="keyword">const</span> branch = <span class="title function_">createIfBranch</span>(node, dir)</span><br><span class="line">    <span class="comment">// 创建 IF 节点，替换当前节点</span></span><br><span class="line">    <span class="keyword">const</span> ifNode = &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="number">9</span> <span class="comment">/* IF */</span>,</span><br><span class="line">      <span class="attr">loc</span>: node.<span class="property">loc</span>,</span><br><span class="line">      <span class="attr">branches</span>: [branch]</span><br><span class="line">    &#125;</span><br><span class="line">    context.<span class="title function_">replaceNode</span>(ifNode)</span><br><span class="line">    <span class="keyword">if</span> (processCodegen) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">processCodegen</span>(ifNode, branch, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processIf 主要就是用来处理 v-if 节点以及 v-if 的相邻节点，比如 v-else-if 和 v-else，并且它们会走不同的处理逻辑。</p><p>我们先来看 v-if 的处理逻辑。首先，它会执行 createIfBranch 去创建一个分支节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIfBranch</span>(<span class="params">node, dir</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">10</span> <span class="comment">/* IF_BRANCH */</span>,</span><br><span class="line">    <span class="attr">loc</span>: node.<span class="property">loc</span>,</span><br><span class="line">    <span class="attr">condition</span>: dir.<span class="property">name</span> === <span class="string">&#x27;else&#x27;</span> ? <span class="literal">undefined</span> : dir.<span class="property">exp</span>,</span><br><span class="line">    <span class="attr">children</span>: node.<span class="property">tagType</span> === <span class="number">3</span> <span class="comment">/* TEMPLATE */</span> ? node.<span class="property">children</span> : [node]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个分支节点很好理解，因为 v-if 节点内部的子节点可以属于一个分支，v-else-if 和 v-else 节点内部的子节点也都可以属于一个分支，而最终页面渲染执行哪个分支，这取决于哪个分支节点的 condition 为 true。</p><p>所以分支节点返回的对象，就包含了 condition 条件，以及它的子节点 children。注意，<strong>如果节点 node 不是 template</strong>，<strong>那么 children 指向的就是这个单个 node 构造的数组</strong>。</p><p>接下来它会创建 IF 节点替换当前节点，IF 节点拥有 branches 属性，包含我们前面创建的分支节点，显然，相对于原节点，IF 节点的语义化更强，更利于后续生成条件表达式代码。</p><p>最后它会执行 processCodegen 创建退出函数。我们先不着急去分析退出函数的创建过程，先把 v-if 相邻节点的处理逻辑分析完：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processIf</span>(<span class="params">node, dir, context, processCodegen</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (dir.<span class="property">name</span> === <span class="string">&#x27;if&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 v-if 节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span></span><br><span class="line">    <span class="keyword">const</span> siblings = context.<span class="property">parent</span>.<span class="property">children</span></span><br><span class="line">    <span class="keyword">let</span> i = siblings.<span class="title function_">indexOf</span>(node)</span><br><span class="line">    <span class="keyword">while</span> (i-- &gt;= -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> sibling = siblings[i]</span><br><span class="line">      <span class="keyword">if</span> (sibling &amp;&amp; sibling.<span class="property">type</span> === <span class="number">9</span> <span class="comment">/* IF */</span>) &#123;</span><br><span class="line">        <span class="comment">// 把节点移动到 IF 节点的 branches 中</span></span><br><span class="line">        context.<span class="title function_">removeNode</span>()</span><br><span class="line">        <span class="keyword">const</span> branch = <span class="title function_">createIfBranch</span>(node, dir)</span><br><span class="line">        sibling.<span class="property">branches</span>.<span class="title function_">push</span>(branch)</span><br><span class="line">        <span class="keyword">const</span> onExit = processCodegen &amp;&amp; <span class="title function_">processCodegen</span>(sibling, branch, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 因为分支已被删除，所以它的子节点需要在这里遍历</span></span><br><span class="line">        <span class="title function_">traverseNode</span>(branch, context)</span><br><span class="line">        <span class="comment">// 执行退出函数</span></span><br><span class="line">        <span class="keyword">if</span> (onExit)</span><br><span class="line">          <span class="title function_">onExit</span>()</span><br><span class="line">        <span class="comment">// 恢复 currentNode 为 null，因为它已经被移除</span></span><br><span class="line">        context.<span class="property">currentNode</span> = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        context.<span class="title function_">onError</span>(<span class="title function_">createCompilerError</span>(<span class="number">28</span> <span class="comment">/* X_V_ELSE_NO_ADJACENT_IF */</span>, node.<span class="property">loc</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段处理逻辑就是从当前节点往前面的兄弟节点遍历，找到 v-if 节点后，把当前节点删除，然后根据当前节点创建一个分支节点，把这个分支节点添加到前面创建的 IF 节点的 branches 中。此外，由于这个节点已经删除，那么需要在这里把这个节点的子节点通过 traverseNode 遍历一遍。</p><p>这么处理下来，就相当于完善了 IF 节点的信息了，IF 节点的 branches 就包含了所有分支节点了。</p><p>那么至此，进入 v-if、v-else-if、v-else 这些节点的转换逻辑我们就分析完毕了，即最终创建了一个 IF 节点，它包含了所有的分支节点。</p><p>接下来，我们再来分析这个退出函数的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(node, dir, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">processIf</span>(node, dir, context, <span class="function">(<span class="params">ifNode, branch, isRoot</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 退出回调函数，当所有子节点转换完成执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRoot) &#123;</span><br><span class="line">        <span class="comment">// v-if 节点的退出函数</span></span><br><span class="line">        <span class="comment">// 创建 IF 节点的 codegenNode</span></span><br><span class="line">        ifNode.<span class="property">codegenNode</span> = <span class="title function_">createCodegenNodeForBranch</span>(branch, <span class="number">0</span>, context)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// v-else-if、v-else 节点的退出函数</span></span><br><span class="line">        <span class="comment">// 将此分支的 codegenNode 附加到 上一个条件节点的 codegenNode 的 alternate 中</span></span><br><span class="line">        <span class="keyword">let</span> parentCondition = ifNode.<span class="property">codegenNode</span></span><br><span class="line">        <span class="keyword">while</span> (parentCondition.<span class="property">alternate</span>.<span class="property">type</span> ===</span><br><span class="line">        <span class="number">19</span> <span class="comment">/* JS_CONDITIONAL_EXPRESSION */</span>) &#123;</span><br><span class="line">          parentCondition = parentCondition.<span class="property">alternate</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新候选节点</span></span><br><span class="line">        parentCondition.<span class="property">alternate</span> = <span class="title function_">createCodegenNodeForBranch</span>(branch, ifNode.<span class="property">branches</span>.<span class="property">length</span> - <span class="number">1</span>, context)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当 v-if 节点执行退出函数时，会通过 createCodegenNodeForBranch 创建 IF 分支节点的 codegenNode，我们来看一下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCodegenNodeForBranch</span>(<span class="params">branch, index, context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (branch.<span class="property">condition</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createConditionalExpression</span>(branch.<span class="property">condition</span>, <span class="title function_">createChildrenCodegenNode</span>(branch, index, context),</span><br><span class="line">      <span class="title function_">createCallExpression</span>(context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_COMMENT</span>), [</span><br><span class="line">        (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) ? <span class="string">&#x27;&quot;v-if&quot;&#x27;</span> : <span class="string">&#x27;&quot;&quot;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      ]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createChildrenCodegenNode</span>(branch, index, context)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当分支节点存在 condition 的时候，比如 v-if、和 v-else-if，它通过 createConditionalExpression 返回一个条件表达式节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createConditionalExpression</span>(<span class="params">test, consequent, alternate, newline = <span class="literal">true</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">19</span> <span class="comment">/* JS_CONDITIONAL_EXPRESSION */</span>,</span><br><span class="line">    test,</span><br><span class="line">    consequent,</span><br><span class="line">    alternate,</span><br><span class="line">    newline,</span><br><span class="line">    <span class="attr">loc</span>: locStub</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 consequent 在这里是 IF 主 branch 的子节点对应的代码生成节点，alternate 是后补 branch 子节点对应的代码生成节点。</p><p>接着，我们来看一下 createChildrenCodegenNode 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createChildrenCodegenNode</span>(<span class="params">branch, index, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; helper &#125; = context</span><br><span class="line">  <span class="comment">// 根据 index 创建 key 属性</span></span><br><span class="line">  <span class="keyword">const</span> keyProperty = <span class="title function_">createObjectProperty</span>(<span class="string">`key`</span>, <span class="title function_">createSimpleExpression</span>(index + <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>))</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = branch</span><br><span class="line">  <span class="keyword">const</span> firstChild = children[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> needFragmentWrapper = children.<span class="property">length</span> !== <span class="number">1</span> || firstChild.<span class="property">type</span> !== <span class="number">1</span> <span class="comment">/* ELEMENT */</span></span><br><span class="line">  <span class="keyword">if</span> (needFragmentWrapper) &#123;</span><br><span class="line">    <span class="keyword">if</span> (children.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; firstChild.<span class="property">type</span> === <span class="number">11</span> <span class="comment">/* FOR */</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> vnodeCall = firstChild.<span class="property">codegenNode</span></span><br><span class="line">      <span class="title function_">injectProp</span>(vnodeCall, keyProperty, context)</span><br><span class="line">      <span class="keyword">return</span> vnodeCall</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createVNodeCall</span>(context, <span class="title function_">helper</span>(<span class="variable constant_">FRAGMENT</span>), <span class="title function_">createObjectExpression</span>([keyProperty]), children, <span class="string">`<span class="subst">$&#123;<span class="number">64</span> /* STABLE_FRAGMENT */&#125;</span> /* <span class="subst">$&#123;PatchFlagNames[<span class="number">64</span> /* STABLE_FRAGMENT */]&#125;</span> */`</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">true</span>, <span class="literal">false</span>, branch.<span class="property">loc</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vnodeCall = firstChild</span><br><span class="line">      .<span class="property">codegenNode</span>;</span><br><span class="line">    <span class="comment">// 把 createVNode 改变为 createBlock</span></span><br><span class="line">    <span class="keyword">if</span> (vnodeCall.<span class="property">type</span> === <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span> &amp;&amp;</span><br><span class="line">      <span class="comment">// 组件节点的 children 会被视为插槽，不需要添加 block</span></span><br><span class="line">      (firstChild.<span class="property">tagType</span> !== <span class="number">1</span> <span class="comment">/* COMPONENT */</span> ||</span><br><span class="line">        vnodeCall.<span class="property">tag</span> === <span class="variable constant_">TELEPORT</span>)) &#123;</span><br><span class="line">      vnodeCall.<span class="property">isBlock</span> = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 创建 block 的辅助代码</span></span><br><span class="line">      <span class="title function_">helper</span>(<span class="variable constant_">OPEN_BLOCK</span>)</span><br><span class="line">      <span class="title function_">helper</span>(<span class="variable constant_">CREATE_BLOCK</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 branch 注入 key 属性</span></span><br><span class="line">    <span class="title function_">injectProp</span>(vnodeCall, keyProperty, context)</span><br><span class="line">    <span class="keyword">return</span> vnodeCall</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createChildrenCodegenNode 主要就是判断每个分支子节点是不是一个 vnodeCall，如果这个子节点不是组件节点的话，则把它转变成一个 BlockCall，也就是让 v-if 的每一个分支都可以创建一个 Block。</p><p>这个行为是很好理解的，因为 v-if 是条件渲染的，我们知道在某些条件下某些分支是不会渲染的，那么它内部的动态节点就不能添加到外部的 Block 中的，所以它就需要单独创建一个 Block 来维护分支内部的动态节点，这样也就构成了 Block tree。</p><p>为了直观让你感受 v-if 节点最终转换的结果，我们来看前面示例转换后的结果，最终转换生成的 IF 节点对象大致如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;branches&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_ctx.flag&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_ctx.flag&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;codegenNode&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;consequent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_component_hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;directives&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dynamicProps&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isBlock&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;patchFlag&quot;</span><span class="punctuation">:</span> undefined</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;alternate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_component_hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="comment">// 子节点</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;directives&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dynamicProps&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isBlock&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;patchFlag&quot;</span><span class="punctuation">:</span> undefined</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，相比原节点，转换后的 IF 节点无论是在语义化还是在信息上，都更加丰富，我们可以依据它在代码生成阶段生成所需的代码。</p><h3 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h3><p>节点转换完毕后，接下来会判断编译配置中是否配置了 hoistStatic，如果是就会执行 hoistStatic 做静态提升：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.<span class="property">hoistStatic</span>) &#123;</span><br><span class="line">  <span class="title function_">hoistStatic</span>(root, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态提升也是 Vue.js 3.0 在编译阶段设计了一个优化策略，为了便于你理解，我先举个简单的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&gt;hello &#123;&#123; msg + test &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>static<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>static<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们为它配置了 hoistStatic，经过编译后，它的代码就变成了这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toDisplayString <span class="keyword">as</span> _toDisplayString, createVNode <span class="keyword">as</span> _createVNode, <span class="title class_">Fragment</span> <span class="keyword">as</span> _Fragment, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;static&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;static&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;hello &quot;</span> + <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">msg</span> + _ctx.<span class="property">test</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>),</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    _hoisted_2</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们先忽略 openBlock、Fragment ，我会在代码生成章节详细说明，重点看一下 _hoisted_1 和 _hoisted_2 这两个变量，它们分别对应模板中两个静态 p 标签生成的 vnode，可以发现它的创建是在 render 函数外部执行的。<br>这样做的好处是，不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，直接用之前在内存中创建好的 vnode 即可。</p><p>那么为什么叫静态提升呢？</p><p>因为这些静态节点不依赖动态数据，一旦创建了就不会改变，所以只有静态节点才能被提升到外部创建。</p><p>了解以上背景知识后，我们接下来看一下静态提升的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoistStatic</span>(<span class="params">root, context</span>) &#123;</span><br><span class="line">  <span class="title function_">walk</span>(</span><br><span class="line">      root, context, <span class="keyword">new</span> <span class="title class_">Map</span>(),</span><br><span class="line">    <span class="comment">// Root node is unfortunately non-hoistable due to potential parent fallthrough attributes.</span></span><br><span class="line">      <span class="title function_">isSingleElementRoot</span>(root, root.<span class="property">children</span>[<span class="number">0</span>])</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">walk</span>(<span class="params">node, context, resultCache, doNotHoistNode = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hasHoistedNode = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 是否包含运行时常量</span></span><br><span class="line">  <span class="keyword">let</span> hasRuntimeConstant = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = node</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = children[i]</span><br><span class="line">    <span class="comment">// 只有普通元素和文本节点才能被静态提升</span></span><br><span class="line">    <span class="keyword">if</span> (child.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">      child.<span class="property">tagType</span> === <span class="number">0</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> staticType</span><br><span class="line">      <span class="keyword">if</span> (!doNotHoistNode &amp;&amp;</span><br><span class="line">        <span class="comment">// 获取静态节点的类型，如果是元素，则递归检查它的子节点</span></span><br><span class="line">        (staticType = <span class="title function_">getStaticType</span>(child, resultCache)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticType === <span class="number">2</span> <span class="comment">/* HAS_RUNTIME_CONSTANT */</span>) &#123;</span><br><span class="line">          hasRuntimeConstant = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 patchFlag</span></span><br><span class="line">        child.<span class="property">codegenNode</span>.<span class="property">patchFlag</span> =</span><br><span class="line">          -<span class="number">1</span> <span class="comment">/* HOISTED */</span> + ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) ? <span class="string">` /* HOISTED */`</span> : <span class="string">``</span>)</span><br><span class="line">        <span class="comment">// 更新节点的 codegenNode</span></span><br><span class="line">        child.<span class="property">codegenNode</span> = context.<span class="title function_">hoist</span>(child.<span class="property">codegenNode</span>)</span><br><span class="line">        hasHoistedNode = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点可能会包含一些动态子节点，但它的静态属性还是可以被静态提升</span></span><br><span class="line">        <span class="keyword">const</span> codegenNode = child.<span class="property">codegenNode</span></span><br><span class="line">        <span class="keyword">if</span> (codegenNode.<span class="property">type</span> === <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> flag = <span class="title function_">getPatchFlag</span>(codegenNode)</span><br><span class="line">          <span class="keyword">if</span> ((!flag ||</span><br><span class="line">            flag === <span class="number">512</span> <span class="comment">/* NEED_PATCH */</span> ||</span><br><span class="line">            flag === <span class="number">1</span> <span class="comment">/* TEXT */</span>) &amp;&amp;</span><br><span class="line">            !<span class="title function_">hasDynamicKeyOrRef</span>(child) &amp;&amp;</span><br><span class="line">            !<span class="title function_">hasCachedProps</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> props = <span class="title function_">getNodeProps</span>(child)</span><br><span class="line">            <span class="keyword">if</span> (props) &#123;</span><br><span class="line">              codegenNode.<span class="property">props</span> = context.<span class="title function_">hoist</span>(props)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child.<span class="property">type</span> === <span class="number">12</span> <span class="comment">/* TEXT_CALL */</span>) &#123;</span><br><span class="line">      <span class="comment">// 文本节点也可以静态提升</span></span><br><span class="line">      <span class="keyword">const</span> staticType = <span class="title function_">getStaticType</span>(child.<span class="property">content</span>, resultCache)</span><br><span class="line">      <span class="keyword">if</span> (staticType &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (staticType === <span class="number">2</span> <span class="comment">/* HAS_RUNTIME_CONSTANT */</span>) &#123;</span><br><span class="line">          hasRuntimeConstant = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        child.<span class="property">codegenNode</span> = context.<span class="title function_">hoist</span>(child.<span class="property">codegenNode</span>)</span><br><span class="line">        hasHoistedNode = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归遍历子节点</span></span><br><span class="line">      <span class="title function_">walk</span>(child, context, resultCache)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child.<span class="property">type</span> === <span class="number">11</span> <span class="comment">/* FOR */</span>) &#123;</span><br><span class="line">      <span class="title function_">walk</span>(child, context, resultCache, child.<span class="property">children</span>.<span class="property">length</span> === <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child.<span class="property">type</span> === <span class="number">9</span> <span class="comment">/* IF */</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; child.<span class="property">branches</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">walk</span>(child.<span class="property">branches</span>[i], context, resultCache, child.<span class="property">branches</span>[i].<span class="property">children</span>.<span class="property">length</span> === <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!hasRuntimeConstant &amp;&amp; hasHoistedNode &amp;&amp; context.<span class="property">transformHoist</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果编译配置了 transformHoist，则执行</span></span><br><span class="line">    context.<span class="title function_">transformHoist</span>(children, context, node)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，hoistStatic 主要就是从根节点开始，通过递归的方式去遍历节点，只有普通元素和文本节点才能被静态提升，所以针对这些节点，这里通过 getStaticType 去获取静态类型，如果节点是一个元素类型，getStaticType 内部还会递归判断它的子节点的静态类型。</p><p>虽然有的节点包含一些动态子节点，但它本身的静态属性还是可以被静态提升的。</p><p>注意，<strong>如果 getStaticType 返回的 staticType 的值是 2</strong>，<strong>则表明它是一个运行时常量</strong>，<strong>由于它的值在运行时才能被确定</strong>，<strong>所以是不能静态提升的</strong>。</p><p>如果节点满足可以被静态提升的条件，节点对应的 codegenNode 会通过执行 context.hoist 修改为一个简单表达式节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hoist</span>(<span class="params">exp</span>) &#123;</span><br><span class="line">  context.<span class="property">hoists</span>.<span class="title function_">push</span>(exp);</span><br><span class="line">  <span class="keyword">const</span> identifier = <span class="title function_">createSimpleExpression</span>(<span class="string">`_hoisted_<span class="subst">$&#123;context.hoists.length&#125;</span>`</span>, <span class="literal">false</span>, exp.<span class="property">loc</span>, <span class="literal">true</span>)</span><br><span class="line">  identifier.<span class="property">hoisted</span> = exp</span><br><span class="line">  <span class="keyword">return</span> identifier</span><br><span class="line">&#125;</span><br><span class="line">child.<span class="property">codegenNode</span> = context.<span class="title function_">hoist</span>(child.<span class="property">codegenNode</span>)</span><br></pre></td></tr></table></figure><p>改动后的 codegenNode 会在生成代码阶段帮助我们生成静态提升的相关代码。</p><h3 id="createRootCodegen"><a href="#createRootCodegen" class="headerlink" title="createRootCodegen"></a>createRootCodegen</h3><p>完成静态提升后，我们来到了 AST 转换的最后一步，即<strong>创建根节点的代码生成节点</strong>。我们先来看一下 createRootCodegen 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createRootCodegen</span>(<span class="params">root, context</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; helper &#125; = context;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = root;</span><br><span class="line">  <span class="keyword">const</span> child = children[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (children.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果子节点是单个元素节点，则将其转换成一个 block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSingleElementRoot</span>(root, child) &amp;&amp; child.<span class="property">codegenNode</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> codegenNode = child.<span class="property">codegenNode</span>;</span><br><span class="line">      <span class="keyword">if</span> (codegenNode.<span class="property">type</span> === <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span>) &#123;</span><br><span class="line">        codegenNode.<span class="property">isBlock</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">helper</span>(<span class="variable constant_">OPEN_BLOCK</span>);</span><br><span class="line">        <span class="title function_">helper</span>(<span class="variable constant_">CREATE_BLOCK</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      root.<span class="property">codegenNode</span> = codegenNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      root.<span class="property">codegenNode</span> = child;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (children.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果子节点是多个节点，则返回一个 fragement 的代码生成节点</span></span><br><span class="line">    root.<span class="property">codegenNode</span> = <span class="title function_">createVNodeCall</span>(context, <span class="title function_">helper</span>(<span class="variable constant_">FRAGMENT</span>), <span class="literal">undefined</span>, root.<span class="property">children</span>, <span class="string">`<span class="subst">$&#123;<span class="number">64</span> /* STABLE_FRAGMENT */&#125;</span> /* <span class="subst">$&#123;PatchFlagNames[<span class="number">64</span> /* STABLE_FRAGMENT */]&#125;</span> */`</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createRootCodegen 做的事情很简单，就是为 root 这个虚拟的 AST 根节点创建一个代码生成节点，如果 root 的子节点 children 是单个元素节点，则将其转换成一个 Block，把这个 child 的 codegenNode 赋值给 root 的 codegenNode。</p><p>如果 root 的子节点 children 是多个节点，则返回一个 fragement 的代码生成节点，并赋值给 root 的 codegenNode。</p><p>这里，创建 codegenNode 就是为了后续生成代码时使用。</p><p>createRootCodegen 完成之后，接着把 transform 上下文在转换 AST 节点过程中创建的一些变量赋值给 root 节点对应的属性，在这里可以看一下这些属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">root.helpers</span> <span class="string">=</span> [<span class="string">...context.helpers</span>]</span><br><span class="line"><span class="string">root.components</span> <span class="string">=</span> [<span class="string">...context.components</span>]</span><br><span class="line"><span class="string">root.directives</span> <span class="string">=</span> [<span class="string">...context.directives</span>]</span><br><span class="line"><span class="string">root.imports</span> <span class="string">=</span> [<span class="string">...context.imports</span>]</span><br><span class="line"><span class="string">root.hoists</span> <span class="string">=</span> <span class="string">context.hoists</span></span><br><span class="line"><span class="string">root.temps</span> <span class="string">=</span> <span class="string">context.temps</span></span><br><span class="line"><span class="string">root.cached</span> <span class="string">=</span> <span class="string">context.cached</span></span><br></pre></td></tr></table></figure><p>这样后续在代码生成节点时，就可以通过 root 这个根节点访问到这些变量了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的，到这里我们这一节的学习就结束啦，通过这节课的学习，你应该对 AST 节点内部做了哪些转换有所了解。</p><p>如果说 parse 阶段是一个词法分析过程，构造基础的 AST 节点对象，那么 transform 节点就是语法分析阶段，把 AST 节点做一层转换，构造出语义化更强，信息更加丰富的 codegenCode，它在后续的代码生成阶段起着非常重要的作用。</p><p>最后，给你留一道思考题目，我们已经知道静态提升的好处是，针对静态节点不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，但它有没有成本呢？为什么？欢迎你在留言区与我分享。</p><blockquote><p>本节课的相关代码在源代码中的位置如下：<br>packages&#x2F;compiler-core&#x2F;src&#x2F;ast.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;transform.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;transforms&#x2F;transformText.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;transforms&#x2F;vIf.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;transforms&#x2F;hoistStatic.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://xiaozhouguo.github.io/2022/08/03/vue3/ast-transform-one/&quot;&gt;上一篇文章中&lt;/a&gt;，我们已经知道了 transform 的核心流程主要有四步：创建 transform 上下文、遍历 AST 节点、静态提升以及创建根代码生成节点。这节课我们接着分析遍历 AST 节点中的 Text 节点的转换函数。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="AST" scheme="https://xiaozhouguo.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>模板解析-构造AST的完整流程是怎样的？ -下篇</title>
    <link href="https://xiaozhouguo.github.io/2022/08/31/vue3/ast-two/"/>
    <id>https://xiaozhouguo.github.io/2022/08/31/vue3/ast-two/</id>
    <published>2022-08-31T06:52:33.000Z</published>
    <updated>2022-10-24T06:41:29.128Z</updated>
    
    <content type="html"><![CDATA[<p>这一节课我们依然要<strong>解析 template 生成 AST 背后的实现原理</strong>，之前，我们知道了baseParse 主要就做三件事情：<strong>创建解析上下文</strong>，<strong>解析子节点</strong>，<strong>创建 AST 根节点</strong></p><span id="more"></span><p>我们讲到了解析子节点，主要有四种情况，分别是注释节点的解析、插值的解析、普通文本的解析，以及元素节点的解析，这节课我们就到了最后的元素节点。</p><h3 id="解析子节点"><a href="#解析子节点" class="headerlink" title="解析子节点"></a>解析子节点</h3><h4 id="元素节点的解析"><a href="#元素节点的解析" class="headerlink" title="元素节点的解析"></a>元素节点的解析</h4><p>我们来看元素节点的解析过程，它会解析模板中的标签节点，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相对于前面三种类型的解析过程，元素节点的解析过程应该是最复杂的了，即当前代码 s 是以 &lt; 开头，并且后面跟着字母，说明它是一个标签的开头，则走到元素节点的解析处理逻辑，我们来看 <code>parseElement</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseElement</span>(<span class="params">context, ancestors</span>) &#123;</span><br><span class="line">  <span class="comment">// 是否在 pre 标签内</span></span><br><span class="line">  <span class="keyword">const</span> wasInPre = context.<span class="property">inPre</span></span><br><span class="line">  <span class="comment">// 是否在 v-pre 指令内</span></span><br><span class="line">  <span class="keyword">const</span> wasInVPre = context.<span class="property">inVPre</span></span><br><span class="line">  <span class="comment">// 获取当前元素的父标签节点</span></span><br><span class="line">  <span class="keyword">const</span> parent = <span class="title function_">last</span>(ancestors)</span><br><span class="line">  <span class="comment">// 解析开始标签，生成一个标签节点，并前进代码到开始标签后</span></span><br><span class="line">  <span class="keyword">const</span> element = <span class="title function_">parseTag</span>(context, <span class="number">0</span> <span class="comment">/* Start */</span>, parent)</span><br><span class="line">  <span class="comment">// 是否在 pre 标签的边界</span></span><br><span class="line">  <span class="keyword">const</span> isPreBoundary = context.<span class="property">inPre</span> &amp;&amp; !wasInPre</span><br><span class="line">  <span class="comment">// 是否在 v-pre 指令的边界</span></span><br><span class="line">  <span class="keyword">const</span> isVPreBoundary = context.<span class="property">inVPre</span> &amp;&amp; !wasInVPre</span><br><span class="line">  <span class="keyword">if</span> (element.<span class="property">isSelfClosing</span> || context.<span class="property">options</span>.<span class="title function_">isVoidTag</span>(element.<span class="property">tag</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果是自闭和标签，直接返回标签节点</span></span><br><span class="line">    <span class="keyword">return</span> element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面是处理子节点的逻辑</span></span><br><span class="line">  <span class="comment">// 先把标签节点添加到 ancestors，入栈</span></span><br><span class="line">  ancestors.<span class="title function_">push</span>(element)</span><br><span class="line">  <span class="keyword">const</span> mode = context.<span class="property">options</span>.<span class="title function_">getTextMode</span>(element, parent)</span><br><span class="line">  <span class="comment">// 递归解析子节点，传入 ancestors</span></span><br><span class="line">  <span class="keyword">const</span> children = <span class="title function_">parseChildren</span>(context, mode, ancestors)</span><br><span class="line">  <span class="comment">// ancestors 出栈</span></span><br><span class="line">  ancestors.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="comment">// 添加到 children 属性中</span></span><br><span class="line">  element.<span class="property">children</span> = children</span><br><span class="line">  <span class="comment">// 结束标签</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">startsWithEndTagOpen</span>(context.<span class="property">source</span>, element.<span class="property">tag</span>)) &#123;</span><br><span class="line">    <span class="comment">// 解析结束标签，并前进代码到结束标签后</span></span><br><span class="line">    <span class="title function_">parseTag</span>(context, <span class="number">1</span> <span class="comment">/* End */</span>, parent)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">emitError</span>(context, <span class="number">24</span> <span class="comment">/* X_MISSING_END_TAG */</span>, <span class="number">0</span>, element.<span class="property">loc</span>.<span class="property">start</span>);</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="property">source</span>.<span class="property">length</span> === <span class="number">0</span> &amp;&amp; element.<span class="property">tag</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;script&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> first = children[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (first &amp;&amp; <span class="title function_">startsWith</span>(first.<span class="property">loc</span>.<span class="property">source</span>, <span class="string">&#x27;&lt;!--&#x27;</span>)) &#123;</span><br><span class="line">        <span class="title function_">emitError</span>(context, <span class="number">8</span> <span class="comment">/* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新标签节点的代码位置，结束位置到结束标签后</span></span><br><span class="line">  element.<span class="property">loc</span> = <span class="title function_">getSelection</span>(context, element.<span class="property">loc</span>.<span class="property">start</span>)</span><br><span class="line">  <span class="keyword">if</span> (isPreBoundary) &#123;</span><br><span class="line">    context.<span class="property">inPre</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isVPreBoundary) &#123;</span><br><span class="line">    context.<span class="property">inVPre</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个过程中 parseElement 主要做了三件事情：解析开始标签，解析子节点，解析闭合标签。</p><p>首先，我们来看解析开始标签的过程。主要通过 <code>parseTag</code> 方法来解析并创建一个标签节点，来看它的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseTag</span>(<span class="params">context, type, parent</span>) &#123;</span><br><span class="line">  <span class="comment">// 标签打开</span></span><br><span class="line">  <span class="keyword">const</span> start = <span class="title function_">getCursor</span>(context)</span><br><span class="line">  <span class="comment">// 匹配标签文本结束的位置</span></span><br><span class="line">  <span class="keyword">const</span> match = <span class="regexp">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i</span>.<span class="title function_">exec</span>(context.<span class="property">source</span>);</span><br><span class="line">  <span class="keyword">const</span> tag = match[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> ns = context.<span class="property">options</span>.<span class="title function_">getNamespace</span>(tag, parent);</span><br><span class="line">  <span class="comment">// 前进代码到标签文本结束位置</span></span><br><span class="line">  <span class="title function_">advanceBy</span>(context, match[<span class="number">0</span>].<span class="property">length</span>);</span><br><span class="line">  <span class="comment">// 前进代码到标签文本后面的空白字符后</span></span><br><span class="line">  <span class="title function_">advanceSpaces</span>(context);</span><br><span class="line">  <span class="comment">// 保存当前状态以防我们需要用 v-pre 重新解析属性</span></span><br><span class="line">  <span class="keyword">const</span> cursor = <span class="title function_">getCursor</span>(context);</span><br><span class="line">  <span class="keyword">const</span> currentSource = context.<span class="property">source</span>;</span><br><span class="line">  <span class="comment">// 解析标签中的属性，并前进代码到属性后</span></span><br><span class="line">  <span class="keyword">let</span> props = <span class="title function_">parseAttributes</span>(context, type);</span><br><span class="line">  <span class="comment">// 检查是不是一个 pre 标签</span></span><br><span class="line">  <span class="keyword">if</span> (context.<span class="property">options</span>.<span class="title function_">isPreTag</span>(tag)) &#123;</span><br><span class="line">    context.<span class="property">inPre</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查属性中有没有 v-pre 指令</span></span><br><span class="line">  <span class="keyword">if</span> (!context.<span class="property">inVPre</span> &amp;&amp;</span><br><span class="line">    props.<span class="title function_">some</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">type</span> === <span class="number">7</span> <span class="comment">/* DIRECTIVE */</span> &amp;&amp; p.<span class="property">name</span> === <span class="string">&#x27;pre&#x27;</span>)) &#123;</span><br><span class="line">    context.<span class="property">inVPre</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 重置 context</span></span><br><span class="line">    <span class="title function_">extend</span>(context, cursor);</span><br><span class="line">    context.<span class="property">source</span> = currentSource;</span><br><span class="line">    <span class="comment">// 重新解析属性，并把 v-pre 过滤了</span></span><br><span class="line">    props = <span class="title function_">parseAttributes</span>(context, type).<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">name</span> !== <span class="string">&#x27;v-pre&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 标签闭合</span></span><br><span class="line">  <span class="keyword">let</span> isSelfClosing = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (context.<span class="property">source</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">emitError</span>(context, <span class="number">9</span> <span class="comment">/* EOF_IN_TAG */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否自闭合标签</span></span><br><span class="line">    isSelfClosing = <span class="title function_">startsWith</span>(context.<span class="property">source</span>, <span class="string">&#x27;/&gt;&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span> <span class="comment">/* End */</span> &amp;&amp; isSelfClosing) &#123;</span><br><span class="line">      <span class="comment">// 结束标签不应该是自闭和标签</span></span><br><span class="line">      <span class="title function_">emitError</span>(context, <span class="number">4</span> <span class="comment">/* END_TAG_WITH_TRAILING_SOLIDUS */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进代码到闭合标签后</span></span><br><span class="line">    <span class="title function_">advanceBy</span>(context, isSelfClosing ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tagType = <span class="number">0</span> <span class="comment">/* ELEMENT */</span>;</span><br><span class="line">  <span class="keyword">const</span> options = context.<span class="property">options</span>;</span><br><span class="line">  <span class="comment">// 接下来判断标签类型，是组件、插槽还是模板</span></span><br><span class="line">  <span class="keyword">if</span> (!context.<span class="property">inVPre</span> &amp;&amp; !options.<span class="title function_">isCustomElement</span>(tag)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否有 is 属性</span></span><br><span class="line">    <span class="keyword">const</span> hasVIs = props.<span class="title function_">some</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">type</span> === <span class="number">7</span> <span class="comment">/* DIRECTIVE */</span> &amp;&amp; p.<span class="property">name</span> === <span class="string">&#x27;is&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">isNativeTag</span> &amp;&amp; !hasVIs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!options.<span class="title function_">isNativeTag</span>(tag))</span><br><span class="line">        tagType = <span class="number">1</span> <span class="comment">/* COMPONENT */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hasVIs ||</span><br><span class="line">      <span class="title function_">isCoreComponent</span>(tag) ||</span><br><span class="line">      (options.<span class="property">isBuiltInComponent</span> &amp;&amp; options.<span class="title function_">isBuiltInComponent</span>(tag)) ||</span><br><span class="line">      <span class="regexp">/^[A-Z]/</span>.<span class="title function_">test</span>(tag) ||</span><br><span class="line">      tag === <span class="string">&#x27;component&#x27;</span>) &#123;</span><br><span class="line">      tagType = <span class="number">1</span> <span class="comment">/* COMPONENT */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tag === <span class="string">&#x27;slot&#x27;</span>) &#123;</span><br><span class="line">      tagType = <span class="number">2</span> <span class="comment">/* SLOT */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">&#x27;template&#x27;</span> &amp;&amp;</span><br><span class="line">      props.<span class="title function_">some</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p.<span class="property">type</span> === <span class="number">7</span> <span class="comment">/* DIRECTIVE */</span> &amp;&amp; <span class="title function_">isSpecialTemplateDirective</span>(p.<span class="property">name</span>));</span><br><span class="line">      &#125;)) &#123;</span><br><span class="line">      tagType = <span class="number">3</span> <span class="comment">/* TEMPLATE */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span> <span class="comment">/* ELEMENT */</span>,</span><br><span class="line">    ns,</span><br><span class="line">    tag,</span><br><span class="line">    tagType,</span><br><span class="line">    props,</span><br><span class="line">    isSelfClosing,</span><br><span class="line">    <span class="attr">children</span>: [],</span><br><span class="line">    <span class="attr">loc</span>: <span class="title function_">getSelection</span>(context, start),</span><br><span class="line">    <span class="attr">codegenNode</span>: <span class="literal">undefined</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseTag 首先匹配标签文本结束的位置，并前进代码到标签文本后面的空白字符后，然后解析标签中的属性，比如 class、style 和指令等，parseAttributes 函数的实现我就不多说了，感兴趣的同学可以自己去看，它最终会解析生成一个 props 的数组，并前进代码到属性后。</p><p>接着去检查是不是一个 pre 标签，如果是则设置 context.inPre 为 true；再去检查属性中有没有 v-pre 指令，如果有则设置 context.inVPre 为 true，并重置上下文 context 和重新解析属性；接下来再去判断是不是一个自闭和标签，并前进代码到闭合标签后；最后判断标签类型，是组件、插槽还是模板。</p><p>parseTag 最终返回的值就是一个描述标签节点的对象，其中 type 表示它是一个标签节点，tag 表示标签名称，tagType 表示标签的类型，content 表示文本的内容，isSelfClosing 表示是否是一个闭合标签，loc 表示文本的代码开头和结束的位置信息，children 是标签的子节点数组，会先初始化为空。</p><p>解析完开始标签后，再回到 parseElement，接下来第二步就是解析子节点，它把解析好的 element 节点添加到 ancestors 数组中，然后执行 parseChildren 去解析子节点，并传入 ancestors。</p><p>如果有嵌套的标签，那么就会递归执行 parseElement，可以看到，在 parseElement 的一开始，我们能获取 ancestors 数组的最后一个值拿到父元素的标签节点，这个就是我们在执行 parseChildren 前添加到数组尾部的。</p><p>解析完子节点后，我们再把 element 从 ancestors 中弹出，然后把 children 数组添加到 element.children 中，同时也把代码前进到子节点的末尾。</p><p>最后，就是解析结束标签，并前进代码到结束标签后，然后更新标签节点的代码位置。parseElement 最终返回的值就是这样一个标签节点 element。</p><p>其实 HTML 的嵌套结构的解析过程，就是一个递归解析元素节点的过程，为了维护父子关系，当需要解析子节点时，我们就把当前节点入栈，子节点解析完毕后，我们就把当前节点出栈，因此 ancestors 的设计就是一个栈的数据结构，整个过程是一个不断入栈和出栈的过程。</p><p>通过不断地递归解析，我们就可以完整地解析整个模板，并且标签类型的 AST 节点会保持对子节点数组的引用，这样就构成了一个树形的数据结构，所以整个解析过程构造出的 AST 节点数组就能很好地映射整个模板的 DOM 结构。</p><h4 id="空白字符管理"><a href="#空白字符管理" class="headerlink" title="空白字符管理"></a>空白字符管理</h4><p>在前面的解析过程中，有些时候我们会遇到空白字符的情况，比如前面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>div 标签到下一行会有一个换行符，hello 标签前面也有空白字符，这些空白字符在解析的过程中会被当作文本节点解析处理。但这些空白节点显然是没有什么意义的，所以我们需要移除这些节点，减少后续对这些没用意义的节点的处理，以提高编译效率。</p><p>我们先来看一下空白字符管理相关逻辑代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseChildren</span>(<span class="params">context, mode, ancestors</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> parent = <span class="title function_">last</span>(ancestors)</span><br><span class="line">  <span class="keyword">const</span> ns = parent ? parent.<span class="property">ns</span> : <span class="number">0</span> <span class="comment">/* HTML */</span></span><br><span class="line">  <span class="keyword">const</span> nodes = []</span><br><span class="line">  <span class="comment">// 自顶向下分析代码，生成 nodes</span></span><br><span class="line">  <span class="keyword">let</span> removedWhitespace = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (mode !== <span class="number">2</span> <span class="comment">/* RAWTEXT */</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!context.<span class="property">inPre</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = nodes[i]</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">2</span> <span class="comment">/* TEXT */</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="regexp">/[^\t\r\n\f ]/</span>.<span class="title function_">test</span>(node.<span class="property">content</span>)) &#123;</span><br><span class="line">            <span class="comment">// 匹配空白字符</span></span><br><span class="line">            <span class="keyword">const</span> prev = nodes[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">const</span> next = nodes[i + <span class="number">1</span>]</span><br><span class="line">            <span class="comment">// 如果空白字符是开头或者结尾节点</span></span><br><span class="line">            <span class="comment">// 或者空白字符与注释节点相连</span></span><br><span class="line">            <span class="comment">// 或者空白字符在两个元素之间并包含换行符</span></span><br><span class="line">            <span class="comment">// 那么这些空白字符节点都应该被移除</span></span><br><span class="line">            <span class="keyword">if</span> (!prev ||</span><br><span class="line">              !next ||</span><br><span class="line">              prev.<span class="property">type</span> === <span class="number">3</span> <span class="comment">/* COMMENT */</span> ||</span><br><span class="line">              next.<span class="property">type</span> === <span class="number">3</span> <span class="comment">/* COMMENT */</span> ||</span><br><span class="line">              (prev.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">                next.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">                <span class="regexp">/[\r\n]/</span>.<span class="title function_">test</span>(node.<span class="property">content</span>))) &#123;</span><br><span class="line">              removedWhitespace = <span class="literal">true</span></span><br><span class="line">              nodes[i] = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则压缩这些空白字符到一个空格</span></span><br><span class="line">              node.<span class="property">content</span> = <span class="string">&#x27; &#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 替换内容中的空白空间到一个空格</span></span><br><span class="line">            node.<span class="property">content</span> = node.<span class="property">content</span>.<span class="title function_">replace</span>(<span class="regexp">/[\t\r\n\f ]+/g</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; node.<span class="property">type</span> === <span class="number">3</span> <span class="comment">/* COMMENT */</span>) &#123;</span><br><span class="line">          <span class="comment">// 生产环境移除注释节点</span></span><br><span class="line">          removedWhitespace = <span class="literal">true</span></span><br><span class="line">          nodes[i] = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (parent &amp;&amp; context.<span class="property">options</span>.<span class="title function_">isPreTag</span>(parent.<span class="property">tag</span>)) &#123;</span><br><span class="line">      <span class="comment">// 根据 HTML 规范删除前导换行符</span></span><br><span class="line">      <span class="keyword">const</span> first = nodes[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">if</span> (first &amp;&amp; first.<span class="property">type</span> === <span class="number">2</span> <span class="comment">/* TEXT */</span>) &#123;</span><br><span class="line">        first.<span class="property">content</span> = first.<span class="property">content</span>.<span class="title function_">replace</span>(<span class="regexp">/^\r?\n/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 过滤空白字符节点</span></span><br><span class="line">  <span class="keyword">return</span> removedWhitespace ? nodes.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>) : nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建-AST-根节点"><a href="#创建-AST-根节点" class="headerlink" title="创建 AST 根节点"></a>创建 AST 根节点</h3><p>子节点解析完毕，baseParse 过程就剩最后一步创建 AST 根节点了，我们来看一下<code> createRoot</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createRoot</span>(<span class="params">children, loc = locStub</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">0</span> <span class="comment">/* ROOT */</span>,</span><br><span class="line">    children,</span><br><span class="line">    <span class="attr">helpers</span>: [],</span><br><span class="line">    <span class="attr">components</span>: [],</span><br><span class="line">    <span class="attr">directives</span>: [],</span><br><span class="line">    <span class="attr">hoists</span>: [],</span><br><span class="line">    <span class="attr">imports</span>: [],</span><br><span class="line">    <span class="attr">cached</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">temps</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">codegenNode</span>: <span class="literal">undefined</span>,</span><br><span class="line">    loc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createRoot 的实现非常简单，它就是返回一个 JavaScript 对象，作为 AST 根节点。其中 type 表示它是一个根节点类型，children 是我们前面解析的子节点数组。除此之外，这个根节点还添加了其它的属性，当前我们并不需要搞清楚每一个属性代表的含义，这些属性我们在分析后续的处理流程中会介绍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的，到这里我们这一节的学习也要结束啦，通过这节课的学习，你应该掌握 Vue.js 编译过程的第一步，即<strong>把 template 解析生成 AST 对象</strong>，整个解析过程是一个自顶向下的分析过程，也就是从代码开始，通过语法分析，找到对应的解析处理逻辑，创建 AST 节点，处理的过程中也在不断前进代码，更新解析上下文，最终根据生成的 AST 节点数组创建 AST 根节点。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;compiler-core&#x2F;src&#x2F;parse.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;ast.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节课我们依然要&lt;strong&gt;解析 template 生成 AST 背后的实现原理&lt;/strong&gt;，之前，我们知道了baseParse 主要就做三件事情：&lt;strong&gt;创建解析上下文&lt;/strong&gt;，&lt;strong&gt;解析子节点&lt;/strong&gt;，&lt;strong&gt;创建 AST 根节点&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="AST" scheme="https://xiaozhouguo.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>AST转换-AST节点内部做了哪些转换？- 上篇</title>
    <link href="https://xiaozhouguo.github.io/2022/08/03/vue3/ast-transform-one/"/>
    <id>https://xiaozhouguo.github.io/2022/08/03/vue3/ast-transform-one/</id>
    <published>2022-08-03T02:05:13.000Z</published>
    <updated>2022-10-24T06:42:03.782Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们学习了 template 的解析过程，最终拿到了一个 AST 节点对象。这个对象是对模板的完整描述，但是它还不能直接拿来生成代码，因为它的语义化还不够，没有包含和编译优化的相关属性，所以还需要进一步转换。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>AST 转换过程非常复杂，有非常多的分支逻辑，为了方便你理解它的核心流程，我精心准备了一个示例，我们只分析示例场景在 AST 转换过程中的相关代码逻辑，不过我希望你在学习完之后，可以举一反三，对示例做一些修改，学习更多场景的代码逻辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&gt;hello &#123;&#123; msg + test &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>static<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>static<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例中，我们有普通的 DOM 节点，有组件节点，有 v-bind 指令，有 v-if 指令，有文本节点，也有表达式节点。</p><p>对于这个模板，我们通过 parse 生成一个 AST 对象，接下来我们就来分析这个 AST 对象的转换都做了哪些事情。</p><p>我们会先通过 <code>getBaseTransformPreset</code> 方法获取节点和指令转换的方法，然后调用 transform 方法做 AST 转换，并且把这些节点和指令的转换方法作为配置的属性参数传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取节点和指令转换的方法</span></span><br><span class="line"><span class="keyword">const</span> [nodeTransforms, directiveTransforms] = <span class="title function_">getBaseTransformPreset</span>()</span><br><span class="line"><span class="comment">// AST 转换</span></span><br><span class="line"><span class="title function_">transform</span>(ast, <span class="title function_">extend</span>(&#123;&#125;, options, &#123;</span><br><span class="line">  prefixIdentifiers,</span><br><span class="line">  <span class="attr">nodeTransforms</span>: [</span><br><span class="line">    ...nodeTransforms,</span><br><span class="line">    ...(options.<span class="property">nodeTransforms</span> || []) <span class="comment">// 用户自定义  transforms</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">directiveTransforms</span>: <span class="title function_">extend</span>(&#123;&#125;, </span><br><span class="line">    directiveTransforms, options.<span class="property">directiveTransforms</span> || &#123;&#125; <span class="comment">// 用户自定义 transforms</span></span><br><span class="line">  )&#125;</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>我们先来看一下 getBaseTransformPreset 返回哪些节点和指令的转换方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getBaseTransformPreset</span>(<span class="params">prefixIdentifiers</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    [</span><br><span class="line">      transformOnce,</span><br><span class="line">      transformIf,</span><br><span class="line">      transformFor,</span><br><span class="line">      transformExpression,</span><br><span class="line">      transformSlotOutlet,</span><br><span class="line">      transformElement,</span><br><span class="line">      trackSlotScopes,</span><br><span class="line">      transformText</span><br><span class="line">    ],</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">on</span>: transformOn,</span><br><span class="line">      <span class="attr">bind</span>: transformBind,</span><br><span class="line">      <span class="attr">model</span>: transformModel</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并不需要你进一步去看每个转换函数的实现，只要大致了解有哪些转换函数即可，这些转换函数会在后续执行 transform 的时候调用。</p><blockquote><p>注意这里我们只分析在 Node.js 环境下的编译过程。Web 环境的编译结果可能会有一些差别，我们会在后续章节说明。</p></blockquote><p>我们主要来看 transform 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">transform</span>(<span class="params">root, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">createTransformContext</span>(root, options)</span><br><span class="line">  <span class="title function_">traverseNode</span>(root, context)</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">hoistStatic</span>) &#123;</span><br><span class="line">    <span class="title function_">hoistStatic</span>(root, context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">ssr</span>) &#123;</span><br><span class="line">    <span class="title function_">createRootCodegen</span>(root, context)</span><br><span class="line">  &#125;</span><br><span class="line">  root.<span class="property">helpers</span> = [...context.<span class="property">helpers</span>]</span><br><span class="line">  root.<span class="property">components</span> = [...context.<span class="property">components</span>]</span><br><span class="line">  root.<span class="property">directives</span> = [...context.<span class="property">directives</span>]</span><br><span class="line">  root.<span class="property">imports</span> = [...context.<span class="property">imports</span>]</span><br><span class="line">  root.<span class="property">hoists</span> = context.<span class="property">hoists</span></span><br><span class="line">  root.<span class="property">temps</span> = context.<span class="property">temps</span></span><br><span class="line">  root.<span class="property">cached</span> = context.<span class="property">cached</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transform 的核心流程主要有四步：<strong>创建 transform 上下文、遍历 AST 节点、静态提升以及创建根代码生成节点</strong>。接下来，我们就好好分析一下每一步主要做了什么。</p><h3 id="创建-transform-上下文"><a href="#创建-transform-上下文" class="headerlink" title="创建 transform 上下文"></a>创建 transform 上下文</h3><p>首先，我们来看创建 transform 上下文的过程，其实和 parse 过程一样，在 transform 阶段会创建一个上下文对象，它的实现过程是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTransformContext</span>(<span class="params">root, &#123; prefixIdentifiers = <span class="literal">false</span>, hoistStatic = <span class="literal">false</span>, cacheHandlers = <span class="literal">false</span>, nodeTransforms = [], directiveTransforms = &#123;&#125;, transformHoist = <span class="literal">null</span>, isBuiltInComponent = NOOP, expressionPlugins = [], scopeId = <span class="literal">null</span>, ssr = <span class="literal">false</span>, onError = defaultOnError &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = &#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    prefixIdentifiers,</span><br><span class="line">    hoistStatic,</span><br><span class="line">    cacheHandlers,</span><br><span class="line">    nodeTransforms,</span><br><span class="line">    directiveTransforms,</span><br><span class="line">    transformHoist,</span><br><span class="line">    isBuiltInComponent,</span><br><span class="line">    expressionPlugins,</span><br><span class="line">    scopeId,</span><br><span class="line">    ssr,</span><br><span class="line">    onError,</span><br><span class="line">    <span class="comment">// 状态数据</span></span><br><span class="line">    root,</span><br><span class="line">    <span class="attr">helpers</span>: <span class="keyword">new</span> <span class="title class_">Set</span>(),</span><br><span class="line">    <span class="attr">components</span>: <span class="keyword">new</span> <span class="title class_">Set</span>(),</span><br><span class="line">    <span class="attr">directives</span>: <span class="keyword">new</span> <span class="title class_">Set</span>(),</span><br><span class="line">    <span class="attr">hoists</span>: [],</span><br><span class="line">    <span class="attr">imports</span>: <span class="keyword">new</span> <span class="title class_">Set</span>(),</span><br><span class="line">    <span class="attr">temps</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">cached</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">identifiers</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">scopes</span>: &#123;</span><br><span class="line">      <span class="attr">vFor</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">vSlot</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">vPre</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">vOnce</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">parent</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">currentNode</span>: root,</span><br><span class="line">    <span class="attr">childIndex</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">    <span class="title function_">helper</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      context.<span class="property">helpers</span>.<span class="title function_">add</span>(name)</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">helperString</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`_<span class="subst">$&#123;helperNameMap[context.helper(name)]&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">replaceNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">      context.<span class="property">parent</span>.<span class="property">children</span>[context.<span class="property">childIndex</span>] = context.<span class="property">currentNode</span> = node</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">removeNode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = context.<span class="property">parent</span>.<span class="property">children</span></span><br><span class="line">      <span class="keyword">const</span> removalIndex = node</span><br><span class="line">        ? list.<span class="title function_">indexOf</span>(node)</span><br><span class="line">        : context.<span class="property">currentNode</span></span><br><span class="line">          ? context.<span class="property">childIndex</span></span><br><span class="line">          : -<span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (!node || node === context.<span class="property">currentNode</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除当前节点</span></span><br><span class="line">        context.<span class="property">currentNode</span> = <span class="literal">null</span></span><br><span class="line">        context.<span class="title function_">onNodeRemoved</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 移除兄弟节点</span></span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">childIndex</span> &gt; removalIndex) &#123;</span><br><span class="line">          context.<span class="property">childIndex</span>--</span><br><span class="line">          context.<span class="title function_">onNodeRemoved</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移除节点</span></span><br><span class="line">      context.<span class="property">parent</span>.<span class="property">children</span>.<span class="title function_">splice</span>(removalIndex, <span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onNodeRemoved</span>: <span class="function">() =&gt;</span> &#123; &#125;,</span><br><span class="line">    <span class="title function_">addIdentifiers</span>(<span class="params">exp</span>) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">removeIdentifiers</span>(<span class="params">exp</span>) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">hoist</span>(<span class="params">exp</span>) &#123;</span><br><span class="line">      context.<span class="property">hoists</span>.<span class="title function_">push</span>(exp)</span><br><span class="line">      <span class="keyword">const</span> identifier = <span class="title function_">createSimpleExpression</span>(<span class="string">`_hoisted_<span class="subst">$&#123;context.hoists.length&#125;</span>`</span>, <span class="literal">false</span>, exp.<span class="property">loc</span>, <span class="literal">true</span>)</span><br><span class="line">      identifier.<span class="property">hoisted</span> = exp</span><br><span class="line">      <span class="keyword">return</span> identifier</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">cache</span>(<span class="params">exp, isVNode = <span class="literal">false</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createCacheExpression</span>(++context.<span class="property">cached</span>, exp, isVNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，这个上下文对象 context 维护了 transform 过程的一些配置，比如前面提到的节点和指令的转换函数等；还维护了 transform 过程的一些状态数据，比如当前处理的 AST 节点，当前 AST 节点在子节点中的索引，以及当前 AST 节点的父节点等。此外，context 还包含了在转换过程中可能会调用的一些辅助函数，和一些修改 context 对象的方法。</p><p>你现在也没必要去了解它的每一个属性和方法的含义，只需要你大致有一个印象即可，未来分析某个具体场景，再回过头了解它们的实现即可。</p><p>创建完上下文对象后，接下来就需要遍历 AST 节点。</p><h3 id="遍历-AST-节点"><a href="#遍历-AST-节点" class="headerlink" title="遍历 AST 节点"></a>遍历 AST 节点</h3><p>遍历 AST 节点的过程很关键，因为核心的转换过程就是在遍历中实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">traverseNode</span>(<span class="params">node, context</span>) &#123;</span><br><span class="line">  context.<span class="property">currentNode</span> = node</span><br><span class="line">  <span class="comment">// 节点转换函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; nodeTransforms &#125; = context</span><br><span class="line">  <span class="keyword">const</span> exitFns = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodeTransforms.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 有些转换函数会设计一个退出函数，在处理完子节点后执行</span></span><br><span class="line">    <span class="keyword">const</span> onExit = nodeTransforms[i](node, context)</span><br><span class="line">    <span class="keyword">if</span> (onExit) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isArray</span>(onExit)) &#123;</span><br><span class="line">        exitFns.<span class="title function_">push</span>(...onExit)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        exitFns.<span class="title function_">push</span>(onExit)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!context.<span class="property">currentNode</span>) &#123;</span><br><span class="line">      <span class="comment">// 节点被移除</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 因为在转换的过程中节点可能被替换，恢复到之前的节点</span></span><br><span class="line">      node = context.<span class="property">currentNode</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (node.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> <span class="comment">/* COMMENT */</span>:</span><br><span class="line">      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要导入 createComment 辅助函数</span></span><br><span class="line">        context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_COMMENT</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> <span class="comment">/* INTERPOLATION */</span>:</span><br><span class="line">      <span class="comment">// 需要导入 toString 辅助函数</span></span><br><span class="line">      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;</span><br><span class="line">        context.<span class="title function_">helper</span>(<span class="variable constant_">TO_DISPLAY_STRING</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span> <span class="comment">/* IF */</span>:</span><br><span class="line">      <span class="comment">// 递归遍历每个分支节点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">branches</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">traverseNode</span>(node.<span class="property">branches</span>[i], context)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span> <span class="comment">/* IF_BRANCH */</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span> <span class="comment">/* FOR */</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> <span class="comment">/* ELEMENT */</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="comment">/* ROOT */</span>:</span><br><span class="line">      <span class="comment">// 遍历子节点</span></span><br><span class="line">      <span class="title function_">traverseChildren</span>(node, context)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行转换函数返回的退出函数</span></span><br><span class="line">  <span class="keyword">let</span> i = exitFns.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    exitFns[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，traverseNode 函数的基本思路就是递归遍历 AST 节点，针对每个节点执行一系列的转换函数，有些转换函数还会设计一个退出函数，当你执行转换函数后，它会返回一个新函数，然后在你处理完子节点后再执行这些退出函数，这是因为有些逻辑的处理需要依赖子节点的处理结果才能继续执行。</p><p>Vue.js 内部大概内置了八种转换函数，分别处理指令、表达式、元素节点、文本节点等不同的特性。限于篇幅，我不会介绍所有转换函数，感兴趣的同学可以后续自行分析。</p><p>下面我会介绍四种类型的转换函数，并结合前面的示例来分析。</p><h4 id="Element-节点转换函数"><a href="#Element-节点转换函数" class="headerlink" title="Element 节点转换函数"></a>Element 节点转换函数</h4><p>首先，我们来看一下 Element 节点转换函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">transformElement</span> = (<span class="params">node, context</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(node.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span> &amp;&amp;</span><br><span class="line">    (node.<span class="property">tagType</span> === <span class="number">0</span> <span class="comment">/* ELEMENT */</span> ||</span><br><span class="line">      node.<span class="property">tagType</span> === <span class="number">1</span> <span class="comment">/* COMPONENT */</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回退出函数，在所有子表达式处理并合并后执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">postTransformElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 转换的目标是创建一个实现 VNodeCall 接口的代码生成节点</span></span><br><span class="line">    <span class="keyword">const</span> &#123; tag, props &#125; = node</span><br><span class="line">    <span class="keyword">const</span> isComponent = node.<span class="property">tagType</span> === <span class="number">1</span> <span class="comment">/* COMPONENT */</span></span><br><span class="line">    <span class="keyword">const</span> vnodeTag = isComponent</span><br><span class="line">      ? <span class="title function_">resolveComponentType</span>(node, context)</span><br><span class="line">      : <span class="string">`&quot;<span class="subst">$&#123;tag&#125;</span>&quot;`</span></span><br><span class="line">    <span class="keyword">const</span> isDynamicComponent = </span><br><span class="line">          <span class="title function_">isObject</span>(vnodeTag) &amp;&amp; vnodeTag.<span class="property">callee</span> === <span class="variable constant_">RESOLVE_DYNAMIC_COMPONENT</span></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">let</span> vnodeProps</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    <span class="keyword">let</span> vnodeChildren</span><br><span class="line">    <span class="comment">// 标记更新的类型标识，用于运行时优化</span></span><br><span class="line">    <span class="keyword">let</span> vnodePatchFlag</span><br><span class="line">    <span class="keyword">let</span> patchFlag = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 动态绑定的属性</span></span><br><span class="line">    <span class="keyword">let</span> vnodeDynamicProps</span><br><span class="line">    <span class="keyword">let</span> dynamicPropNames</span><br><span class="line">    <span class="keyword">let</span> vnodeDirectives</span><br><span class="line">    <span class="comment">// 动态组件、svg、foreignObject 标签以及动态绑定 key prop 的节点都被视作一个 Block</span></span><br><span class="line">    <span class="keyword">let</span> shouldUseBlock =</span><br><span class="line">      isDynamicComponent ||</span><br><span class="line">      (!isComponent &amp;&amp;</span><br><span class="line">        (tag === <span class="string">&#x27;svg&#x27;</span> ||</span><br><span class="line">          tag === <span class="string">&#x27;foreignObject&#x27;</span> ||</span><br><span class="line">          <span class="title function_">findProp</span>(node, <span class="string">&#x27;key&#x27;</span>, <span class="literal">true</span>)))</span><br><span class="line">    <span class="comment">// 处理 props</span></span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> propsBuildResult = <span class="title function_">buildProps</span>(node, context)</span><br><span class="line">      vnodeProps = propsBuildResult.<span class="property">props</span></span><br><span class="line">      patchFlag = propsBuildResult.<span class="property">patchFlag</span></span><br><span class="line">      dynamicPropNames = propsBuildResult.<span class="property">dynamicPropNames</span></span><br><span class="line">      <span class="keyword">const</span> directives = propsBuildResult.<span class="property">directives</span></span><br><span class="line">      vnodeDirectives =</span><br><span class="line">        directives &amp;&amp; directives.<span class="property">length</span></span><br><span class="line">          ? <span class="title function_">createArrayExpression</span>(directives.<span class="title function_">map</span>(</span><br><span class="line">          <span class="function"><span class="params">dir</span> =&gt;</span> <span class="title function_">buildDirectiveArgs</span>(dir, context))</span><br><span class="line">            )</span><br><span class="line">          : <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 children</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vnodeTag === <span class="variable constant_">KEEP_ALIVE</span>) &#123;</span><br><span class="line">        <span class="comment">// 把 KeepAlive 看做是一个 Block，这样可以避免它的子节点的动态节点被父 Block 收集</span></span><br><span class="line">        shouldUseBlock = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 2. 确保它始终更新</span></span><br><span class="line">        patchFlag |= <span class="number">1024</span> <span class="comment">/* DYNAMIC_SLOTS */</span></span><br><span class="line">        <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; node.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          context.<span class="title function_">onError</span>(<span class="title function_">createCompilerError</span>(<span class="number">42</span> <span class="comment">/* X_KEEP_ALIVE_INVALID_CHILDREN */</span>, &#123;</span><br><span class="line">            <span class="attr">start</span>: node.<span class="property">children</span>[<span class="number">0</span>].<span class="property">loc</span>.<span class="property">start</span>,</span><br><span class="line">            <span class="attr">end</span>: node.<span class="property">children</span>[node.<span class="property">children</span>.<span class="property">length</span> - <span class="number">1</span>].<span class="property">loc</span>.<span class="property">end</span>,</span><br><span class="line">            <span class="attr">source</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">          &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> shouldBuildAsSlots = isComponent &amp;&amp;</span><br><span class="line">        <span class="comment">// Teleport不是一个真正的组件，它有专门的运行时处理</span></span><br><span class="line">        vnodeTag !== <span class="variable constant_">TELEPORT</span> &amp;&amp;</span><br><span class="line">        vnodeTag !== <span class="variable constant_">KEEP_ALIVE</span></span><br><span class="line">      <span class="keyword">if</span> (shouldBuildAsSlots) &#123;</span><br><span class="line">        <span class="comment">// 组件有 children，则处理插槽</span></span><br><span class="line">        <span class="keyword">const</span> &#123; slots, hasDynamicSlots &#125; = <span class="title function_">buildSlots</span>(node, context)</span><br><span class="line">        vnodeChildren = slots</span><br><span class="line">        <span class="keyword">if</span> (hasDynamicSlots) &#123;</span><br><span class="line">          patchFlag |= <span class="number">1024</span> <span class="comment">/* DYNAMIC_SLOTS */</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">children</span>.<span class="property">length</span> === <span class="number">1</span> &amp;&amp; vnodeTag !== <span class="variable constant_">TELEPORT</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = node.<span class="property">children</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> type = child.<span class="property">type</span></span><br><span class="line">        <span class="keyword">const</span> hasDynamicTextChild = type === <span class="number">5</span> <span class="comment">/* INTERPOLATION */</span> ||</span><br><span class="line">          type === <span class="number">8</span> <span class="comment">/* COMPOUND_EXPRESSION */</span></span><br><span class="line">        <span class="keyword">if</span> (hasDynamicTextChild &amp;&amp; !<span class="title function_">getStaticType</span>(child)) &#123;</span><br><span class="line">          patchFlag |= <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果只是一个普通文本节点、插值或者表达式，直接把节点赋值给 vnodeChildren</span></span><br><span class="line">        <span class="keyword">if</span> (hasDynamicTextChild || type === <span class="number">2</span> <span class="comment">/* TEXT */</span>) &#123;</span><br><span class="line">          vnodeChildren = child</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          vnodeChildren = node.<span class="property">children</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeChildren = node.<span class="property">children</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 patchFlag 和 dynamicPropNames</span></span><br><span class="line">    <span class="keyword">if</span> (patchFlag !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (patchFlag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          vnodePatchFlag = patchFlag + <span class="string">` /* <span class="subst">$&#123;PatchFlagNames[patchFlag]&#125;</span> */`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 获取 flag 对应的名字，生成注释，方便理解生成代码对应节点的 pathFlag</span></span><br><span class="line">          <span class="keyword">const</span> flagNames = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">PatchFlagNames</span>)</span><br><span class="line">            .<span class="title function_">map</span>(<span class="title class_">Number</span>)</span><br><span class="line">            .<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">0</span> &amp;&amp; patchFlag &amp; n)</span><br><span class="line">            .<span class="title function_">map</span>(<span class="function"><span class="params">n</span> =&gt;</span> <span class="title class_">PatchFlagNames</span>[n])</span><br><span class="line">            .<span class="title function_">join</span>(<span class="string">`, `</span>)</span><br><span class="line">          vnodePatchFlag = patchFlag + <span class="string">` /* <span class="subst">$&#123;flagNames&#125;</span> */`</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodePatchFlag = <span class="title class_">String</span>(patchFlag)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dynamicPropNames &amp;&amp; dynamicPropNames.<span class="property">length</span>) &#123;</span><br><span class="line">        vnodeDynamicProps = <span class="title function_">stringifyDynamicPropNames</span>(dynamicPropNames)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">codegenNode</span> = <span class="title function_">createVNodeCall</span>(context, vnodeTag, vnodeProps, </span><br><span class="line">         vnodeChildren, vnodePatchFlag, vnodeDynamicProps,</span><br><span class="line">         vnodeDirectives, !!shouldUseBlock, <span class="literal">false</span> <span class="comment">/* disableTracking */</span>,</span><br><span class="line">         node.<span class="property">loc</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只有当 AST 节点是组件或者普通元素节点时，才会返回一个退出函数，而且它会在该节点的子节点逻辑处理完毕后执行。</p><p>分析这个退出函数前，我们需要知道节点函数的转换目标，即创建一个实现 VNodeCall 接口的代码生成节点，也就是说，生成这个代码生成节点后，后续的代码生成阶段可以根据这个节点对象生成目标代码。</p><p>知道了这个目标，我们再去理解 transformElement 函数的实现就不难了。</p><p>首先，<strong>判断这个节点是不是一个 Block 节点</strong>。</p><p>为了运行时的更新优化，Vue.js 3.0 设计了一个 Block tree 的概念。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，极大优化了 diff 的效率，模板的动静比越大，这个优化就会越明显。</p><p>因此在编译阶段，我们需要找出哪些节点可以构成一个 Block，<strong>其中动态组件、svg、foreignObject 标签以及动态绑定的 prop 的节点都被视作一个 Block</strong>。</p><p>其次，<strong>是处理节点的 props</strong>。</p><p>这个过程主要是从 AST 节点的 props 对象中进一步解析出指令 vnodeDirectives、动态属性 dynamicPropNames，以及更新标识 patchFlag。patchFlag 主要用于标识节点更新的类型，在组件更新的优化中会用到，我们在后续章节会详细讲。</p><p>接着，<strong>是处理节点的 children</strong>。</p><p>对于一个组件节点而言，如果它有子节点，则说明是组件的插槽，另外还会有对一些内置组件比如 KeepAlive、Teleport 的处理逻辑。</p><p>对于一个普通元素节点，我们通常直接拿节点的 children 属性给 vnodeChildren 即可，但有一种特殊情况，<strong>如果节点只有一个子节点</strong>，<strong>并且是一个普通文本节点</strong>、<strong>插值或者表达式</strong>，<strong>那么直接把节点赋值给 vnodeChildren</strong>。</p><p>然后，<strong>会对前面解析 props 求得的 patchFlag 和 dynamicPropNames 做进一步处理</strong>。</p><p>在这个过程中，我们会根据 patchFlag 的值从 PatchFlagNames 中获取 flag 对应的名字，从而生成注释，因为 patchFlag 本身就是一个个数字，通过名字注释的方式，我们就可以一眼从最终生成的代码中了解到 patchFlag 代表的含义。</p><p>另外，我们还会把数组 dynamicPropNames 转化生成 vnodeDynamicProps 字符串，便于后续对节点生成代码逻辑的处理。</p><p>最后，<strong>通过 createVNodeCall 创建了实现 VNodeCall 接口的代码生成节点</strong>，我们来看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createVNodeCall</span>(<span class="params">context, tag, props, children, patchFlag, dynamicProps,   directives, isBlock = <span class="literal">false</span>, disableTracking = <span class="literal">false</span>, loc = locStub</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlock) &#123;</span><br><span class="line">      context.<span class="title function_">helper</span>(<span class="variable constant_">OPEN_BLOCK</span>)</span><br><span class="line">      context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_BLOCK</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_VNODE</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (directives) &#123;</span><br><span class="line">      context.<span class="title function_">helper</span>(<span class="variable constant_">WITH_DIRECTIVES</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">13</span> <span class="comment">/* VNODE_CALL */</span>,</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    directives,</span><br><span class="line">    isBlock,</span><br><span class="line">    disableTracking,</span><br><span class="line">    loc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createVNodeCall 的实现很简单，它最后返回了一个对象，包含了传入的参数数据。这里要注意 context.helper 函数的调用，它会把一些 Symbol 对象添加到 context.helpers 数组中，目的是为了后续代码生成阶段，生成一些辅助代码。</p><p>对于我们示例中的根节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  // ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它转换后生成的 node.codegenNode ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;directives&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dynamicProps&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isBlock&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isForBlock&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;patchFlag&quot;</span><span class="punctuation">:</span> undefined<span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 属性相关</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;div&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">13</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个 codegenNode 相比之前的 AST 节点对象，多了很多和编译优化相关的属性，它们会在代码生成阶段会起到非常重要作用，在后续的章节你就可以深入了解到。</p><p>这个 codegenNode 相比之前的 AST 节点对象，多了很多和编译优化相关的属性，它们会在代码生成阶段会起到非常重要作用，在后续的章节你就可以深入了解到。</p><h4 id="表达式节点转换函数"><a href="#表达式节点转换函数" class="headerlink" title="表达式节点转换函数"></a>表达式节点转换函数</h4><p>接下来，我们来看一下表达式节点转换函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">transformExpression</span> = (<span class="params">node, context</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">5</span> <span class="comment">/* INTERPOLATION */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理插值中的动态表达式</span></span><br><span class="line">    node.<span class="property">content</span> = <span class="title function_">processExpression</span>(node.<span class="property">content</span>, context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">type</span> === <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理元素指令中的动态表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">props</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> dir = node.<span class="property">props</span>[i]</span><br><span class="line">      <span class="comment">// v-on 和 v-for 不处理，因为它们都有各自的处理逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (dir.<span class="property">type</span> === <span class="number">7</span> <span class="comment">/* DIRECTIVE */</span> &amp;&amp; dir.<span class="property">name</span> !== <span class="string">&#x27;for&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> exp = dir.<span class="property">exp</span></span><br><span class="line">        <span class="keyword">const</span> arg = dir.<span class="property">arg</span></span><br><span class="line">        <span class="keyword">if</span> (exp &amp;&amp;</span><br><span class="line">          exp.<span class="property">type</span> === <span class="number">4</span> <span class="comment">/* SIMPLE_EXPRESSION */</span> &amp;&amp;</span><br><span class="line">          !(dir.<span class="property">name</span> === <span class="string">&#x27;on&#x27;</span> &amp;&amp; arg)) &#123;</span><br><span class="line">          dir.<span class="property">exp</span> = <span class="title function_">processExpression</span>(exp, context, dir.<span class="property">name</span> === <span class="string">&#x27;slot&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arg &amp;&amp; arg.<span class="property">type</span> === <span class="number">4</span> <span class="comment">/* SIMPLE_EXPRESSION */</span> &amp;&amp; !arg.<span class="property">isStatic</span>) &#123;</span><br><span class="line">          dir.<span class="property">arg</span> = <span class="title function_">processExpression</span>(arg, context)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于表达式本身不会再有子节点，所以它也不需要退出函数，直接在进入函数时做转换处理即可。</p><p>需要注意的是，<strong>只有在 Node.js 环境下的编译或者是 Web 端的非生产环境下才会执行 transformExpression</strong>，原因我稍后会告诉你。</p><p>transformExpression 主要做的事情就是转换插值和元素指令中的动态表达式，把简单的表达式对象转换成复合表达式对象，内部主要是通过 processExpression 函数完成。举个例子，比如这个模板：<code>&#123;&#123; msg + test &#125;&#125;</code>，它执行 parse 后生成的表达式节点 node.content 值为一个简单的表达式对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isStatic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isConstant&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;msg + test&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>经过 processExpression 处理后，node.content 的值变成了一个复合表达式对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isConstant&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_ctx.msg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isStatic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot; + &quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isConstant&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_ctx.test&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isStatic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;identifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里，我们重点关注对象中的 children 属性，它是一个长度为 3 的数组，其实就是把表达式<code>msg + test</code>拆成了三部分，其中变量 msg 和 test 对应都加上了前缀 _ctx。</p><p>那么为什么需要加这个前缀呢？</p><p>我们就要想到模板中引用的的 msg 和 test 对象最终都是在组件实例中访问的，但为了书写模板方便，Vue.js 并没有让我们在模板中手动加组件实例的前缀，例如：<code>&#123;&#123; this.msg + this.test &#125;&#125;</code>，这样写起来就会不够方便，但如果用 JSX 写的话，通常要手动写 this。</p><p>你可能会有疑问，为什么 Vue.js 2.x 编译的结果没有 _ctx 前缀呢？这是因为 Vue.js 2.x 的编译结果使用了”黑魔法“ with，比如上述模板，在 Vue.js 2.x 最终编译的结果：<code>with(this)&#123;return _s(msg + test)&#125;</code>。</p><p>它利用 with 的特性动态去 this 中查找 msg 和 test 属性，所以不需要手动加前缀。</p><p>但是，Vue.js 3.0 在 Node.js 端的编译结果舍弃了 with，它会在 processExpression 过程中对表达式动态分析，给该加前缀的地方加上前缀。</p><p>processExpression 的详细实现我们不会分析，但你需要知道，这个过程肯定有一定的成本，因为它内部依赖了 <code>@babel/parser</code> 库去解析表达式生成 AST 节点，并依赖了 <code>estree-walker</code> 库去遍历这个 AST 节点，然后对节点分析去判断是否需要加前缀，接着对 AST 节点修改，最终转换生成新的表达式对象。</p><blockquote><p>@babel&#x2F;parser 这个库通常是在 Node.js 端用的，而且这库本身体积非常大，如果打包进 Vue.js 的话会让包体积膨胀 4 倍，所以我们并不会在生产环境的 Web 端引入这个库，Web 端生产环境下的运行时编译最终仍然会用 with 的方式。</p></blockquote><p>因为用 with 的话就完全不需要对表达式做转换了，这也就回答我前面的问题：只有在 Node.js 环境下的编译或者是 Web 端的非生产环境下才会执行 <code>transformExpression</code>。</p><p>这部分内容比较多，所以本课时的内容就先到这。下篇文章，我们接着分析遍历 AST 节点中的 Text 节点的转换函数。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;compiler-core&#x2F;src&#x2F;compile.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;transform.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;ast.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;transforms&#x2F;transformElement.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;transforms&#x2F;transformExpression.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章中，我们学习了 template 的解析过程，最终拿到了一个 AST 节点对象。这个对象是对模板的完整描述，但是它还不能直接拿来生成代码，因为它的语义化还不够，没有包含和编译优化的相关属性，所以还需要进一步转换。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="AST" scheme="https://xiaozhouguo.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>模板解析：构造AST的完整流程是怎么样的？ - 上篇</title>
    <link href="https://xiaozhouguo.github.io/2022/08/02/vue3/ast-one/"/>
    <id>https://xiaozhouguo.github.io/2022/08/02/vue3/ast-one/</id>
    <published>2022-08-02T06:58:58.000Z</published>
    <updated>2022-10-24T06:40:53.969Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 3.0 的编译场景分<strong>服务端 SSR 编译</strong>和 <strong>web 编译</strong>，本文我们只分析 web 的编译。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们先来看 web 编译的入口 compile 函数，分析它的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compile</span>(<span class="params">template, options = &#123;&#125;</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">baseCompile</span>(template, <span class="title function_">extend</span>(&#123;&#125;, parserOptions, options, &#123; </span><br><span class="line">    <span class="attr">nodeTransforms</span>: [...<span class="title class_">DOMNodeTransforms</span>, ...(options.<span class="property">nodeTransforms</span> || [])], </span><br><span class="line">    <span class="attr">directiveTransforms</span>: <span class="title function_">extend</span>(&#123;&#125;, <span class="title class_">DOMDirectiveTransforms</span>, options.<span class="property">directiveTransforms</span> || &#123;&#125;), </span><br><span class="line">    <span class="attr">transformHoist</span>:  <span class="literal">null</span> </span><br><span class="line">  &#125;)) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>compile 函数支持两个参数，第一个参数 template 是待编译的模板字符串，第二个参数 options 是编译的一些配置信息。</p><p>compile 内部通过执行 baseCompile 方法完成编译工作，可以看到 baseCompile 在参数 options 的基础上又扩展了一些配置。对于这些编译相关的配置，我们后面会在具体的场景具体分析。</p><p>接下来，我们来看一下 baseCompile 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baseCompile</span>(<span class="params">template,  options = &#123;&#125;</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> prefixIdentifiers = <span class="literal">false</span> </span><br><span class="line">  <span class="comment">// 解析 template 生成 AST </span></span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">isString</span>(template) ? <span class="title function_">baseParse</span>(template, options) : template </span><br><span class="line">  <span class="keyword">const</span> [nodeTransforms, directiveTransforms] = <span class="title function_">getBaseTransformPreset</span>() </span><br><span class="line">  <span class="comment">// AST 转换 </span></span><br><span class="line">  <span class="title function_">transform</span>(ast, <span class="title function_">extend</span>(&#123;&#125;, options, &#123; </span><br><span class="line">    prefixIdentifiers, </span><br><span class="line">    <span class="attr">nodeTransforms</span>: [ </span><br><span class="line">      ...nodeTransforms, </span><br><span class="line">      ...(options.<span class="property">nodeTransforms</span> || []) </span><br><span class="line">    ], </span><br><span class="line">    <span class="attr">directiveTransforms</span>: </span><br><span class="line">      <span class="title function_">extend</span>(&#123;&#125;, directiveTransforms, options.<span class="property">directiveTransforms</span> || &#123;&#125;) </span><br><span class="line">    &#125;)</span><br><span class="line">  ) </span><br><span class="line">  <span class="comment">// 生成代码 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">generate</span>(ast, <span class="title function_">extend</span>(&#123;&#125;, options, &#123; </span><br><span class="line">    prefixIdentifiers </span><br><span class="line">  &#125;)) </span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p>可以看到，baseCompile 函数主要做三件事情：<strong>解析 template 生成 AST</strong>，<strong>AST 转换</strong>和<strong>生成代码</strong>。</p><p>本文的目标就是<strong>解析 template 生成 AST 背后的实现原理</strong>。</p><h3 id="生成-AST-抽象语法树"><a href="#生成-AST-抽象语法树" class="headerlink" title="生成 AST 抽象语法树"></a>生成 AST 抽象语法树</h3><p>你可以在百度百科中看到 <a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/6129952?fr=aladdin">AST 的定义</a>，这里我就不赘述啦，对应到我们的 template，也可以用 AST 去描述它，比如我们有如下 template：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 这是一段注释 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">hello</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an app<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>经过第一步解析后，生成相应的AST对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;ns&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;div&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">        <span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;app&quot;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">11</span> </span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">16</span> </span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\&quot;app\&quot;&quot;</span> </span><br><span class="line">            <span class="punctuation">&#125;</span> </span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">            <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">5</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">16</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class=\&quot;app\&quot;&quot;</span> </span><br><span class="line">          <span class="punctuation">&#125;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span> </span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;isSelfClosing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">        <span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot; 这是一段注释 &quot;</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">            <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">20</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">35</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;!-- 这是一段注释 --&gt;&quot;</span> </span><br><span class="line">          <span class="punctuation">&#125;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;ns&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;isSelfClosing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">            <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;ns&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;isSelfClosing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">                <span class="punctuation">&#123;</span> </span><br><span class="line">                  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="attr">&quot;isStatic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="attr">&quot;isConstant&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;msg&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                        <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span> </span><br><span class="line">                        <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">                        <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">56</span> </span><br><span class="line">                      <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                        <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span> </span><br><span class="line">                        <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">                        <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">59</span> </span><br><span class="line">                      <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;msg&quot;</span> </span><br><span class="line">                    <span class="punctuation">&#125;</span> </span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">53</span> </span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">62</span> </span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#123; msg &#125;&#125;&quot;</span> </span><br><span class="line">                  <span class="punctuation">&#125;</span> </span><br><span class="line">                <span class="punctuation">&#125;</span> </span><br><span class="line">              <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                  <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">50</span> </span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                  <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">66</span> </span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&quot;</span> </span><br><span class="line">              <span class="punctuation">&#125;</span> </span><br><span class="line">            <span class="punctuation">&#125;</span> </span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">            <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">38</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">77</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;hello&gt;\n    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;\n  &lt;/hello&gt;&quot;</span> </span><br><span class="line">          <span class="punctuation">&#125;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;ns&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;isSelfClosing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">            <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is an app&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                  <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">83</span> </span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">                  <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">97</span> </span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is an app&quot;</span> </span><br><span class="line">              <span class="punctuation">&#125;</span> </span><br><span class="line">            <span class="punctuation">&#125;</span> </span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">            <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">80</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">              <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">101</span> </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;p&gt;This is an app&lt;/p&gt;&quot;</span> </span><br><span class="line">          <span class="punctuation">&#125;</span> </span><br><span class="line">        <span class="punctuation">&#125;</span> </span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span> </span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> </span><br><span class="line">          <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">108</span> </span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;div class=\&quot;app\&quot;&gt;\n  &lt;!-- 这是一段注释 --&gt;\n  &lt;hello&gt;\n    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;\n  &lt;/hello&gt;\n  &lt;p&gt;This is an app&lt;/p&gt;\n&lt;/div&gt;&quot;</span> </span><br><span class="line">      <span class="punctuation">&#125;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span> </span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;helpers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;directives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;hoists&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;imports&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;cached&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;temps&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span> </span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">108</span> </span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;div class=\&quot;app\&quot;&gt;\n  &lt;!-- 这是一段注释 --&gt;\n  &lt;hello&gt;\n    &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;\n  &lt;/hello&gt;\n  &lt;p&gt;This is an app&lt;/p&gt;\n&lt;/div&gt;&quot;</span> </span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，AST 是树状结构，对于树中的每个节点，会有 type 字段描述节点的类型，tag 字段描述节点的标签，props 描述节点的属性，loc 描述节点对应代码相关信息，children 指向它的子节点对象数组。</p><p>当然 AST 中的节点还包含其他的一些属性，我在这里就不一一介绍了，你现在要理解的是 <strong>AST 中的节点是可以完整地描述它在模板中映射的节点信息</strong>。</p><p>注意，<strong>AST 对象根节点其实是一个虚拟节点</strong>，<strong>它并不会映射到一个具体节点</strong>，另外它还包含了其他的一些属性，这些属性在后续的 AST 转换的过程中会赋值，并在生成代码阶段用到。</p><p>那么，为什么要设计一个虚拟节点呢？</p><p>因为 Vue.js 3.0 和 Vue.js 2.x 有一个很大的不同——Vue.js 3.0 支持了<code> Fragment</code> 的语法，即组件可以有多个根节点，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./logo.jpg&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>这种写法在 Vue.js 2.x 中会报错，提示模板只能有一个根节点，而 Vue.js 3.0 允许了这种写法。但是对于一棵树而言，必须有一个根节点，所以虚拟节点在这种场景下就非常有用了，它可以作为 AST 的根节点，然后其 children 包含了 img 和 hello 的节点。</p><p>好了，到这里你已经大致了解了 AST，那么接下来我们看一下如何根据模板字符串来构建这个 AST 对象吧。</p><p>先来看一下 <code>baseParse</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baseParse</span>(<span class="params">content, options = &#123;&#125;</span>) &#123; </span><br><span class="line">    <span class="comment">// 创建解析上下文 </span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="title function_">createParserContext</span>(content, options) </span><br><span class="line">    <span class="keyword">const</span> start = <span class="title function_">getCursor</span>(context) </span><br><span class="line">    <span class="comment">// 解析子节点，并创建 AST  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createRoot</span>(</span><br><span class="line">        <span class="title function_">parseChildren</span>(context, <span class="number">0</span> <span class="comment">/* DATA */</span>, []), </span><br><span class="line">        <span class="title function_">getSelection</span>(context, start)</span><br><span class="line">    ) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>baseParse 主要就做三件事情：<strong>创建解析上下文</strong>，<strong>解析子节点</strong>，<strong>创建 AST 根节点</strong>。</p><h4 id="创建解析上下文"><a href="#创建解析上下文" class="headerlink" title="创建解析上下文"></a>创建解析上下文</h4><p>首先，我们来分析创建解析上下文的过程，先来看 <code>createParserContext</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认解析配置 </span></span><br><span class="line"><span class="keyword">const</span> defaultParserOptions = &#123; </span><br><span class="line">  <span class="attr">delimiters</span>: [<span class="string">`&#123;&#123;`</span>, <span class="string">`&#125;&#125;`</span>], </span><br><span class="line">  <span class="attr">getNamespace</span>: <span class="function">() =&gt;</span> <span class="number">0</span> <span class="comment">/* HTML */</span>, </span><br><span class="line">  <span class="attr">getTextMode</span>: <span class="function">() =&gt;</span> <span class="number">0</span> <span class="comment">/* DATA */</span>, </span><br><span class="line">  <span class="attr">isVoidTag</span>: <span class="variable constant_">NO</span>, </span><br><span class="line">  <span class="attr">isPreTag</span>: <span class="variable constant_">NO</span>, </span><br><span class="line">  <span class="attr">isCustomElement</span>: <span class="variable constant_">NO</span>, </span><br><span class="line">  <span class="attr">decodeEntities</span>: <span class="function">(<span class="params">rawText</span>) =&gt;</span> rawText.<span class="title function_">replace</span>(decodeRE, <span class="function">(<span class="params">_, p1</span>) =&gt;</span> decodeMap[p1]), </span><br><span class="line">  <span class="attr">onError</span>: defaultOnError </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createParserContext</span>(<span class="params">content, options</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">options</span>: <span class="title function_">extend</span>(&#123;&#125;, defaultParserOptions, options), </span><br><span class="line">    <span class="attr">column</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">line</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">offset</span>: <span class="number">0</span>, </span><br><span class="line">    <span class="attr">originalSource</span>: content, </span><br><span class="line">    <span class="attr">source</span>: content, </span><br><span class="line">    <span class="attr">inPre</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="attr">inVPre</span>: <span class="literal">false</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析上下文实际上就是一个 JavaScript 对象，它维护着解析过程中的上下文，其中 options 表示解析相关配置 ，column 表示当前代码的列号，line 表示当前代码的行号，originalSource 表示最初的原始代码，source 表示当前代码，offset 表示当前代码相对于原始代码的偏移量，inPre 表示当前代码是否在 pre 标签内，inVPre 表示当前代码是否在 v-pre 指令的环境下。</p><p>在后续解析的过程中，会始终维护和更新这个解析上下文，它能够表示当前解析的状态。</p><p>创建完解析上下文，接下来就开始解析子节点了。</p><h4 id="解析子节点"><a href="#解析子节点" class="headerlink" title="解析子节点"></a>解析子节点</h4><p>我们先来看一下 <code>parseChildren</code> 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseChildren</span>(<span class="params">context, mode, ancestors</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> parent = <span class="title function_">last</span>(ancestors) </span><br><span class="line">  <span class="keyword">const</span> ns = parent ? parent.<span class="property">ns</span> : <span class="number">0</span> <span class="comment">/* HTML */</span> </span><br><span class="line">  <span class="keyword">const</span> nodes = [] </span><br><span class="line">  <span class="comment">// 自顶向下分析代码，生成 nodes </span></span><br><span class="line">  <span class="keyword">let</span> removedWhitespace = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 空白字符管理 </span></span><br><span class="line">  <span class="keyword">return</span> removedWhitespace ? nodes.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>) : nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseChildren 的目的就是解析并创建 AST 节点数组。它有两个主要流程，第一个是自顶向下分析代码，生成 AST 节点数组 nodes；第二个是空白字符管理，用于提高编译的效率。</p><p>首先，我们来看<strong>生成 AST 节点数组</strong>的流程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseChildren</span>(<span class="params">context, mode, ancestors</span>) &#123; </span><br><span class="line">  <span class="comment">// 父节点 </span></span><br><span class="line">  <span class="keyword">const</span> parent = <span class="title function_">last</span>(ancestors) </span><br><span class="line">  <span class="keyword">const</span> ns = parent ? parent.<span class="property">ns</span> : <span class="number">0</span> <span class="comment">/* HTML */</span> </span><br><span class="line">  <span class="keyword">const</span> nodes = [] </span><br><span class="line">  <span class="comment">// 判断是否遍历结束 </span></span><br><span class="line">  <span class="keyword">while</span> (!<span class="title function_">isEnd</span>(context, mode, ancestors)) &#123; </span><br><span class="line">    <span class="keyword">const</span> s = context.<span class="property">source</span> </span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">undefined</span> </span><br><span class="line">    <span class="keyword">if</span> (mode === <span class="number">0</span> <span class="comment">/* DATA */</span> || mode === <span class="number">1</span> <span class="comment">/* RCDATA */</span>) &#123; </span><br><span class="line">      <span class="keyword">if</span> (!context.<span class="property">inVPre</span> &amp;&amp; <span class="title function_">startsWith</span>(s, context.<span class="property">options</span>.<span class="property">delimiters</span>[<span class="number">0</span>])) &#123; </span><br><span class="line">        <span class="comment">// 处理 &#123;&#123; 插值代码 </span></span><br><span class="line">        node = parseInterpolation(context, mode) </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mode === <span class="number">0</span> <span class="comment">/* DATA */</span> &amp;&amp; s[<span class="number">0</span>] === <span class="string">&#x27;&lt;&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">// 处理 &lt; 开头的代码 </span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">1</span>) &#123; </span><br><span class="line">          <span class="comment">// s 长度为 1，说明代码结尾是 &lt;，报错 </span></span><br><span class="line">          <span class="title function_">emitError</span>(context, <span class="number">5</span> <span class="comment">/* EOF_BEFORE_TAG_NAME */</span>, <span class="number">1</span>) </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;!&#x27;</span>) &#123; </span><br><span class="line">          <span class="comment">// 处理 &lt;! 开头的代码 </span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">startsWith</span>(s, <span class="string">&#x27;&lt;!--&#x27;</span>)) &#123; </span><br><span class="line">            <span class="comment">// 处理注释节点 </span></span><br><span class="line">            node = <span class="title function_">parseComment</span>(context) </span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">startsWith</span>(s, <span class="string">&#x27;&lt;!DOCTYPE&#x27;</span>)) &#123; </span><br><span class="line">            <span class="comment">// 处理 &lt;!DOCTYPE 节点 </span></span><br><span class="line">            node = <span class="title function_">parseBogusComment</span>(context) </span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">startsWith</span>(s, <span class="string">&#x27;&lt;![CDATA[&#x27;</span>)) &#123; </span><br><span class="line">            <span class="comment">// 处理 &lt;![CDATA[ 节点 </span></span><br><span class="line">            <span class="keyword">if</span> (ns !== <span class="number">0</span> <span class="comment">/* HTML */</span>) &#123; </span><br><span class="line">              node = <span class="title function_">parseCDATA</span>(context, ancestors) </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">              <span class="title function_">emitError</span>(context, <span class="number">1</span> <span class="comment">/* CDATA_IN_HTML_CONTENT */</span>) </span><br><span class="line">              node = <span class="title function_">parseBogusComment</span>(context) </span><br><span class="line">            &#125; </span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="title function_">emitError</span>(context, <span class="number">11</span> <span class="comment">/* INCORRECTLY_OPENED_COMMENT */</span>) </span><br><span class="line">            node = <span class="title function_">parseBogusComment</span>(context) </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">          <span class="comment">// 处理 &lt;/ 结束标签 </span></span><br><span class="line">          <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">2</span>) &#123; </span><br><span class="line">            <span class="comment">// s 长度为 2，说明代码结尾是 &lt;/，报错 </span></span><br><span class="line">            <span class="title function_">emitError</span>(context, <span class="number">5</span> <span class="comment">/* EOF_BEFORE_TAG_NAME */</span>, <span class="number">2</span>) </span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">2</span>] === <span class="string">&#x27;&gt;&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">// &lt;/&gt; 缺少结束标签，报错 </span></span><br><span class="line">            <span class="title function_">emitError</span>(context, <span class="number">14</span> <span class="comment">/* MISSING_END_TAG_NAME */</span>, <span class="number">2</span>) </span><br><span class="line">            <span class="title function_">advanceBy</span>(context, <span class="number">3</span>) </span><br><span class="line">            <span class="keyword">continue</span> </span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">2</span>])) &#123; </span><br><span class="line">            <span class="comment">// 多余的结束标签 </span></span><br><span class="line">            <span class="title function_">emitError</span>(context, <span class="number">23</span> <span class="comment">/* X_INVALID_END_TAG */</span>) </span><br><span class="line">            <span class="title function_">parseTag</span>(context, <span class="number">1</span> <span class="comment">/* End */</span>, parent) </span><br><span class="line">            <span class="keyword">continue</span> </span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="title function_">emitError</span>(context, <span class="number">12</span> <span class="comment">/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span>, <span class="number">2</span>) </span><br><span class="line">            node = <span class="title function_">parseBogusComment</span>(context) </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">1</span>])) &#123; </span><br><span class="line">          <span class="comment">// 解析标签元素节点 </span></span><br><span class="line">          node = <span class="title function_">parseElement</span>(context, ancestors) </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;?&#x27;</span>) &#123; </span><br><span class="line">          <span class="title function_">emitError</span>(context, <span class="number">21</span> <span class="comment">/* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span>, <span class="number">1</span>) </span><br><span class="line">          node = <span class="title function_">parseBogusComment</span>(context) </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="title function_">emitError</span>(context, <span class="number">12</span> <span class="comment">/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span>, <span class="number">1</span>) </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!node) &#123; </span><br><span class="line">      <span class="comment">// 解析普通文本节点 </span></span><br><span class="line">      node = <span class="title function_">parseText</span>(context, mode) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArray</span>(node)) &#123; </span><br><span class="line">      <span class="comment">// 如果 node 是数组，则遍历添加 </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">length</span>; i++) &#123; </span><br><span class="line">        <span class="title function_">pushNode</span>(nodes, node[i]) </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 添加单个 node </span></span><br><span class="line">      <span class="title function_">pushNode</span>(nodes, node) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码看起来很复杂，但它的思路就是自顶向下地去遍历代码，然后根据不同的情况尝试去解析代码，然后把生成的 node 添加到 AST nodes 数组中。在解析的过程中，解析上下文 context 的状态也是在不断发生变化的，我们可以通过 context.source 拿到当前解析剩余的代码 s，然后根据 s 不同的情况走不同的分支处理逻辑。在解析的过程中，可能会遇到各种错误，都会通过 emitError 方法报错。</p><p>我们没有必要去了解所有代码的分支细节，只需要知道大致的解析思路即可，因此我们这里只分析四种情况：注释节点的解析、插值的解析、普通文本的解析，以及元素节点的解析。</p><ul><li>注释节点的解析</li></ul><p>首先，我们来看注释节点的解析过程，它会解析模板中的注释节点，比如 <code>&lt;!-- 这是一段注释 --&gt;，</code> 即当前代码 s 是以 <code>&lt;!--</code> 开头的字符串，则走到注释节点的解析处理逻辑。</p><p>我们来看 <code>parseComment</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseComment</span>(<span class="params">context</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> start = <span class="title function_">getCursor</span>(context) </span><br><span class="line">  <span class="keyword">let</span> content </span><br><span class="line">  <span class="comment">// 常规注释的结束符 </span></span><br><span class="line">  <span class="keyword">const</span> match = <span class="regexp">/--(\!)?&gt;/</span>.<span class="title function_">exec</span>(context.<span class="property">source</span>) </span><br><span class="line">  <span class="keyword">if</span> (!match) &#123; </span><br><span class="line">    <span class="comment">// 没有匹配的注释结束符 </span></span><br><span class="line">    content = context.<span class="property">source</span>.<span class="title function_">slice</span>(<span class="number">4</span>) </span><br><span class="line">    <span class="title function_">advanceBy</span>(context, context.<span class="property">source</span>.<span class="property">length</span>) </span><br><span class="line">    <span class="title function_">emitError</span>(context, <span class="number">7</span> <span class="comment">/* EOF_IN_COMMENT */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (match.<span class="property">index</span> &lt;= <span class="number">3</span>) &#123; </span><br><span class="line">      <span class="comment">// 非法的注释符号 </span></span><br><span class="line">      <span class="title function_">emitError</span>(context, <span class="number">0</span> <span class="comment">/* ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span>) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (match[<span class="number">1</span>]) &#123; </span><br><span class="line">      <span class="comment">// 注释结束符不正确 </span></span><br><span class="line">      <span class="title function_">emitError</span>(context, <span class="number">10</span> <span class="comment">/* INCORRECTLY_CLOSED_COMMENT */</span>) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 获取注释的内容 </span></span><br><span class="line">    content = context.<span class="property">source</span>.<span class="title function_">slice</span>(<span class="number">4</span>, match.<span class="property">index</span>) </span><br><span class="line">    <span class="comment">// 截取到注释结尾之间的代码，用于后续判断嵌套注释 </span></span><br><span class="line">    <span class="keyword">const</span> s = context.<span class="property">source</span>.<span class="title function_">slice</span>(<span class="number">0</span>, match.<span class="property">index</span>) </span><br><span class="line">    <span class="keyword">let</span> prevIndex = <span class="number">1</span>, nestedIndex = <span class="number">0</span> </span><br><span class="line">    <span class="comment">// 判断嵌套注释符的情况，存在即报错 </span></span><br><span class="line">    <span class="keyword">while</span> ((nestedIndex = s.<span class="title function_">indexOf</span>(<span class="string">&#x27;&lt;!--&#x27;</span>, prevIndex)) !== -<span class="number">1</span>) &#123; </span><br><span class="line">      <span class="title function_">advanceBy</span>(context, nestedIndex - prevIndex + <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">if</span> (nestedIndex + <span class="number">4</span> &lt; s.<span class="property">length</span>) &#123; </span><br><span class="line">        <span class="title function_">emitError</span>(context, <span class="number">16</span> <span class="comment">/* NESTED_COMMENT */</span>) </span><br><span class="line">      &#125; </span><br><span class="line">      prevIndex = nestedIndex + <span class="number">1</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 前进代码到注释结束符后 </span></span><br><span class="line">    <span class="title function_">advanceBy</span>(context, match.<span class="property">index</span> + match[<span class="number">0</span>].<span class="property">length</span> - prevIndex + <span class="number">1</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">type</span>: <span class="number">3</span> <span class="comment">/* COMMENT */</span>, </span><br><span class="line">    content, </span><br><span class="line">    <span class="attr">loc</span>: <span class="title function_">getSelection</span>(context, start) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，parseComment 的实现很简单，首先它会利用注释结束符的正则表达式去匹配代码，找出注释结束符。如果没有匹配到或者注释结束符不合法，都会报错。<br>如果找到合法的注释结束符，则获取它中间的注释内容 content，然后截取注释开头到结尾之间的代码，并判断是否有嵌套注释，如果有嵌套注释也会报错。</p><p>接着就是通过调用 advanceBy 前进代码到注释结束符后，这个函数在整个模板解析过程中经常被调用，它的目的是用来前进代码，更新 context 解析上下文，我们来看一下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">advanceBy</span>(<span class="params">context, numberOfCharacters</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> &#123; source &#125; = context </span><br><span class="line">  <span class="comment">// 更新 context 的 offset、line、column </span></span><br><span class="line">  <span class="title function_">advancePositionWithMutation</span>(context, source, numberOfCharacters) </span><br><span class="line">  <span class="comment">// 更新 context 的 source </span></span><br><span class="line">  context.<span class="property">source</span> = source.<span class="title function_">slice</span>(numberOfCharacters) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">advancePositionWithMutation</span>(<span class="params">pos, source, numberOfCharacters = source.length</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> linesCount = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">let</span> lastNewLinePos = -<span class="number">1</span> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numberOfCharacters; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (source.<span class="title function_">charCodeAt</span>(i) === <span class="number">10</span> <span class="comment">/* newline char code */</span>) &#123; </span><br><span class="line">      linesCount++ </span><br><span class="line">      lastNewLinePos = i </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  pos.<span class="property">offset</span> += numberOfCharacters </span><br><span class="line">  pos.<span class="property">line</span> += linesCount </span><br><span class="line">  pos.<span class="property">column</span> = </span><br><span class="line">    lastNewLinePos === -<span class="number">1</span> </span><br><span class="line">      ? pos.<span class="property">column</span> + numberOfCharacters </span><br><span class="line">      : numberOfCharacters - lastNewLinePos </span><br><span class="line">  <span class="keyword">return</span> pos </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>advanceBy 的实现很简单，主要就是更新解析上下文 context 中的 source 来前进代码，同时更新 offset、line、column 等和代码位置相关的属性。</p><p>为了更直观地说明 advanceBy 的作用，前面的示例可以通过下图表示：</p><img src="/2022/08/02/vue3/ast-one/Ciqc1F88z3mACHOrAAFRdAq-Jxw187.png" class=""><p>经过 advanceBy 前进代码到注释结束符后，表示注释部分代码处理完毕，可以继续解析后续代码了。</p><p>parseComment 最终返回的值就是一个描述注释节点的对象，其中 type 表示它是一个注释节点，content 表示注释的内容，loc 表示注释的代码开头和结束的位置信息。</p><ul><li>插值的解析</li></ul><p>接下来，我们来看插值的解析过程，它会解析模板中的插值，比如 <code>&#123;&#123; msg &#125;&#125;</code> ，即当前代码 s 是以 { { 开头的字符串，且不在 v-pre 指令的环境下（v-pre 会跳过插值的解析），则会走到插值的解析处理逻辑 <code>parseInterpolation</code> 函数，我们来看它的实现： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseInterpolation</span>(<span class="params">context, mode</span>) &#123; </span><br><span class="line">  <span class="comment">// 从配置中获取插值开始和结束分隔符，默认是 &#123;&#123; 和 &#125;&#125; </span></span><br><span class="line">  <span class="keyword">const</span> [open, close] = context.<span class="property">options</span>.<span class="property">delimiters</span> </span><br><span class="line">  <span class="keyword">const</span> closeIndex = context.<span class="property">source</span>.<span class="title function_">indexOf</span>(close, open.<span class="property">length</span>) </span><br><span class="line">  <span class="keyword">if</span> (closeIndex === -<span class="number">1</span>) &#123; </span><br><span class="line">    <span class="title function_">emitError</span>(context, <span class="number">25</span> <span class="comment">/* X_MISSING_INTERPOLATION_END */</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span> </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">const</span> start = <span class="title function_">getCursor</span>(context) </span><br><span class="line">  <span class="comment">// 代码前进到插值开始分隔符后 </span></span><br><span class="line">  <span class="title function_">advanceBy</span>(context, open.<span class="property">length</span>) </span><br><span class="line">  <span class="comment">// 内部插值开始位置 </span></span><br><span class="line">  <span class="keyword">const</span> innerStart = <span class="title function_">getCursor</span>(context) </span><br><span class="line">  <span class="comment">// 内部插值结束位置 </span></span><br><span class="line">  <span class="keyword">const</span> innerEnd = <span class="title function_">getCursor</span>(context) </span><br><span class="line">  <span class="comment">// 插值原始内容的长度 </span></span><br><span class="line">  <span class="keyword">const</span> rawContentLength = closeIndex - open.<span class="property">length</span> </span><br><span class="line">  <span class="comment">// 插值原始内容 </span></span><br><span class="line">  <span class="keyword">const</span> rawContent = context.<span class="property">source</span>.<span class="title function_">slice</span>(<span class="number">0</span>, rawContentLength) </span><br><span class="line">  <span class="comment">// 获取插值的内容，并前进代码到插值的内容后 </span></span><br><span class="line">  <span class="keyword">const</span> preTrimContent = <span class="title function_">parseTextData</span>(context, rawContentLength, mode) </span><br><span class="line">  <span class="keyword">const</span> content = preTrimContent.<span class="title function_">trim</span>() </span><br><span class="line">  <span class="comment">// 内容相对于插值开始分隔符的头偏移 </span></span><br><span class="line">  <span class="keyword">const</span> startOffset = preTrimContent.<span class="title function_">indexOf</span>(content) </span><br><span class="line">  <span class="keyword">if</span> (startOffset &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// 更新内部插值开始位置 </span></span><br><span class="line">    <span class="title function_">advancePositionWithMutation</span>(innerStart, rawContent, startOffset) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 内容相对于插值结束分隔符的尾偏移 </span></span><br><span class="line">  <span class="keyword">const</span> endOffset = rawContentLength - (preTrimContent.<span class="property">length</span> - content.<span class="property">length</span> - startOffset) </span><br><span class="line">  <span class="comment">// 更新内部插值结束位置 </span></span><br><span class="line">  <span class="title function_">advancePositionWithMutation</span>(innerEnd, rawContent, endOffset); </span><br><span class="line">  <span class="comment">// 前进代码到插值结束分隔符后 </span></span><br><span class="line">  <span class="title function_">advanceBy</span>(context, close.<span class="property">length</span>) </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">type</span>: <span class="number">5</span> <span class="comment">/* INTERPOLATION */</span>, </span><br><span class="line">    <span class="attr">content</span>: &#123; </span><br><span class="line">      <span class="attr">type</span>: <span class="number">4</span> <span class="comment">/* SIMPLE_EXPRESSION */</span>, </span><br><span class="line">      <span class="attr">isStatic</span>: <span class="literal">false</span>, </span><br><span class="line">      <span class="attr">isConstant</span>: <span class="literal">false</span>, </span><br><span class="line">      content, </span><br><span class="line">      <span class="attr">loc</span>: <span class="title function_">getSelection</span>(context, innerStart, innerEnd) </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">loc</span>: <span class="title function_">getSelection</span>(context, start) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>parseInterpolation 的实现也很简单，首先它会尝试找插值的结束分隔符，如果找不到则报错。</p><p>如果找到，先前进代码到插值开始分隔符后，然后通过 parseTextData 获取插值中间的内容并前进代码到插值内容后，除了普通字符串，parseTextData 内部会处理一些 HTML 实体符号比如 <code>&amp;nbsp</code> 。由于插值的内容可能是前后有空白字符的，所以最终返回的 content 需要执行一下 trim 函数。</p><p>为了准确地反馈插值内容的代码位置信息，我们使用了 innerStart 和 innerEnd 去记录插值内容（不包含空白字符）的代码开头和结束位置。</p><p>接着就是前进代码到插值结束分隔符后，表示插值部分代码处理完毕，可以继续解析后续代码了。</p><p>parseInterpolation 最终返回的值就是一个描述插值节点的对象，其中 type 表示它是一个插值节点，loc 表示插值的代码开头和结束的位置信息，而 content 又是一个描述表达式节点的对象，其中 type 表示它是一个表达式节点，loc 表示内容的代码开头和结束的位置信息，content 表示插值的内容。</p><ul><li>普通文本的解析</li></ul><p>接下来，我们来看普通文本的解析过程，它会解析模板中的普通文本，比如 <code>This is an app</code> ，即当前代码 s 既不是以 { { 插值分隔符开头的字符串，也不是以 &lt; 开头的字符串，则走到普通文本的解析处理逻辑，我们来看 parseText 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseText</span>(<span class="params">context, mode</span>) &#123; </span><br><span class="line">  <span class="comment">// 文本结束符 </span></span><br><span class="line">  <span class="keyword">const</span> endTokens = [<span class="string">&#x27;&lt;&#x27;</span>, context.<span class="property">options</span>.<span class="property">delimiters</span>[<span class="number">0</span>]] </span><br><span class="line">  <span class="keyword">if</span> (mode === <span class="number">3</span> <span class="comment">/* CDATA */</span>) &#123; </span><br><span class="line">    <span class="comment">// CDATA 标记 XML 中的纯文本 </span></span><br><span class="line">    endTokens.<span class="title function_">push</span>(<span class="string">&#x27;]]&gt;&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">let</span> endIndex = context.<span class="property">source</span>.<span class="property">length</span> </span><br><span class="line">  <span class="comment">// 遍历文本结束符，匹配找到结束的位置 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; endTokens.<span class="property">length</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">const</span> index = context.<span class="property">source</span>.<span class="title function_">indexOf</span>(endTokens[i], <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span> &amp;&amp; endIndex &gt; index) &#123; </span><br><span class="line">      endIndex = index </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">const</span> start = <span class="title function_">getCursor</span>(context) </span><br><span class="line">  <span class="comment">// 获取文本的内容，并前进代码到文本的内容后 </span></span><br><span class="line">  <span class="keyword">const</span> content = <span class="title function_">parseTextData</span>(context, endIndex, mode) </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">type</span>: <span class="number">2</span> <span class="comment">/* TEXT */</span>, </span><br><span class="line">    content, </span><br><span class="line">    <span class="attr">loc</span>: <span class="title function_">getSelection</span>(context, start) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>同样，parseText 的实现很简单。对于一段文本来说，都是在遇到 &lt; 或者插值分隔符 { { 结束，所以会遍历这些结束符，匹配并找到文本结束的位置，然后执行 parseTextData 获取文本的内容，并前进代码到文本的内容后。</p><p>parseText 最终返回的值就是一个描述文本节点的对象，其中 type 表示它是一个文本节点，content 表示文本的内容，loc 表示文本的代码开头和结束的位置信息。</p><p>这部分内容比较多，所以本课时的内容就先到这。下节课中，我们接着分析元素节点，继续解析 template 生成 AST 的背后实现原理。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;compiler-core&#x2F;src&#x2F;compile.ts<br>packages&#x2F;compiler-core&#x2F;src&#x2F;parse.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue.js 3.0 的编译场景分&lt;strong&gt;服务端 SSR 编译&lt;/strong&gt;和 &lt;strong&gt;web 编译&lt;/strong&gt;，本文我们只分析 web 的编译。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="AST" scheme="https://xiaozhouguo.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>侦听器的实现原理和使用场景 - 下篇</title>
    <link href="https://xiaozhouguo.github.io/2022/08/01/vue3/watcher-two/"/>
    <id>https://xiaozhouguo.github.io/2022/08/01/vue3/watcher-two/</id>
    <published>2022-08-01T08:55:54.000Z</published>
    <updated>2022-08-01T09:35:21.890Z</updated>
    
    <content type="html"><![CDATA[<p>在前面中，我们多次提到回调函数是以一种调度的方式执行的，特别是当 flush 不是 sync 时，它会把回调函数执行的任务推到一个异步队列中执行。接下来，我们就来分析异步执行队列的设计。分析之前，我们先来思考一下，为什么会需要异步队列？</p><span id="more"></span><h3 id="异步任务队列的设计"><a href="#异步任务队列的设计" class="headerlink" title="异步任务队列的设计"></a>异步任务队列的设计</h3><p>我们把之前的例子简单修改一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) </span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">count</span>, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count) </span><br><span class="line">&#125;) </span><br><span class="line">state.<span class="property">count</span>++ </span><br><span class="line">state.<span class="property">count</span>++ </span><br><span class="line">state.<span class="property">count</span>++ </span><br></pre></td></tr></table></figure><p>这里，我们修改了三次 state.count，那么 watcher 的回调函数会执行三次吗？</p><p>答案是不会，实际上只输出了一次 count 的值，也就是最终计算的值 3。这在大多数场景下都是符合预期的，因为在一个 <code>Tick（宏任务执行的生命周期）</code>内，即使多次修改侦听的值，它的回调函数也只执行一次。</p><blockquote><p><strong>知识延伸</strong><br>组件的更新过程是异步的，我们知道修改模板中引用的响应式对象的值时，会触发组件的重新渲染，但是在一个 Tick 内，即使你多次修改多个响应式对象的值，组件的重新渲染也只执行一次。这是因为如果每次更新数据都触发组件重新渲染，那么重新渲染的次数和代价都太高了。</p></blockquote><p>那么，这是怎么做到的呢？我们先从异步任务队列的创建说起。</p><h4 id="异步任务队列的创建"><a href="#异步任务队列的创建" class="headerlink" title="异步任务队列的创建"></a>异步任务队列的创建</h4><p>通过前面的分析我们知道，在创建一个 watcher 时，如果配置 flush 为 pre 或不配置 flush ，那么 watcher 的回调函数就会异步执行。此时分别是通过 queueJob 和 queuePostRenderEffect 把回调函数推入异步队列中的。</p><p>在不涉及 suspense 的情况下，queuePostRenderEffect 相当于 queuePostFlushCb，我们来看它们的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步任务队列 </span></span><br><span class="line"><span class="keyword">const</span> queue = [] </span><br><span class="line"><span class="comment">// 队列任务执行完后执行的回调函数队列 </span></span><br><span class="line"><span class="keyword">const</span> postFlushCbs = [] </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueJob</span>(<span class="params">job</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (!queue.<span class="title function_">includes</span>(job)) &#123; </span><br><span class="line">    queue.<span class="title function_">push</span>(job) </span><br><span class="line">    <span class="title function_">queueFlush</span>() </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queuePostFlushCb</span>(<span class="params">cb</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isArray</span>(cb)) &#123; </span><br><span class="line">    postFlushCbs.<span class="title function_">push</span>(cb) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 如果是数组，把它拍平成一维 </span></span><br><span class="line">    postFlushCbs.<span class="title function_">push</span>(...cb) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="title function_">queueFlush</span>() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue.js 内部维护了一个 queue 数组和一个 postFlushCbs 数组，其中 queue 数组用作异步任务队列， postFlushCbs 数组用作异步任务队列执行完毕后的回调函数队列。</p><p>执行 queueJob 时会把这个任务 job 添加到 queue 的队尾，而执行 queuePostFlushCb 时，会把这个 cb 回调函数添加到 postFlushCbs 的队尾。它们在添加完毕后都执行了 queueFlush 函数，我们接着看它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() </span><br><span class="line"><span class="comment">// 异步任务队列是否正在执行 </span></span><br><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span> </span><br><span class="line"><span class="comment">// 异步任务队列是否等待执行 </span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">fn</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(fn) : p </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123; </span><br><span class="line">    isFlushPending = <span class="literal">true</span> </span><br><span class="line">    <span class="title function_">nextTick</span>(flushJobs) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到，Vue.js 内部还维护了 isFlushing 和 isFlushPending 变量，用来控制异步任务的刷新逻辑。</p><p>在 queueFlush 首次执行时，isFlushing 和 isFlushPending 都是 false，此时会把 isFlushPending 设置为 true，并且调用 nextTick(flushJobs) 去执行队列里的任务。</p><p>因为 isFlushPending 的控制，这使得即使多次执行 queueFlush，也不会多次去执行 flushJobs。另外 nextTick 在 Vue.js 3.0 中的实现也是非常简单，通过 Promise.resolve().then 去异步执行 flushJobs。</p><p>因为 JavaScript 是单线程执行的，这样的异步设计使你在一个 Tick 内，可以多次执行 queueJob 或者 queuePostFlushCb 去添加任务，也可以保证在宏任务执行完毕后的微任务阶段执行一次 flushJobs。</p><h4 id="异步任务队列的执行"><a href="#异步任务队列的执行" class="headerlink" title="异步任务队列的执行"></a>异步任务队列的执行</h4><p>创建完任务队列后，接下来要异步执行这个队列，我们来看一下 flushJobs 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getId</span> = (<span class="params">job</span>) =&gt; (job.<span class="property">id</span> == <span class="literal">null</span> ? <span class="title class_">Infinity</span> : job.<span class="property">id</span>) </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params">seen</span>) &#123; </span><br><span class="line">  isFlushPending = <span class="literal">false</span> </span><br><span class="line">  isFlushing = <span class="literal">true</span> </span><br><span class="line">  <span class="keyword">let</span> job </span><br><span class="line">  <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">    seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>() </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 组件的更新是先父后子 </span></span><br><span class="line">  <span class="comment">// 如果一个组件在父组件更新过程中卸载，它自身的更新应该被跳过 </span></span><br><span class="line">  queue.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">getId</span>(a) - <span class="title function_">getId</span>(b)) </span><br><span class="line">  <span class="keyword">while</span> ((job = queue.<span class="title function_">shift</span>()) !== <span class="literal">undefined</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (job === <span class="literal">null</span>) &#123; </span><br><span class="line">      <span class="keyword">continue</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">      <span class="title function_">checkRecursiveUpdates</span>(seen, job) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="number">14</span> <span class="comment">/* SCHEDULER */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="title function_">flushPostFlushCbs</span>(seen) </span><br><span class="line">  isFlushing = <span class="literal">false</span> </span><br><span class="line">  <span class="comment">// 一些 postFlushCb 执行过程中会再次添加异步任务，递归 flushJobs 会把它们都执行完毕 </span></span><br><span class="line">  <span class="keyword">if</span> (queue.<span class="property">length</span> || postFlushCbs.<span class="property">length</span>) &#123; </span><br><span class="line">    <span class="title function_">flushJobs</span>(seen) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，flushJobs 函数开始执行的时候，会把 isFlushPending 重置为 false，把 isFlushing 设置为 true 来表示正在执行异步任务队列。</p><p>对于异步任务队列 queue，在遍历执行它们前会先对它们做一次从小到大的排序，这是因为两个主要原因：</p><ul><li>我们创建组件的过程是由父到子，所以创建组件副作用渲染函数也是先父后子，父组件的副作用渲染函数的 effect id 是小于子组件的，每次更新组件也是通过 queueJob 把 effect 推入异步任务队列 queue 中的。所以为了保证先更新父组再更新子组件，要对 queue 做从小到大的排序。</li><li>如果一个组件在父组件更新过程中被卸载，它自身的更新应该被跳过。所以也应该要保证先更新父组件再更新子组件，要对 queue 做从小到大的排序。</li></ul><p>接下来，就是遍历这个 queue，依次执行队列中的任务了，在遍历过程中，注意有一个 checkRecursiveUpdates 的逻辑，它是用来在非生产环境下检测是否有循环更新的，它的作用我们稍后会提。</p><p>遍历完 queue 后，又会进一步执行 flushPostFlushCbs 方法去遍历执行所有推入到 postFlushCbs 的回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">flushPostFlushCbs</span>(<span class="params">seen</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (postFlushCbs.<span class="property">length</span>) &#123; </span><br><span class="line">    <span class="comment">// 拷贝副本 </span></span><br><span class="line">    <span class="keyword">const</span> cbs = [...<span class="keyword">new</span> <span class="title class_">Set</span>(postFlushCbs)] </span><br><span class="line">    postFlushCbs.<span class="property">length</span> = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">      seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>() </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.<span class="property">length</span>; i++) &#123; </span><br><span class="line">      <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123;                                                       </span><br><span class="line">        <span class="title function_">checkRecursiveUpdates</span>(seen, cbs[i]) </span><br><span class="line">      &#125; </span><br><span class="line">      cbs[i]() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里遍历前会通过 <code>const cbs = [...new Set(postFlushCbs)]</code> 拷贝一个 postFlushCbs 的副本，这是因为在遍历的过程中，可能某些回调函数的执行会再次修改 postFlushCbs，所以拷贝一个副本循环遍历则不会受到 postFlushCbs 修改的影响。</p><p>遍历完 postFlushCbs 后，会重置 isFlushing 为 false，因为一些 postFlushCb 执行过程中可能会再次添加异步任务，所以需要继续判断如果 queue 或者 postFlushCbs 队列中还存在任务，则递归执行 flushJobs 把它们都执行完毕。</p><h4 id="检测循环更新"><a href="#检测循环更新" class="headerlink" title="检测循环更新"></a>检测循环更新</h4><p>前面我们提到了，在遍历执行异步任务和回调函数的过程中，都会在非生产环境下执行 checkRecursiveUpdates 检测是否有循环更新，它是用来解决什么问题的呢？</p><p>我们把之前的例子改写一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) </span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">count</span>, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  state.<span class="property">count</span>++ </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count) </span><br><span class="line">&#125;) </span><br><span class="line">state.<span class="property">count</span>++ </span><br></pre></td></tr></table></figure><p>如果你去跑这个示例，你会在控制台看到输出了 101 次值，然后报了错误： <code>Maximum recursive updates exceeded</code> 。这是因为我们在 watcher 的回调函数里更新了数据，这样会再一次进入回调函数，如果我们不加任何控制，那么回调函数会一直执行，直到把内存耗尽造成浏览器假死。<br>为了避免这种情况，Vue.js 实现了 checkRecursiveUpdates 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RECURSION_LIMIT</span> = <span class="number">100</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkRecursiveUpdates</span>(<span class="params">seen, fn</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (!seen.<span class="title function_">has</span>(fn)) &#123; </span><br><span class="line">    seen.<span class="title function_">set</span>(fn, <span class="number">1</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> count = seen.<span class="title function_">get</span>(fn) </span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="variable constant_">RECURSION_LIMIT</span>) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Maximum recursive updates exceeded. &#x27;</span> + </span><br><span class="line">        <span class="string">&quot;You may have code that is mutating state in your component&#x27;s &quot;</span> + </span><br><span class="line">        <span class="string">&#x27;render function or updated hook or watcher source function.&#x27;</span>) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      seen.<span class="title function_">set</span>(fn, count + <span class="number">1</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的代码，我们知道 flushJobs 一开始便创建了 seen，它是一个 Map 对象，然后在 checkRecursiveUpdates 的时候会把任务添加到 seen 中，记录引用计数 count，初始值为 1，如果 postFlushCbs 再次添加了相同的任务，则引用计数 count 加 1，如果 count 大于我们定义的限制 100 ，则说明一直在添加这个相同的任务并超过了 100 次。那么，Vue.js 会抛出这个错误，因为在正常的使用中，不应该出现这种情况，而我们上述的错误示例就会触发这种报错逻辑。</p><h4 id="优化：只用一个变量"><a href="#优化：只用一个变量" class="headerlink" title="优化：只用一个变量"></a>优化：只用一个变量</h4><p>到这里，异步队列的设计就介绍完毕了，你可能会对 isFlushPending 和 isFlushing 有些疑问，为什么需要两个变量来控制呢？</p><p>从语义上来看，isFlushPending 用于判断是否在等待 nextTick 执行 flushJobs，而 isFlushing 是判断是否正在执行任务队列。</p><p>从功能上来看，它们的作用是为了确保以下两点：</p><ol><li>在一个 Tick 内可以多次添加任务到队列中，但是任务队列会在 nextTick 后执行；</li><li>在执行任务队列的过程中，也可以添加新的任务到队列中，并且在当前 Tick 去执行剩余的任务队列。</li></ol><p>但实际上，这里我们可以进行优化。在我看来，这里用一个变量就足够了，我们来稍微修改一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">queueFlush</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (!isFlushing) &#123; </span><br><span class="line">    isFlushing = <span class="literal">true</span> </span><br><span class="line">    <span class="title function_">nextTick</span><span class="params">(flushJobs)</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">function <span class="title function_">flushJobs</span><span class="params">(seen)</span> &#123; </span><br><span class="line">  let job </span><br><span class="line">  <span class="title function_">if</span> <span class="params">((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)</span>) &#123; </span><br><span class="line">    seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>() </span><br><span class="line">  &#125; </span><br><span class="line">  queue.sort((a, b) =&gt; getId(a) - getId(b)) </span><br><span class="line">  <span class="keyword">while</span> ((job = queue.shift()) !== undefined) &#123; </span><br><span class="line">    <span class="keyword">if</span> (job === <span class="literal">null</span>) &#123; </span><br><span class="line">      <span class="keyword">continue</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">      checkRecursiveUpdates(seen, job) </span><br><span class="line">    &#125; </span><br><span class="line">    callWithErrorHandling(job, <span class="literal">null</span>, <span class="number">14</span> <span class="comment">/* SCHEDULER */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  flushPostFlushCbs(seen) </span><br><span class="line">  <span class="keyword">if</span> (queue.length || postFlushCbs.length) &#123; </span><br><span class="line">    flushJobs(seen) </span><br><span class="line">  &#125; </span><br><span class="line">  isFlushing = <span class="literal">false</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以看到，我们只需要一个 isFlushing 来控制就可以实现相同的功能了。在执行 queueFlush 的时候，判断 isFlushing 为 false，则把它设置为 true，然后 nextTick 会执行 flushJobs。在 flushJobs 函数执行完成的最后，也就是所有的任务（包括后添加的）都执行完毕，再设置 isFlushing 为 false。</p><blockquote><p>我这么修改源码后也跑通了 Vue.js 3.0 的单元测试，如果你觉得这么实现有问题的话，欢迎在留言区评论与我讨论。</p></blockquote><p>了解完 watch API 和异步任务队列的设计后，我们再来学习侦听器提供的另一个 API—— watchEffect API。</p><h3 id="watchEffect-API"><a href="#watchEffect-API" class="headerlink" title="watchEffect API"></a>watchEffect API</h3><p>watchEffect API 的作用是注册一个副作用函数，副作用函数内部可以访问到响应式对象，当内部响应式对象变化后再立即执行这个函数。</p><p>可以先来看一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>)) </span><br><span class="line">count.<span class="property">value</span>++ </span><br></pre></td></tr></table></figure><p>它的结果是依次输出 0 和 1。<br>watchEffect 和前面的 watch API 有哪些不同呢？主要有三点：</p><ol><li><strong>侦听的源不同</strong> 。watch API 可以侦听一个或多个响应式对象，也可以侦听一个 getter 函数，而 watchEffect API 侦听的是一个普通函数，只要内部访问了响应式对象即可，这个函数并不需要返回响应式对象。</li><li><strong>没有回调函数</strong> 。watchEffect API 没有回调函数，副作用函数的内部响应式对象发生变化后，会再次执行这个副作用函数。</li><li><strong>立即执行</strong> 。watchEffect API 在创建好 watcher 后，会立刻执行它的副作用函数，而 watch API 需要配置 immediate 为 true，才会立即执行回调函数。</li></ol><p>对 watchEffect API 有大体了解后，我们来看一下在我整理的 watchEffect 场景下， doWatch 函数的简化版实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params">effect, options</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(effect, <span class="literal">null</span>, options); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123; </span><br><span class="line">  instance = currentInstance; </span><br><span class="line">  <span class="keyword">let</span> getter; </span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123; </span><br><span class="line">    getter = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (instance &amp;&amp; instance.<span class="property">isUnmounted</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">      &#125; </span><br><span class="line">       <span class="comment">// 执行清理函数 </span></span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123; </span><br><span class="line">        <span class="title function_">cleanup</span>(); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 执行 source 函数，传入 onInvalidate 作为参数 </span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callWithErrorHandling</span>(source, instance, <span class="number">3</span> <span class="comment">/* WATCH_CALLBACK */</span>, [onInvalidate]); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">let</span> cleanup; </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onInvalidate</span> = (<span class="params">fn</span>) =&gt; &#123; </span><br><span class="line">    cleanup = runner.<span class="property">options</span>.<span class="property">onStop</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="title function_">callWithErrorHandling</span>(fn, instance, <span class="number">4</span> <span class="comment">/* WATCH_CLEANUP */</span>); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="keyword">let</span> scheduler; </span><br><span class="line">  <span class="comment">// 创建 scheduler </span></span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123; </span><br><span class="line">    scheduler = invoke; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;pre&#x27;</span>) &#123; </span><br><span class="line">    scheduler = <span class="function"><span class="params">job</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (!instance || instance.<span class="property">isMounted</span>) &#123; </span><br><span class="line">        <span class="title function_">queueJob</span>(job); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="title function_">job</span>(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    scheduler = <span class="function"><span class="params">job</span> =&gt;</span> <span class="title function_">queuePostRenderEffect</span>(job, instance &amp;&amp; instance.<span class="property">suspense</span>); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 创建 runner </span></span><br><span class="line">  <span class="keyword">const</span> runner = <span class="title function_">effect</span>(getter, &#123; </span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="attr">computed</span>: <span class="literal">true</span>, </span><br><span class="line">    onTrack, </span><br><span class="line">    onTrigger, </span><br><span class="line">    scheduler </span><br><span class="line">  &#125;); </span><br><span class="line">  <span class="title function_">recordInstanceBoundEffect</span>(runner); </span><br><span class="line">  <span class="comment">// 立即执行 runner </span></span><br><span class="line">  <span class="title function_">runner</span>();</span><br><span class="line">  <span class="comment">// 返回销毁函数 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">stop</span>(runner);</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="title function_">remove</span>(instance.<span class="property">effects</span>, runner);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，getter 函数就是对 source 函数的简单封装，它会先判断组件实例是否已经销毁，然后每次执行 source 函数前执行 cleanup 清理函数。</p><p>watchEffect 内部创建的 runner 对应的 scheduler 对象就是 scheduler 函数本身，这样它再次执行时，就会执行这个 scheduler 函数，并且传入 runner 函数作为参数，其实就是按照一定的调度方式去执行基于 source 封装的 getter 函数。</p><p>创建完 runner 后就立刻执行了 runner，其实就是内部同步执行了基于 source 封装的 getter 函数。</p><p>在执行 source 函数的时候，会传入一个 onInvalidate 函数作为参数，接下来我们就来分析它的作用。</p><h4 id="注册无效回调函数"><a href="#注册无效回调函数" class="headerlink" title="注册无效回调函数"></a>注册无效回调函数</h4><p>有些时候，watchEffect 会注册一个副作用函数，在函数内部可以做一些异步操作，但是当这个 watcher 停止后，如果我们想去对这个异步操作做一些额外事情（比如取消这个异步操作），我们可以通过 onInvalidate 参数注册一个无效函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> id = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 执行异步操作 </span></span><br><span class="line">  <span class="keyword">const</span> token = <span class="title function_">performAsyncOperation</span>(id.<span class="property">value</span>) </span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 如果 id 发生变化或者 watcher 停止了，则执行逻辑取消前面的异步操作 </span></span><br><span class="line">    token.<span class="title function_">cancel</span>() </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>我们利用 watchEffect 注册了一个副作用函数，它有一个 onInvalidate 参数。在这个函数内部通过 performAsyncOperation 执行某些异步操作，并且访问了 id 这个响应式对象，然后通过 onInvalidate 注册了一个回调函数。</p><p>如果 id 发生变化或者 watcher 停止了，这个回调函数将会执行，然后执行 token.cancel 取消之前的异步操作。</p><p>我们来回顾 onInvalidate 在 doWatch 中的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onInvalidate</span> = (<span class="params">fn</span>) =&gt; &#123; </span><br><span class="line">  cleanup = runner.<span class="property">options</span>.<span class="property">onStop</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="title function_">callWithErrorHandling</span>(fn, instance, <span class="number">4</span> <span class="comment">/* WATCH_CLEANUP */</span>); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>实际上，当你执行 onInvalidate 的时候，就是注册了一个 cleanup 和 runner 的 onStop 方法，这个方法内部会执行 fn，也就是你注册的无效回调函数。</p><p>也就是说当响应式数据发生变化，会执行 cleanup 方法，当 watcher 被停止，会执行 onStop 方法，这两者都会执行注册的无效回调函数 fn。</p><p>通过这种方式，Vue.js 就很好地实现了 watcher 注册无效回调函数的需求。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的，到这里我们这一节的学习也要结束啦，通过这节课的学习，你应该掌握了侦听器内部实现原理，了解侦听器支持的几种配置参数的作用，以及异步任务队列的设计原理。</p><p>你也应该掌握侦听器的常见应用场景：如何用 watch API 观测数据的变化去执行一些逻辑，如何利用 watchEffect API 去注册一些副作用函数，如何去注册无效回调函数，以及如何停止一个正在运行的 watcher。</p><p>相比于计算属性，侦听器更适合用于在数据变化后执行某段逻辑的场景，而计算属性则用于一个数据依赖另外一些数据计算而来的场景。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-core&#x2F;src&#x2F;apiWatch.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;scheduler.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面中，我们多次提到回调函数是以一种调度的方式执行的，特别是当 flush 不是 sync 时，它会把回调函数执行的任务推到一个异步队列中执行。接下来，我们就来分析异步执行队列的设计。分析之前，我们先来思考一下，为什么会需要异步队列？&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="watch" scheme="https://xiaozhouguo.github.io/tags/watch/"/>
    
  </entry>
  
  <entry>
    <title>响应式内部的实现原理是怎么样的？- 下篇</title>
    <link href="https://xiaozhouguo.github.io/2022/08/01/vue3/reactive-inner-two/"/>
    <id>https://xiaozhouguo.github.io/2022/08/01/vue3/reactive-inner-two/</id>
    <published>2022-08-01T01:42:31.000Z</published>
    <updated>2022-08-01T03:13:14.051Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前了解在 Vue.js 3.0 中引入 reactive API，它可以把对象数据变成响应式，所以我们着重分析 reactive API 的实现原理，并学习了收集依赖的 get 函数， 这节课我们继续来分析 reactive API 中需要关注的另一个内容——派发通知的过程。</p><span id="more"></span><h3 id="reactive-API"><a href="#reactive-API" class="headerlink" title="reactive API"></a>reactive API</h3><h4 id="派发通知-set-函数"><a href="#派发通知-set-函数" class="headerlink" title="派发通知 set 函数"></a>派发通知 set 函数</h4><p><strong>派发通知发生在数据更新的阶段</strong> ，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性更新的时候就会执行 set 函数。我们来看一下 set 函数的实现，它是执行 createSetter 函数的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">    value = <span class="title function_">toRaw</span>(value)</span><br><span class="line">    <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了</span></span><br><span class="line">    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="string">&quot;add&quot;</span> <span class="comment">/* ADD */</span>, key, value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="string">&quot;set&quot;</span> <span class="comment">/* SET */</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上述代码来看，set 函数的实现逻辑很简单，主要就做两件事情， <strong>首先通过 Reflect.set 求值</strong> ， <strong>然后通过 trigger 函数派发通知</strong> ，并依据 key 是否存在于 target 上来确定通知类型，即新增还是修改。</p><p>整个 set 函数最核心的部分就是 <strong>执行 trigger 函数派发通知</strong> ，下面我们将重点分析这个过程。</p><p>我们先来看一下 trigger 函数的实现，为了分析主要流程，这里省略了 trigger 函数中的一些分支逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始数据对象 map</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, type, key, newValue</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过 targetMap 拿到 target 对应的依赖集合</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// 没有依赖，直接返回</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建运行的 effects 集合</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  <span class="comment">// 添加 effects 的函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">effectsToAdd</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        effects.<span class="title function_">add</span>(effect)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// SET | ADD | DELETE 操作之一，添加对应的 effects</span></span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(key))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 调度执行</span></span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接运行</span></span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历执行 effects</span></span><br><span class="line">  effects.<span class="title function_">forEach</span>(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trigger 函数的实现也很简单，主要做了四件事情：</p><ol><li>通过 targetMap 拿到 target 对应的依赖集合 depsMap；</li><li>创建运行的 effects 集合；</li><li>根据 key 从 depsMap 中找到对应的 effects 添加到 effects 集合；</li><li>遍历 effects 执行相关的副作用函数。</li></ol><p>所以每次 trigger 函数就是根据 target 和 key ，从 targetMap 中找到相关的所有副作用函数遍历执行一遍。</p><p>在描述依赖收集和派发通知的过程中，我们都提到了一个词：副作用函数，依赖收集过程中我们把 activeEffect（当前激活副作用函数）作为依赖收集，它又是什么？接下来我们来看一下副作用函数的庐山真面目。</p><h4 id="副作用函数"><a href="#副作用函数" class="headerlink" title="副作用函数"></a>副作用函数</h4><p>介绍副作用函数前，我们先回顾一下响应式的原始需求，即我们修改了数据就能自动执行某个函数，举个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">num</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter.<span class="property">num</span>++</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">logCount</span>()</span><br><span class="line"><span class="title function_">count</span>()</span><br></pre></td></tr></table></figure><p>可以看到，这里我们定义了响应式对象 counter，然后我们在 logCount 中访问了 counter.num，我们希望通过执行 count 函数修改 counter.num 值的时候，能自动执行 logCount 函数。</p><p>按我们之前对依赖收集过程的分析，如果这个 logCount 就是 activeEffect 的话，那么就可以实现需求，但显然是做不到的，因为代码在执行到 <code>console.log(counter.num)</code>这一行 的时候，它对自己在 logCount 函数中的运行是一无所知的。</p><p>那么该怎么办呢？其实只要我们运行 logCount 函数前，把 logCount 赋值给 activeEffect 就好了，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activeEffect = logCount </span><br><span class="line"><span class="title function_">logCount</span>()</span><br></pre></td></tr></table></figure><p>顺着这个思路，我们可以利用高阶函数的思想，对 logCount 做一层封装，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapped = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    activeEffect = fn</span><br><span class="line">    <span class="title function_">fn</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> wrapped</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrappedLog = <span class="title function_">wrapper</span>(logCount)</span><br><span class="line"><span class="title function_">wrappedLog</span>()</span><br></pre></td></tr></table></figure><p>这里，wrapper 本身也是一个函数，它接受 fn 作为参数，返回一个新的函数 wrapped，然后维护一个全局的 activeEffect，当 wrapped 执行的时候，把 activeEffect 设置为 fn，然后执行 fn 即可。</p><p>这样当我们执行 wrappedLog 后，再去修改 counter.num，就会自动执行 logCount 函数了。</p><p>实际上 Vue.js 3.0 就是采用类似的做法，在它内部就有一个 effect 副作用函数，我们来看一下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局 effect 栈</span></span><br><span class="line"><span class="keyword">const</span> effectStack = []</span><br><span class="line"><span class="comment">// 当前激活的 effect</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = EMPTY_OBJ</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isEffect</span>(fn)) &#123;</span><br><span class="line">    <span class="comment">// 如果 fn 已经是一个 effect 函数了，则指向原始函数</span></span><br><span class="line">    fn = fn.<span class="property">raw</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个 wrapper，它是一个响应式的副作用的函数</span></span><br><span class="line">  <span class="keyword">const</span> effect = <span class="title function_">createReactiveEffect</span>(fn, options)</span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="comment">// lazy 配置，计算属性会用到，非 lazy 则直接执行一次</span></span><br><span class="line">    <span class="title function_">effect</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveEffect</span>(<span class="params">fn, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="keyword">function</span> <span class="title function_">reactiveEffect</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="comment">// 非激活状态，则判断如果非调度执行，则直接执行原始函数。</span></span><br><span class="line">      <span class="keyword">return</span> options.<span class="property">scheduler</span> ? <span class="literal">undefined</span> : <span class="title function_">fn</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!effectStack.<span class="title function_">includes</span>(effect)) &#123;</span><br><span class="line">      <span class="comment">// 清空 effect 引用的依赖</span></span><br><span class="line">      <span class="title function_">cleanup</span>(effect)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开启全局 shouldTrack，允许依赖收集</span></span><br><span class="line">        <span class="title function_">enableTracking</span>()</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        effectStack.<span class="title function_">push</span>(effect)</span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="comment">// 执行原始函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        effectStack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="comment">// 恢复 shouldTrack 开启之前的状态</span></span><br><span class="line">        <span class="title function_">resetTracking</span>()</span><br><span class="line">        <span class="comment">// 指向栈最后一个 effect</span></span><br><span class="line">        activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  effect.<span class="property">id</span> = uid++</span><br><span class="line">  <span class="comment">// 标识是一个 effect 函数</span></span><br><span class="line">  effect.<span class="property">_isEffect</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// effect 自身的状态</span></span><br><span class="line">  effect.<span class="property">active</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 包装的原始函数</span></span><br><span class="line">  effect.<span class="property">raw</span> = fn</span><br><span class="line">  <span class="comment">// effect 对应的依赖，双向指针，依赖包含对 effect 的引用，effect 也包含对依赖的引用</span></span><br><span class="line">  effect.<span class="property">deps</span> = []</span><br><span class="line">  <span class="comment">// effect 的相关配置</span></span><br><span class="line">  effect.<span class="property">options</span> = options</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上述代码来看，effect 内部通过执行 <code>createReactiveEffect</code> 函数去创建一个新的 effect 函数，为了和外部的 effect 函数区分，我们把它称作 reactiveEffect 函数，并且还给它添加了一些额外属性（我在注释中都有标明）。另外，effect 函数还支持传入一个配置参数以支持更多的 feature，我们这里就不展开了，在后续的章节会详细分析。</p><p>接着说，这个 reactiveEffect 函数就是响应式的副作用函数，当执行 trigger 过程派发通知的时候，执行的 effect 就是它。</p><p>按我们之前的分析，这个 reactiveEffect 函数只需要做两件事情： <strong>把全局的 activeEffect 指向它</strong> ， <strong>然后执行被包装的原始函数 fn 即可</strong> 。</p><p>但实际上它的实现要更复杂一些，首先它会判断 effect 的状态是否是 active，这其实是一种控制手段，允许在非 active 状态且非调度执行情况，则直接执行原始函数 fn 并返回，在后续学习完侦听器后你会对它的理解更加深刻。</p><p>接着判断 effectStack 中是否包含 effect，如果没有就把 effect 压入栈内。之前我们提到，只要设置 activeEffect &#x3D; effect 即可，那么这里为什么要设计一个栈的结构呢？</p><p>其实是考虑到以下这样一个嵌套 effect 的场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> &#123; effect &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">reactive</span>(&#123; </span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span>, </span><br><span class="line">  <span class="attr">num2</span>: <span class="number">0</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logCount</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title function_">effect</span>(logCount2) </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num:&#x27;</span>, counter.<span class="property">num</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123; </span><br><span class="line">  counter.<span class="property">num</span>++ </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logCount2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num2:&#x27;</span>, counter.<span class="property">num2</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">effect</span>(logCount) </span><br><span class="line"><span class="title function_">count</span>()</span><br></pre></td></tr></table></figure><p>我们每次执行 effect 函数时，如果仅仅把 reactiveEffect 函数赋值给 activeEffect，那么针对这种嵌套场景，执行完 effect(logCount2) 后，activeEffect 还是 effect(logCount2) 返回的 reactiveEffect 函数，这样后续访问 counter.num 的时候，依赖收集对应的 activeEffect 就不对了，此时我们外部执行 count 函数修改 counter.num 后执行的便不是 logCount 函数，而是 logCount2 函数，最终输出的结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">num2</span>: <span class="number">0</span> </span><br><span class="line"><span class="attr">num</span>: <span class="number">0</span> </span><br><span class="line"><span class="attr">num2</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>而我们期望的结果应该如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">num2</span>: <span class="number">0</span> </span><br><span class="line"><span class="attr">num</span>: <span class="number">0</span> </span><br><span class="line"><span class="attr">num2</span>: <span class="number">0</span> </span><br><span class="line"><span class="attr">num</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>因此针对嵌套 effect 的场景，我们不能简单地赋值 activeEffect，应该考虑到函数的执行本身就是一种入栈出栈操作，因此我们也可以设计一个 effectStack，这样每次进入 reactiveEffect 函数就先把它入栈，然后 activeEffect 指向这个 reactiveEffect 函数，接着在 fn 执行完毕后出栈，再把 activeEffect 指向 effectStack 最后一个元素，也就是外层 effect 函数对应的 reactiveEffect。</p><p>这里我们还注意到一个细节，<strong>在入栈前会执行 cleanup 函数清空 reactiveEffect 函数对应的依赖</strong> 。在执行 track 函数的时候，除了收集当前激活的 effect 作为依赖，还通过 activeEffect.deps.push(dep) 把 dep 作为 activeEffect 的依赖，这样在 cleanup 的时候我们就可以找到 effect 对应的 dep 了，然后把 effect 从这些 dep 中删除。cleanup 函数的代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cleanup</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deps &#125; = effect</span><br><span class="line">  <span class="keyword">if</span> (deps.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      deps[i].<span class="title function_">delete</span>(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    deps.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么需要 cleanup 呢？如果遇到这种场景：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;state.showMsg&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; state.msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    &#123;&#123; Math.random()&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span>Toggle Msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;switchView&quot;</span>&gt;</span>Switch View<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">showMsg</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">toggle</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        state.<span class="property">msg</span> = state.<span class="property">msg</span> === <span class="string">&#x27;Hello World&#x27;</span> ? <span class="string">&#x27;Hello Vue&#x27;</span> : <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">switchView</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        state.<span class="property">showMsg</span> = !state.<span class="property">showMsg</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      toggle,</span></span><br><span class="line"><span class="language-javascript">        switchView,</span></span><br><span class="line"><span class="language-javascript">        state</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结合代码可以知道，这个组件的视图会根据 <code>showMsg</code> 变量的控制显示 msg 或者一个随机数，当我们点击 <code>Switch View </code>的按钮时，就会修改这个变量值。</p><p>假设没有 cleanup，在第一次渲染模板的时候，activeEffect 是组件的副作用渲染函数，因为模板 render 的时候访问了 state.msg，所以会执行依赖收集，把副作用渲染函数作为 state.msg 的依赖，我们把它称作 <code>render effect</code>。然后我们点击 Switch View 按钮，视图切换为显示随机数，此时我们再点击 <code>Toggle Msg</code> 按钮，由于修改了 state.msg 就会派发通知，找到了 render effect 并执行，就又触发了组件的重新渲染。</p><p>但这个行为实际上并不符合预期，因为当我们点击 Switch View 按钮，视图切换为显示随机数的时候，也会触发组件的重新渲染，但这个时候视图并没有渲染 state.msg，所以对它的改动并不应该影响组件的重新渲染。</p><p>因此在组件的 render effect 执行之前，如果通过 cleanup 清理依赖，我们就可以删除之前 state.msg 收集的 render effect 依赖。这样当我们修改 state.msg 时，由于已经没有依赖了就不会触发组件的重新渲染，符合预期。</p><p>至此，我们从 reactive API 入手了解了整个响应式对象的实现原理。除了 reactive API，Vue.js 3.0 还提供了其他好用的响应式 API，接下来我们一起分析一些常用的。</p><h3 id="readonly-API"><a href="#readonly-API" class="headerlink" title="readonly API"></a>readonly API</h3><p>如果用 const 声明一个对象变量，虽然不能直接对这个变量赋值，但我们可以修改它的属性。如果我们希望创建只读对象，不能修改它的属性，也不能给这个对象添加和删除属性，让它变成一个真正意义上的只读对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrapped = <span class="title function_">readonly</span>(original)</span><br><span class="line">wrapped.<span class="property">foo</span> = <span class="number">2</span></span><br><span class="line"><span class="comment">// warn: Set operation on key &quot;foo&quot; failed: target is readonly.</span></span><br></pre></td></tr></table></figure><p>显然，想实现上述需求就需要劫持对象，于是 Vue.js 3.0 在 reactive API 的基础上，设计并实现了 readonly API。</p><p>我们先来看一下 readonly 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readonly</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(target, <span class="literal">true</span>, readonlyHandlers, readonlyCollectionHandlers)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadonly, baseHandlers, collectionHandlers</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="comment">// 目标必须是对象或数组类型</span></span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(value cannot be made <span class="attr">reactive</span>: $&#123;<span class="title class_">String</span>(target)&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">__v_raw</span> &amp;&amp; !(isReadonly &amp;&amp; target.<span class="property">__v_isReactive</span>)) &#123;</span><br><span class="line"><span class="comment">// target 已经是 Proxy 对象，直接返回</span></span><br><span class="line"><span class="comment">// 有个例外，如果是 readonly 作用于一个响应式对象，则继续</span></span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(</span><br><span class="line">        target, </span><br><span class="line">        isReadonly ? <span class="string">&quot;__v_readonly&quot;</span> <span class="comment">/* readonly */</span> : <span class="string">&quot;__v_reactive&quot;</span> / <span class="comment">/* reactive */</span></span><br><span class="line">     )</span><br><span class="line">  ) &#123;</span><br><span class="line"><span class="comment">// target 已经有对应的 Proxy 了</span></span><br><span class="line"><span class="keyword">return</span> isReadonly ? target.<span class="property">__v_readonly</span> : target.<span class="property">__v_reactive</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有在白名单里的数据类型才能变成响应式</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">canObserve</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用 Proxy 创建响应式</span></span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, </span><br><span class="line">        collectionTypes.<span class="title function_">has</span>(target.<span class="property">constructor</span>) ? collectionHandlers : baseHandlers)</span><br><span class="line">  <span class="comment">// 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了</span></span><br><span class="line">  <span class="title function_">def</span>(target, </span><br><span class="line">      isReadonly ? <span class="string">&quot;__v_readonly&quot;</span> <span class="comment">/* readonly */</span> : <span class="string">&quot;__v_reactive&quot;</span> <span class="comment">/*reactive */</span>,</span><br><span class="line">      observed</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 readonly 和 reactive 函数的主要区别，就是执行 <code>createReactiveObject</code> 函数时的参数 isReadonly 不同。</p><p>我们来看这里的代码，首先 isReadonly 变量为 true，所以在创建过程中会给原始对象 target 打上一个 <code>__v_readonly</code> 的标识。另外还有一个特殊情况，如果 target 已经是一个 reactive 对象，就会把它继续变成一个 readonly 响应式对象。</p><p>其次就是 <code>baseHandlers</code> 的 <code>collectionHandlers</code> 的区别，我们这里仍然只关心基本数据类型的 Proxy 处理器对象，readonly 函数传入的 baseHandlers 值是 <code>readonlyHandlers</code>。</p><p>接下来，我们来看一下其中 readonlyHandlers 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readonlyHandlers = &#123;</span><br><span class="line">  <span class="attr">get</span>: readonlyGet,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`Set operation on key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot; failed: target is readonly.`</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`Delete operation on key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot; failed: target is readonly.`</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readonlyHandlers 和 mutableHandlers 的区别主要在 get、set 和 deleteProperty 三个函数上。很显然，作为一个只读的响应式对象，是不允许修改属性以及删除属性的，所以在非生产环境下 set 和 deleteProperty 函数的实现都会报警告，提示用户 target 是 readonly 的。</p><p>接下来我们来看一下其中 readonlyGet 的实现，它其实就是 createGetter(true) 的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// isReadonly 为 true 则不需要依赖收集</span></span><br><span class="line">    !isReadonly &amp;&amp; <span class="title function_">track</span>(target, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isObject</span>(res)</span><br><span class="line">      ? isReadonly</span><br><span class="line">        ?</span><br><span class="line">        <span class="comment">// 如果 res 是个对象或者数组类型，则递归执行 readonly 函数把 res readonly</span></span><br><span class="line">        <span class="title function_">readonly</span>(res)</span><br><span class="line">        : <span class="title function_">reactive</span>(res)</span><br><span class="line">      : res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它和 reactive API 最大的区别就是不做依赖收集了，这一点也非常好理解，因为它的属性不会被修改，所以就不用跟踪它的变化了。</p><p>到这里，readonly API 就介绍完了，接下来我们分析一下另一个常用的响应式 API：ref。</p><h3 id="ref-API"><a href="#ref-API" class="headerlink" title="ref API"></a>ref API</h3><p>通过前面的分析，我们知道 reactive API 对传入的 target 类型有限制，必须是对象或者数组类型，而对于一些基础类型（比如 String、Number、Boolean）是不支持的。</p><p>但是有时候从需求上来说，可能我只希望把一个字符串变成响应式，却不得不封装成一个对象，这样使用上多少有一些不方便，于是 Vue.js 3.0 设计并实现了 ref API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World&#x27;</span>) </span><br><span class="line">msg.<span class="property">value</span> = <span class="string">&#x27;Hello Vue&#x27;</span></span><br></pre></td></tr></table></figure><p>我们先来看一下 ref 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">ref</span><span class="params">(value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> createRef(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="variable">convert</span> <span class="operator">=</span> (val) =&gt; isObject(val) ? reactive(val) : val</span><br><span class="line">function <span class="title function_">createRef</span><span class="params">(rawValue)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRef(rawValue)) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的就是一个 ref，那么返回自身即可，处理嵌套 ref 的情况。</span></span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是对象或者数组类型，则转换一个 reactive 对象。</span></span><br><span class="line">  <span class="type">let</span> <span class="variable">value</span> <span class="operator">=</span> convert(rawValue)</span><br><span class="line">  <span class="type">const</span> <span class="variable">r</span> <span class="operator">=</span> &#123;</span><br><span class="line">    __v_isRef: <span class="literal">true</span>,</span><br><span class="line">    get <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// getter</span></span><br><span class="line">      <span class="comment">// 依赖收集，key 为固定的 value</span></span><br><span class="line">      track(r, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;,</span><br><span class="line">    set <span class="title function_">value</span><span class="params">(newVal)</span> &#123;</span><br><span class="line">      <span class="comment">// setter，只处理 value 属性的修改</span></span><br><span class="line">      <span class="keyword">if</span> (hasChanged(toRaw(newVal), rawValue)) &#123;</span><br><span class="line">        <span class="comment">// 判断有变化后更新值</span></span><br><span class="line">        rawValue = <span class="type">newVal</span></span><br><span class="line"><span class="variable">value</span> <span class="operator">=</span> convert(newVal)</span><br><span class="line"><span class="comment">// 派发通知</span></span><br><span class="line">trigger(r, <span class="string">&quot;set&quot;</span> <span class="comment">/* SET */</span>, <span class="string">&#x27;value&#x27;</span>, <span class="keyword">void</span> <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，函数首先处理了嵌套 ref 的情况，如果传入的 rawValue 也是 ref，那么直接返回。</p><p>接着对 rawValue 做了一层转换，如果 rawValue 是对象或者数组类型，那么把它转换成一个 reactive 对象。</p><p>最后定义一个对 value 属性做 getter 和 setter 劫持的对象并返回，get 部分就是执行 track 函数做依赖收集然后返回它的值；set 部分就是设置新值并且执行 trigger 函数派发通知。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后我们通过一张图来看一下整个响应式 API 实现和组件更新的关系：</p><img src="/2022/08/01/vue3/reactive-inner-two/CgqCHl8iOeqAJJlaAAHAhGDRoDQ714.png" class=""><p>这幅图是不是很眼熟？没错，它和前面 Vue.js 2.x 的响应式原理图很接近，其实 Vue.js 3.0 在响应式的实现思路和 Vue.js 2.x 差别并不大，主要就是 <strong>劫持数据的方式改成用 Proxy 实现</strong> ， <strong>以及收集的依赖由 watcher 实例变成了组件副作用渲染函数</strong> 。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;reactivity&#x2F;src&#x2F;baseHandlers.ts<br>packages&#x2F;reactivity&#x2F;src&#x2F;effect.ts<br>packages&#x2F;reactivity&#x2F;src&#x2F;reactive.ts<br>packages&#x2F;reactivity&#x2F;src&#x2F;ref.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们之前了解在 Vue.js 3.0 中引入 reactive API，它可以把对象数据变成响应式，所以我们着重分析 reactive API 的实现原理，并学习了收集依赖的 get 函数， 这节课我们继续来分析 reactive API 中需要关注的另一个内容——派发通知的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="reactive" scheme="https://xiaozhouguo.github.io/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入：子孙组件如何共享数据？</title>
    <link href="https://xiaozhouguo.github.io/2022/07/26/vue3/provide-inject/"/>
    <id>https://xiaozhouguo.github.io/2022/07/26/vue3/provide-inject/</id>
    <published>2022-07-26T06:46:22.000Z</published>
    <updated>2022-08-01T02:37:19.087Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 为我们提供了很多组件通讯的方式，常见的是父子组件通过 props 传递数据。但是有时，我们希望能<strong>跨父子组件通讯</strong>，比如，无论组件之间嵌套多少层级，我都希望在后代组件中能访问它们祖先组件的数据。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue.js 2.x 给我们提供了一种依赖注入的解决方案，即在祖先组件提供一个 provide 选项，举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="attr">provide</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      <span class="attr">foo</span>: <span class="variable language_">this</span>.<span class="property">foo</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就相当于在祖先组件提供 foo 这个变量数据，我们就可以在任意子孙组件中注入这个变量数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;foo&#x27;</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以在子孙组件中通过 this.foo 访问祖先组件提供的数据，以达到组件通讯的目的。</p><p>到了 Vue.js 3.0，除了可以继续沿用这种 Options 的依赖注入，还可以使用依赖注入的 API 函数 provide 和 inject，你可以在 setup 函数中调用它们。</p><p>举个例子，我们在祖先组件调用 provide API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider </span></span><br><span class="line"><span class="keyword">import</span> &#123; provide, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> theme = <span class="title function_">ref</span>(<span class="string">&#x27;dark&#x27;</span>) </span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;theme&#x27;</span>, theme) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在子孙组件调用 inject API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer </span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> theme = <span class="title function_">inject</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>) </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      theme </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说明的是，inject 函数接受第二个参数作为默认值，如果祖先组件上下文没有提供 theme，则使用这个默认值。</p><p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，而且它的规则更加宽松：<strong>祖先组件不需要知道哪些后代组件在使用它提供的数据，后代组件也不需要知道注入的数据来自哪里</strong>。</p><p>那么，依赖注入的背后实现原理是怎样的呢？接下来我们就一起分析吧。</p><h3 id="provide-API"><a href="#provide-API" class="headerlink" title="provide API"></a>provide API</h3><p>我们先来分析 provide API 的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">provide</span>(<span class="params">key, value</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> provides = currentInstance.<span class="property">provides</span> </span><br><span class="line">  <span class="keyword">const</span> parentProvides = currentInstance.<span class="property">parent</span> &amp;&amp; currentInstance.<span class="property">parent</span>.<span class="property">provides</span> </span><br><span class="line">  <span class="keyword">if</span> (parentProvides === provides) &#123; </span><br><span class="line">    provides = currentInstance.<span class="property">provides</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parentProvides) </span><br><span class="line">  &#125; </span><br><span class="line">  provides[key] = value </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建组件实例的时候，组件实例的 provides 对象指向父组件实例的 provides 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = &#123; </span><br><span class="line">  <span class="comment">// 依赖注入相关 </span></span><br><span class="line">  <span class="attr">provides</span>: parent ? parent.<span class="property">provides</span> : <span class="title class_">Object</span>.<span class="title function_">create</span>(appContext.<span class="property">provides</span>), </span><br><span class="line">  <span class="comment">// 其它属性 </span></span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们可以通过一张图直观感受一下它们之间的关系：</p><img src="/2022/07/26/vue3/provide-inject/CgqCHl86T3KAQuhfAACt-IfYuPc049.png" class=""><p>所以在默认情况下，组件实例的 provides 继承它的父组件，但是当组件实例需要提供自己的值的时候，它使用父级提供的对象创建自己的 provides 的对象原型。通过这种方式，在 inject 阶段，我们可以非常容易通过原型链查找来自直接父级提供的数据。</p><p>另外，如果组件实例提供和父级 provides 中有相同 key 的数据，是可以覆盖父级提供的数据。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, h, provide, inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProviderOne</span> = &#123; </span><br><span class="line">  setup () &#123; </span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>) </span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="title class_">ProviderTwo</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProviderTwo</span> = &#123; </span><br><span class="line">  setup () &#123; </span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;fooOverride&#x27;</span>) </span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="title class_">Consumer</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Consumer</span> = &#123; </span><br><span class="line">  setup () &#123; </span><br><span class="line">    <span class="keyword">const</span> foo = <span class="title function_">inject</span>(<span class="string">&#x27;foo&#x27;</span>) </span><br><span class="line">    <span class="keyword">const</span> bar = <span class="title function_">inject</span>(<span class="string">&#x27;bar&#x27;</span>) </span><br><span class="line">    <span class="keyword">const</span> baz = <span class="title function_">inject</span>(<span class="string">&#x27;baz&#x27;</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [foo, bar, baz].<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>)) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">ProviderOne</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这是一个嵌套 provider 的情况。根据 provide 函数的实现，ProviderTwo 提供的 key 为 foo 的 provider 会覆盖 ProviderOne 提供的 key 为 foo 的 provider，所以最后渲染在 Consumer 组件上的就是 <code>fooOverride&amp;bar&amp;baz</code> 。</p><p>接下来，我们来分析另一个依赖注入的 API —— inject。</p><h3 id="inject-API"><a href="#inject-API" class="headerlink" title="inject API"></a>inject API</h3><p>我们先来看 inject API 的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inject</span>(<span class="params">key, defaultValue</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> instance = currentInstance || currentRenderingInstance </span><br><span class="line">  <span class="keyword">if</span> (instance) &#123; </span><br><span class="line">    <span class="keyword">const</span> provides = instance.<span class="property">provides</span> </span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> provides) &#123; </span><br><span class="line">      <span class="keyword">return</span> provides[key] </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> defaultValue </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123; </span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`injection &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot; not found.`</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前文我们已经分析了 provide 的实现后，在此基础上，理解 inject 的实现就非常简单了。inject 支持两个参数，第一个参数是 key，我们可以访问组件实例中的 provides 对象对应的 key，层层查找父级提供的数据。第二个参数是默认值，如果查找不到数据，则直接返回默认值。</p><p>如果既查找不到数据且也没有传入默认值，则在非生产环境下报警告，提示用户找不到这个注入的数据。</p><p>到这里我们就掌握了 provide 和 inject 的实现原理。但是，我曾经看到过一个问题：“ Vue.js 3 跨组件共享数据，为何要用 provide&#x2F;inject ？直接 export&#x2F;import 数据行吗？“</p><p>接下来我们就来探讨依赖注入和模块化共享数据的差异。</p><h3 id="对比模块化共享数据的方式"><a href="#对比模块化共享数据的方式" class="headerlink" title="对比模块化共享数据的方式"></a>对比模块化共享数据的方式</h3><p>我们先来看提问者给出的一个模块化共享数据的示例，即首先在根组件创建一个共享的数据 sharedData：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Root.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sharedData = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Root&#x27;</span>, </span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在子组件中使用 sharedData：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sharedData &#125; <span class="keyword">from</span> <span class="string">&#x27;./Root.js&#x27;</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Root&#x27;</span>, </span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里直接使用 sharedData 即可 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，从这个示例上来看，模块化的方式是可以共享数据，但是 provide 和 inject 与模块化方式有如下几点不同。</p><ul><li><strong>作用域不同</strong></li></ul><p>对于依赖注入，它的作用域是局部范围，所以你只能把数据注入以这个节点为根的后代组件中，不是这棵子树上的组件是不能访问到该数据的；而对于模块化的方式，它的作用域是全局范围的，你可以在任何地方引用它导出的数据。</p><ul><li><strong>数据来源不同</strong></li></ul><p>对于依赖注入，后代组件是不需要知道注入的数据来自哪里，只管注入并使用即可；而对于模块化的方式提供的数据，用户必须明确知道这个数据是在哪个模块定义的，从而引入它。</p><ul><li><strong>上下文不同</strong></li></ul><p>对于依赖注入，提供数据的组件的上下文就是组件实例，而且同一个组件定义是可以有多个组件实例的，我们可以根据不同的组件上下文提供不同的数据给后代组件；而对于模块化提供的数据，它是没有任何上下文的，仅仅是这个模块定义的数据，如果想要根据不同的情况提供不同数据，那么从 API 层面设计就需要做更改。</p><p>比如允许用户传递一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getShareData</span>(<span class="params">context</span>) &#123; </span><br><span class="line">  <span class="comment">// 根据不同的 context 参数返回不同的数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掌握了这些不同，在不同场景下你就应该知道选择哪种方式提供数据了。</p><h3 id="依赖注入的缺陷和应用场景"><a href="#依赖注入的缺陷和应用场景" class="headerlink" title="依赖注入的缺陷和应用场景"></a>依赖注入的缺陷和应用场景</h3><p>我们再回到依赖注入，它确实提供了一种组件共享的方式，但并非完美的。正因为依赖注入是上下文相关的，所以它会将你应用程序中的组件与它们当前的组织方式耦合起来，这使得重构变得困难。</p><p>来回顾一下依赖注入的特点 ：<strong>祖先组件不需要知道哪些后代组件使用它提供的数据</strong>，<strong>后代组件也不需要知道注入的数据来自哪里</strong>。</p><p>如果在一次重构中我们不小心挪动了有依赖注入的后代组件的位置，或者是挪动了提供数据的祖先组件的位置，都有可能导致后代组件丢失注入的数据，进而导致应用程序异常。所以，我<strong>并不推荐在普通应用程序代码中使用依赖注入</strong>。</p><p>但是我推荐你在组件库的开发中使用，因为对于一个特定组件，它和其嵌套的子组件上下文联系很紧密。</p><p>这里来举一个 Element-UI 组件库 Select 组件的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">el-select</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请选择&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-option</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;item in options&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">:label</span>=<span class="string">&quot;item.label&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">:value</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-option</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-select</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">options</span>: [&#123; </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">value</span>: <span class="string">&#x27;选项1&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">label</span>: <span class="string">&#x27;黄金糕&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">value</span>: <span class="string">&#x27;选项2&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">label</span>: <span class="string">&#x27;双皮奶&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">value</span>: <span class="string">&#x27;选项3&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">label</span>: <span class="string">&#x27;蚵仔煎&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">value</span>: <span class="string">&#x27;选项4&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">label</span>: <span class="string">&#x27;龙须面&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">value</span>: <span class="string">&#x27;选项5&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">label</span>: <span class="string">&#x27;北京烤鸭&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">        &#125;], </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">      &#125; </span></span><br><span class="line"><span class="language-javascript">    &#125; </span></span><br><span class="line"><span class="language-javascript">  &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是 Select 组件的基础示例，它最终会在页面上渲染成这样：</p><img src="/2022/07/26/vue3/provide-inject/Ciqc1F86T9CAGMkuAACL3WKe6QA403.png" class=""><p>子组件 ElOption 负责渲染每一个选项，它的内部想要访问最外层的 ElSelect 组件时，就可以通过依赖注入的方式，在 ElSelect 组件中提供组件的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      <span class="string">&#x27;select&#x27;</span>: <span class="variable language_">this</span> </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们可以在 ElOption 组件注入这个数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;select&#x27;</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这些代码还是用的 Vue.js 2.x 的 Options API 方式，但是依赖注入的思想是不变的。</p><p>你可能会问，为什么不在 ElOption 子组件内通过 this.$parent 访问外层的 ElSelect 组件实例呢？</p><p>虽然 this.$parent 指向的是它的父组件实例，在我们这个例子是可以的，但如果组件结构发生了变化呢？</p><p>我们再来看另一个 Select 组件的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">el-select</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请选择&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-option-group</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;group in options&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">&quot;group.label&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">:label</span>=<span class="string">&quot;group.label&quot;</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">el-option</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">v-for</span>=<span class="string">&quot;item in group.options&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:label</span>=<span class="string">&quot;item.label&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">:value</span>=<span class="string">&quot;item.value&quot;</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-option</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-option-group</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-select</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">options</span>: [&#123; </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">label</span>: <span class="string">&#x27;热门城市&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">options</span>: [&#123; </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">value</span>: <span class="string">&#x27;Shanghai&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">label</span>: <span class="string">&#x27;上海&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">          &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">value</span>: <span class="string">&#x27;Beijing&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">label</span>: <span class="string">&#x27;北京&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">          &#125;] </span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">label</span>: <span class="string">&#x27;城市名&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">          <span class="attr">options</span>: [&#123; </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">value</span>: <span class="string">&#x27;Chengdu&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">label</span>: <span class="string">&#x27;成都&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">          &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">value</span>: <span class="string">&#x27;Shenzhen&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">label</span>: <span class="string">&#x27;深圳&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">          &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">value</span>: <span class="string">&#x27;Guangzhou&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">label</span>: <span class="string">&#x27;广州&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">          &#125;, &#123; </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">value</span>: <span class="string">&#x27;Dalian&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="attr">label</span>: <span class="string">&#x27;大连&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">          &#125;] </span></span><br><span class="line"><span class="language-javascript">        &#125;], </span></span><br><span class="line"><span class="language-javascript">        <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">      &#125; </span></span><br><span class="line"><span class="language-javascript">    &#125; </span></span><br><span class="line"><span class="language-javascript">  &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是 Select 组件的分组示例，最终会在页面上渲染成这样：</p><img src="/2022/07/26/vue3/provide-inject/CgqCHl86T-OAVgk-AACFqLBanFk012.png" class=""><p>显然，这里 ElOption 中的 this.$parent 指向的就不是 ElSelect 组件实例，而是 ElOptionGroup 组件实例。但如果我们用依赖注入的方式，即使结构变了，还是可以在 ElOption 组件中正确访问到 ElSelect 的实例。</p><p>所以，this.$parent 是一种强耦合的获取父组件实例方式，非常不利于代码的重构，因为一旦组件层级发生变化，就会产生非预期的后果，所以在平时的开发工作中你应该慎用这个属性。</p><p>相反，在组件库的场景中，依赖注入还是很方便的，除了示例中提供组件实例数据，还可以提供任意类型的数据。因为入口组件和它的相关子组件关联性是很强的，无论后代组件的结构如何变化，最终都会渲染在入口组件的子树上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的，到这里我们这一节的学习就结束啦，通过这节课的学习，你应该掌握 Vue.js 依赖注入的实现原理，了解依赖注入的使用场景和它的缺陷。</p><p>到目前为止，我们已经学习了 Vue.js 3.0 提供的所有常用的 Composition API。可以看到和 Vue.js 2.x Options API 相比，我们不再是通过编写一些组件配置去描述一个组件，更像是主动调用一些 API 去编写组件的实现逻辑。</p><p>Vue.js 2.x 中，框架背后帮我们做了很多事情，比如我们在 data 中定义的变量，在组件实例化阶段会把它们变成响应式的，这个行为是黑盒的，用户是无感知的。反观 Vue.js 3.0 Composition API，用户会利用 reactive 或者 ref API 主动去申明一个响应式对象。</p><p>所以<strong>通过 Composition API 去编写组件</strong>，<strong>用户更清楚自己在做什么事情</strong>。</p><p>另外，为什么说 Composition API 比 mixin 更适合逻辑复用呢？</p><p>其实，二者都是把复用的逻辑放在单独的文件中维护。但从使用的方式而言，用户只是在需要混入 mixin 的组件中去申明这个 mixin，使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div&gt; </span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125; </span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">import mousePositionMixin from &#x27;./mouse&#x27; </span><br><span class="line">export default &#123; </span><br><span class="line">  mixins: [mousePositionMixin] </span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们在组件中申明了 mousePositionMixin，组件模板中使用的 x、y 就来源于这个 mixin，这一切都是 Vue.js 内部帮我们做的。如果该组件只引入这单个 mixin，问题倒不大，但如果这个组件引入的 mixin 越来越多，很容易出现命名冲突的情况，以及造成数据来源不清晰等问题。</p><p>而我们通过 Composition API 去编写功能类似的 hook 函数，使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div&gt; </span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125; </span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">  import useMousePosition from &#x27;./mouse&#x27; </span><br><span class="line">  export default &#123; </span><br><span class="line">    setup() &#123; </span><br><span class="line">      const &#123; x, y &#125; = useMousePosition() </span><br><span class="line">      return &#123; x, y &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们可以清楚地分辨出模板中使用的 x、y 是来源于 useMousePosition 函数，即便我们引入更多的 hook 函数，也不会出现命名冲突的情况。</p><p>Composition API 在逻辑复用上确实有不错的优势，但是它并非完美的，使用起来会增加代码量。Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，还是可以使用 Options API 的。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-core&#x2F;src&#x2F;apiInject.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue.js 为我们提供了很多组件通讯的方式，常见的是父子组件通过 props 传递数据。但是有时，我们希望能&lt;strong&gt;跨父子组件通讯&lt;/strong&gt;，比如，无论组件之间嵌套多少层级，我都希望在后代组件中能访问它们祖先组件的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="provide" scheme="https://xiaozhouguo.github.io/tags/provide/"/>
    
  </entry>
  
  <entry>
    <title>生命周期：各个生命周期的执行时机和应用场景是怎么样的？</title>
    <link href="https://xiaozhouguo.github.io/2022/07/07/vue3/life-cycle/"/>
    <id>https://xiaozhouguo.github.io/2022/07/07/vue3/life-cycle/</id>
    <published>2022-07-07T08:44:51.000Z</published>
    <updated>2022-07-14T03:37:18.722Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 组件的生命周期包括创建、更新、销毁等过程。在这些过程中也会运行叫生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Vue.js 2.x 中，我们通常会在组件对象中定义一些生命周期钩子函数，到了 Vue.js 3.0，依然兼容 Vue.js 2.x 生命周期的语法，但是 Composition API 提供了一些生命周期函数的 API，让我们可以主动注册不同的生命周期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.js 2.x 定义生命周期钩子函数 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 做一些初始化工作 </span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 可以拿到 DOM 节点 </span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 做一些清理操作 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Vue.js 3.x 生命周期 API 改写上例 </span></span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, onBeforeUnmount &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="comment">// 做一些初始化工作 </span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="comment">// 可以拿到 DOM 节点 </span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="title function_">onBeforeUnmount</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">      <span class="comment">// 做一些清理操作 </span></span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 Vue.js 3.0 中，setup 函数已经替代了 Vue.js 2.x 的 <code>beforeCreate</code> 和 <code>created</code> 钩子函数，我们可以在 setup 函数做一些初始化工作，比如发送一个异步 Ajax 请求获取数据。</p><p>我们用 onMounted API 替代了 Vue.js 2.x 的 mounted 钩子函数，用 onBeforeUnmount API 替代了 Vue.js 2.x 的 beforeDestroy 钩子函数。</p><p>其实，Vue.js 3.0 针对 Vue.js 2.x 的生命周期钩子函数做了全面替换，映射关系如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate -&gt; 使用 <span class="title function_">setup</span>() </span><br><span class="line">created -&gt; 使用 use <span class="title function_">setup</span>() </span><br><span class="line">beforeMount -&gt; onBeforeMount </span><br><span class="line">mounted -&gt; onMounted </span><br><span class="line">beforeUpdate -&gt; onBeforeUpdate </span><br><span class="line">updated -&gt; onUpdated </span><br><span class="line">beforeDestroy-&gt; onBeforeUnmount </span><br><span class="line">destroyed -&gt; onUnmounted </span><br><span class="line">activated -&gt; onActivated </span><br><span class="line">deactivated -&gt; onDeactivated </span><br><span class="line">errorCaptured -&gt; onErrorCaptured</span><br></pre></td></tr></table></figure><p>除此之外，Vue.js 3.0 还新增了两个用于调试的生命周期 API：onRenderTracked 和 onRenderTriggered。</p><p>那么，这些生命周期钩子函数内部是如何实现的？它们又分别在组件生命周期的哪些阶段执行的？分别适用于哪些开发场景？</p><p>带着这些疑问，我们来深入学习生命周期钩子函数背后的实现原理。</p><h3 id="注册钩子函数"><a href="#注册钩子函数" class="headerlink" title="注册钩子函数"></a>注册钩子函数</h3><p>首先，我们来看这些钩子函数是如何注册的，先来看一下它们的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onBeforeMount = <span class="title function_">createHook</span>(<span class="string">&#x27;bm&#x27;</span> <span class="comment">/* BEFORE_MOUNT */</span>) </span><br><span class="line"><span class="keyword">const</span> onMounted = <span class="title function_">createHook</span>(<span class="string">&#x27;m&#x27;</span> <span class="comment">/* MOUNTED */</span>) </span><br><span class="line"><span class="keyword">const</span> onBeforeUpdate = <span class="title function_">createHook</span>(<span class="string">&#x27;bu&#x27;</span> <span class="comment">/* BEFORE_UPDATE */</span>) </span><br><span class="line"><span class="keyword">const</span> onUpdated = <span class="title function_">createHook</span>(<span class="string">&#x27;u&#x27;</span> <span class="comment">/* UPDATED */</span>) </span><br><span class="line"><span class="keyword">const</span> onBeforeUnmount = <span class="title function_">createHook</span>(<span class="string">&#x27;bum&#x27;</span> <span class="comment">/* BEFORE_UNMOUNT */</span>) </span><br><span class="line"><span class="keyword">const</span> onUnmounted = <span class="title function_">createHook</span>(<span class="string">&#x27;um&#x27;</span> <span class="comment">/* UNMOUNTED */</span>) </span><br><span class="line"><span class="keyword">const</span> onRenderTriggered = <span class="title function_">createHook</span>(<span class="string">&#x27;rtg&#x27;</span> <span class="comment">/* RENDER_TRIGGERED */</span>) </span><br><span class="line"><span class="keyword">const</span> onRenderTracked = <span class="title function_">createHook</span>(<span class="string">&#x27;rtc&#x27;</span> <span class="comment">/* RENDER_TRACKED */</span>) </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onErrorCaptured</span> = (<span class="params">hook, target = currentInstance</span>) =&gt; &#123; </span><br><span class="line">  <span class="title function_">injectHook</span>(<span class="string">&#x27;ec&#x27;</span> <span class="comment">/* ERROR_CAPTURED */</span>, hook, target) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现除了 onErrorCaptured，其他钩子函数都是通过 <code>createHook</code> 函数创建的，通过传入不同的字符串来表示不同的钩子函数。</p><p>那么，我们就来分析一下 createHook 钩子函数的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createHook = <span class="keyword">function</span>(<span class="params">lifecycle</span>)  &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">hook, target = currentInstance</span>) &#123; </span><br><span class="line">    <span class="title function_">injectHook</span>(lifecycle, hook, target) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createHook 会返回一个函数，它的内部通过 injectHook 注册钩子函数。你可能会问，这里为什么要用 createHook 做一层封装而不直接使用 injectHook API 呢？比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onBeforeMount = <span class="keyword">function</span>(<span class="params">hook,target = currentInstance</span>) &#123; </span><br><span class="line">  <span class="title function_">injectHook</span>(<span class="string">&#x27;bm&#x27;</span>, hook, target) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> onMounted = <span class="keyword">function</span>(<span class="params">hook,target = currentInstance</span>) &#123; </span><br><span class="line">  <span class="title function_">injectHook</span>(<span class="string">&#x27;m&#x27;</span>, hook, target) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现当然也是可以的，不过，我们可以发现，这些钩子函数内部执行逻辑很类似，都是执行 injectHook，唯一的区别是第一个参数字符串不同，所以这样的代码是可以进一步封装的，即用 createHook 封装，这就是一个典型的函数柯里化技巧。</p><p>在调用 createHook 返回的函数时，也就不需要传入 lifecycle 字符串，因为它在执行 createHook 函数时就已经实现了该参数的保留。</p><p>所以，当我们通过 <code>onMounted(hook)</code> 注册一个钩子函数时，内部就是通过 <code>injectHook(&#39;m&#39;, hook)</code> 去注册的，接下来我们来进一步看 injectHook 函数的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">injectHook</span>(<span class="params">type, hook, target = currentInstance, prepend = <span class="literal">false</span></span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> hooks = target[type] || (target[type] = []) </span><br><span class="line">  <span class="comment">// 封装 hook 钩子函数并缓存 </span></span><br><span class="line">  <span class="keyword">const</span> wrappedHook = hook.<span class="property">__weh</span> || </span><br><span class="line">    (hook.<span class="property">__weh</span> = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (target.<span class="property">isUnmounted</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 停止依赖收集 </span></span><br><span class="line">      <span class="title function_">pauseTracking</span>() </span><br><span class="line">      <span class="comment">// 设置 target 为当前运行的组件实例 </span></span><br><span class="line">      <span class="title function_">setCurrentInstance</span>(target) </span><br><span class="line">      <span class="comment">// 执行钩子函数 </span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="title function_">callWithAsyncErrorHandling</span>(hook, target, type, args) </span><br><span class="line">      <span class="title function_">setCurrentInstance</span>(<span class="literal">null</span>) </span><br><span class="line">      <span class="comment">// 恢复依赖收集 </span></span><br><span class="line">      <span class="title function_">resetTracking</span>() </span><br><span class="line">      <span class="keyword">return</span> res </span><br><span class="line">    &#125;) </span><br><span class="line">  <span class="keyword">if</span> (prepend) &#123; </span><br><span class="line">    hooks.<span class="title function_">unshift</span>(wrappedHook) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    hooks.<span class="title function_">push</span>(wrappedHook) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合代码来看，该函数主要是对用户注册的钩子函数 hook 做了一层封装，然后添加到一个数组中，把数组保存在当前组件实例的 target 上，这里，key 是用来区分钩子函数的字符串。比如， onMounted 注册的钩子函数在组件实例上就是通过 instance.m 来保存。</p><p>这样的设计其实非常好理解，因为生命周期的钩子函数，是在组件生命周期的各个阶段执行，所以钩子函数必须要保存在当前的组件实例上，这样后面就可以在组件实例上通过不同的字符串 key 找到对应的钩子函数数组并执行。</p><p>对于相同的钩子函数，会把封装的 wrappedHook 钩子函数缓存到 hook.__weh 中，这样后续通过 scheduler 方式执行的钩子函数就会被去重。</p><p>在后续执行 wrappedHook 函数时，会先停止依赖收集，因为钩子函数内部访问的响应式对象，通常都已经执行过依赖收集，所以钩子函数执行的时候没有必要再次收集依赖，毕竟这个过程也有一定的性能消耗。</p><p>接着是设置 target 为当前组件实例。在 Vue.js 的内部，会一直维护当前运行的组件实例 currentInstance，在注册钩子函数的过程中，我们可以拿到当前运行组件实例 currentInstance，并用 target 保存，然后在钩子函数执行时，为了确保此时的 currentInstance 和注册钩子函数时一致，会通过 <code>setCurrentInstance(target)</code> 设置 target 为当前组件实例。</p><p>接下来就是通过 callWithAsyncErrorHandling 方法去执行我们注册的 hook 钩子函数，函数执行完毕则设置当前运行组件实例为 null，并恢复依赖收集。</p><p>到这里，我们就了解了生命周期钩子函数是如何注册以及如何执行的，接下来，我们来依次分析各个钩子函数的执行时机和应用场景。</p><p>首先，我们来看通过 onBeforeMount 和 onMounted 注册的钩子函数。</p><h3 id="onBeforeMount-和-onMounted"><a href="#onBeforeMount-和-onMounted" class="headerlink" title="onBeforeMount 和 onMounted"></a>onBeforeMount 和 onMounted</h3><p><strong>onBeforeMount 注册的 beforeMount 钩子函数会在组件挂载之前执行</strong>，<strong>onMounted 注册的 mounted 钩子函数会在组件挂载之后执行</strong>。我们来回顾一下组件副作用渲染函数关于组件挂载部分的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setupRenderEffect</span> = (<span class="params">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123; </span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数 </span></span><br><span class="line">  instance.<span class="property">update</span> = <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">componentEffect</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123; </span><br><span class="line">      <span class="comment">// 获取组件实例上通过 onBeforeMount 钩子函数和 onMounted 注册的钩子函数 </span></span><br><span class="line">      <span class="keyword">const</span> &#123; bm, m &#125; = instance; </span><br><span class="line">      <span class="comment">// 渲染组件生成子树 vnode </span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.<span class="property">subTree</span> = <span class="title function_">renderComponentRoot</span>(instance)) </span><br><span class="line">      <span class="comment">// 执行 beforemount 钩子函数 </span></span><br><span class="line">      <span class="keyword">if</span> (bm) &#123; </span><br><span class="line">        <span class="title function_">invokeArrayFns</span>(bm) </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 把子树 vnode 挂载到 container 中 </span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, subTree, container, anchor, instance, parentSuspense, isSVG) </span><br><span class="line">      <span class="comment">// 保留渲染生成的子树根 DOM 节点 </span></span><br><span class="line">      initialVNode.<span class="property">el</span> = subTree.<span class="property">el</span> </span><br><span class="line">      <span class="comment">// 执行 mounted 钩子函数 </span></span><br><span class="line">      <span class="keyword">if</span> (m) &#123; </span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(m, parentSuspense) </span><br><span class="line">      &#125; </span><br><span class="line">      instance.<span class="property">isMounted</span> = <span class="literal">true</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 更新组件 </span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, prodEffectOptions) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 patch 挂载组件之前，会检测组件实例上是有否有注册的 beforeMount 钩子函数 bm，如果有则通过 invokeArrayFns 执行它，因为用户可以通过多次执行 onBeforeMount 函数注册多个 beforeMount 钩子函数，所以这里 instance.bm 是一个数组，通过遍历这个数组来依次执行 beforeMount 钩子函数。</p><p>在执行 patch 挂载组件之后，会检查组件实例上是否有注册的 mounted 钩子函数 m，如果有的话则执行 queuePostRenderEffect，把 mounted 钩子函数推入 postFlushCbs 中，然后在整个应用 render 完毕后，同步执行 flushPostFlushCbs 函数调用 mounted 钩子函数。</p><p>我经常在社区里听到一种争论：在组件初始化阶段，对于发送一些 Ajax 异步请求的逻辑，是应该放在 created 钩子函数中，还是应该放在 mounted 钩子函数中？</p><p>其实都可以，因为 created 和 mounted 钩子函数执行的时候都能拿到组件数据，它们执行的顺序虽然有先后，但都会在一个 Tick 内执行完毕，而异步请求是有网络耗时的，其耗时远远大于一个 Tick 的时间。所以，你无论在 created 还是在 mounted 里发请求，都要等请求的响应回来，然后更新数据，再触发组件的重新渲染。</p><p>前面说过，Vue.js 2.x 中的 beforeCreate 和 created 钩子函数可以用 setup 函数替代。所以，对于组件初始化阶段发送异步请求的逻辑，放在 setup 函数中、beforeMount 钩子函数中或者 mounted 钩子函数中都可以，它们都可以拿到组件相关的数据。当然，我更推荐在 setup 函数中执行，因为从语义化的角度来看这样更合适。</p><p>不过，如果你想依赖 DOM 去做一些初始化操作，那就只能把相关逻辑放在 mounted 钩子函数中了，这样你才能拿到组件渲染后的 DOM。</p><p>对于嵌套组件，组件在挂载相关的生命周期钩子函数时，先执行父组件的 beforeMount，然后是子组件的 beforeMount，接着是子组件的 mounted ，最后执行父组件的 mounted。</p><p>接下来，我们来看通过 onBeforeUpdate 和 onUpdated 注册的钩子函数。</p><h3 id="onBeforeUpdate-和-onUpdated"><a href="#onBeforeUpdate-和-onUpdated" class="headerlink" title="onBeforeUpdate 和 onUpdated"></a>onBeforeUpdate 和 onUpdated</h3><p><strong>onBeforeUpdate 注册的 beforeUpdate 钩子函数会在组件更新之前执行</strong>，<strong>onUpdated 注册的 updated 钩子函数会在组件更新之后执行</strong>。我们来回顾一下组件副作用渲染函数关于组件更新的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setupRenderEffect</span> = (<span class="params">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123; </span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数 </span></span><br><span class="line">  instance.<span class="property">update</span> = <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">componentEffect</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123; </span><br><span class="line">      <span class="comment">// 渲染组件 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 更新组件 </span></span><br><span class="line">      <span class="comment">// 获取组件实例上通过 onBeforeUpdate 钩子函数和 onUpdated 注册的钩子函数 </span></span><br><span class="line">      <span class="keyword">let</span> &#123; next, vnode, bu, u &#125; = instance </span><br><span class="line">      <span class="comment">// next 表示新的组件 vnode </span></span><br><span class="line">      <span class="keyword">if</span> (next) &#123; </span><br><span class="line">        <span class="comment">// 更新组件 vnode 节点信息 </span></span><br><span class="line">        <span class="title function_">updateComponentPreRender</span>(instance, next, optimized) </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123; </span><br><span class="line">        next = vnode </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 渲染新的子树 vnode </span></span><br><span class="line">      <span class="keyword">const</span> nextTree = <span class="title function_">renderComponentRoot</span>(instance) </span><br><span class="line">      <span class="comment">// 缓存旧的子树 vnode </span></span><br><span class="line">      <span class="keyword">const</span> prevTree = instance.<span class="property">subTree</span> </span><br><span class="line">      <span class="comment">// 更新子树 vnode </span></span><br><span class="line">      instance.<span class="property">subTree</span> = nextTree </span><br><span class="line">      <span class="comment">// 执行 beforeUpdate 钩子函数 </span></span><br><span class="line">      <span class="keyword">if</span> (bu) &#123; </span><br><span class="line">        <span class="title function_">invokeArrayFns</span>(bu) </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 组件更新核心逻辑，根据新旧子树 vnode 做 patch </span></span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        prevTree, nextTree, </span><br><span class="line"> <span class="comment">// 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点 </span></span><br><span class="line">        <span class="title function_">hostParentNode</span>(prevTree.<span class="property">el</span>), </span><br><span class="line">   <span class="comment">// 缓存更新后的 DOM 节点 </span></span><br><span class="line">        <span class="title function_">getNextHostNode</span>(prevTree), </span><br><span class="line">        instance, </span><br><span class="line">        parentSuspense, </span><br><span class="line">        isSVG) </span><br><span class="line">      <span class="comment">// 缓存更新后的 DOM 节点 </span></span><br><span class="line">      next.<span class="property">el</span> = nextTree.<span class="property">el</span> </span><br><span class="line">      <span class="comment">// 执行 updated 钩子函数 </span></span><br><span class="line">      <span class="keyword">if</span> (u) &#123; </span><br><span class="line">        <span class="title function_">queuePostRenderEffect</span>(u, parentSuspense) </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, prodEffectOptions) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 patch 更新组件之前，会检测组件实例上是有否有注册的 beforeUpdate 钩子函数 bu，如果有则通过 invokeArrayFns 执行它。</p><p>在执行 patch 更新组件之后，会检查组件实例上是否有注册的 updated 钩子函数 u，如果有，则通过 queuePostRenderEffect 把 updated 钩子函数推入 postFlushCbs 中，因为组件的更新本身就是在 nextTick 后进行 flushJobs，因此此时再次执行 queuePostRenderEffect 推入到队列的任务，会在同一个 Tick 内执行这些 postFlushCbs，也就是执行所有 updated 的钩子函数。</p><p>在 beforeUpdate 钩子函数执行时，组件的 DOM 还未更新，如果你想在组件更新前访问 DOM，比如手动移除已添加的事件监听器，你可以注册这个钩子函数。</p><p>在 updated 钩子函数执行时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。如果要监听数据的改变并执行某些逻辑，最好不要使用 updated 钩子函数而用计算属性或 watcher 取而代之，因为任何数据的变化导致的组件更新都会执行 updated 钩子函数。另外注意， <strong>不要在 updated 钩子函数中更改数据，因为这样会再次触发组件更新，导致无限递归更新</strong> 。</p><p>还有，父组件的更新不一定会导致子组件的更新，因为 Vue.js 的更新粒度是组件级别的。</p><p>接下来，我们来看通过 onBeforeUnmount 和 onUnmounted 注册的钩子函数。</p><h3 id="onBeforeUnmount-和-onUnmounted"><a href="#onBeforeUnmount-和-onUnmounted" class="headerlink" title="onBeforeUnmount 和 onUnmounted"></a>onBeforeUnmount 和 onUnmounted</h3><p><strong>onBeforeUnmount 注册的 beforeUnMount 钩子函数会在组件销毁之前执行</strong>，onUnmounted <strong>注册的 unmounted 钩子函数会在组件销毁之后执行</strong> 。我们来看一下组件销毁相关逻辑实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">unmountComponent</span> <span class="operator">=</span> (instance, parentSuspense, doRemove) =&gt; &#123; </span><br><span class="line">  const &#123; bum, effects, update, subTree, um &#125; = instance </span><br><span class="line">  <span class="comment">// 执行 beforeUnmount 钩子函数 </span></span><br><span class="line">  <span class="keyword">if</span> (bum) &#123; </span><br><span class="line">    invokeArrayFns(bum) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 清理组件引用的 effects 副作用函数 </span></span><br><span class="line">  <span class="keyword">if</span> (effects) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; effects.length; i++) &#123; </span><br><span class="line">      stop(effects[i]) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 如果一个异步组件在加载前就销毁了，则不会注册副作用渲染函数 </span></span><br><span class="line">  <span class="keyword">if</span> (update) &#123; </span><br><span class="line">    stop(update) </span><br><span class="line">    <span class="comment">// 调用 unmount 销毁子树 </span></span><br><span class="line">    unmount(subTree, instance, parentSuspense, doRemove) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 执行 unmounted 钩子函数 </span></span><br><span class="line">  <span class="keyword">if</span> (um) &#123; </span><br><span class="line">    queuePostRenderEffect(um, parentSuspense) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实整个组件销毁的逻辑很简单，主要就是<strong>清理组件实例上绑定的 effects 副作用函数和注册的副作用渲染函数 update</strong>，以及<strong>调用 unmount 销毁子树</strong></p><p>unmount 主要就是遍历子树，它会通过递归的方式来销毁子节点，遇到组件节点时执行 unmountComponent，遇到普通节点时则删除 DOM 元素。组件的销毁过程和渲染过程类似，都是递归的过程。</p><p>在组件销毁前，会检测组件实例上是有否有注册的 beforeUnmount 钩子函数 bum，如果有则通过 invokeArrayFns 执行。</p><p>在组件销毁后，会检测组件实例上是否有注册的 unmounted 钩子函数 um，如果有则通过 queuePostRenderEffect 把 unmounted 钩子函数推入到 postFlushCbs 中，因为组件的销毁就是组件更新的一个分支逻辑，所以在 nextTick 后进行 flushJobs，因此此时再次执行 queuePostRenderEffect 推入队列的任务，会在同一个 Tick 内执行这些 postFlushCbs，也就是执行所有的 unmounted 钩子函数。</p><p>对于嵌套组件，组件在执行销毁相关的生命周期钩子函数时，先执行父组件的 beforeUnmount，再执行子组件的 beforeUnmount，然后执行子组件的 unmounted ，最后执行父组件的 unmounted。</p><p>虽然组件在销毁阶段会清理一些定义的 effects 函数，删除组件内部的 DOM 元素，但是有一些需要清理的对象，组件并不能自动完成它们的清理，比如你在组件内部创建一个定时器，就应该在 beforeUnmount 或者 unmounted 钩子函数中清除，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref, onBeforeUnmount &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span><br><span class="line"><span class="language-javascript">    setup () &#123; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>++) </span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">1000</span>) </span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">clearInterval</span>(timer) </span></span><br><span class="line"><span class="language-javascript">      &#125;) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        count </span></span><br><span class="line"><span class="language-javascript">      &#125; </span></span><br><span class="line"><span class="language-javascript">    &#125; </span></span><br><span class="line"><span class="language-javascript">  &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这里我们在 setup 函数内部定义了一个 timer 计时器， count 每秒会加 1 并在控制台中输出。如果这个组件被销毁，就会触发 onBeforeUnmount 注册的 beforeUnmount 钩子函数，然后清除定时器。如果你不清除，就会发现组件销毁后，虽然 DOM 被移除了，计时器仍然存在，并且会一直计时并在控制台输出，这就造成了不必要的内存泄漏。</p><p>接下来，我们来看通过 onErrorCaptured 注册的钩子函数</p><h3 id="onErrorCaptured"><a href="#onErrorCaptured" class="headerlink" title="onErrorCaptured"></a>onErrorCaptured</h3><p>在前面的课时中，我们多次接触过一个方法 callWithErrorHandling，它就是执行一段函数并通过 handleError 处理错误。那么，handleError 具体做了哪些事情呢？</p><p>我们先来看一下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleError</span>(<span class="params">err, instance, type</span>) &#123; </span><br><span class="line">  <span class="keyword">const</span> contextVNode = instance ? instance.<span class="property">vnode</span> : <span class="literal">null</span> </span><br><span class="line">  <span class="keyword">if</span> (instance) &#123; </span><br><span class="line">    <span class="keyword">let</span> cur = instance.<span class="property">parent</span> </span><br><span class="line">    <span class="comment">// 为了兼容 2.x 版本，暴露组件实例给钩子函数 </span></span><br><span class="line">    <span class="keyword">const</span> exposedInstance = instance.<span class="property">proxy</span> </span><br><span class="line">    <span class="comment">// 获取错误信息 </span></span><br><span class="line">    <span class="keyword">const</span> errorInfo = (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) ? <span class="title class_">ErrorTypeStrings</span>[type] : type </span><br><span class="line">    <span class="comment">// 尝试向上查找所有父组件，执行 errorCaptured 钩子函数 </span></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123; </span><br><span class="line">      <span class="keyword">const</span> errorCapturedHooks = cur.<span class="property">ec</span> </span><br><span class="line">      <span class="keyword">if</span> (errorCapturedHooks) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; errorCapturedHooks.<span class="property">length</span>; i++) &#123; </span><br><span class="line">          <span class="comment">// 如果执行的 errorCaptured 钩子函数并返回 true，则停止向上查找。、 </span></span><br><span class="line">          <span class="keyword">if</span> (errorCapturedHooks[i](err, exposedInstance, errorInfo)) &#123; </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">      cur = cur.<span class="property">parent</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 往控制台输出未处理的错误 </span></span><br><span class="line">  <span class="title function_">logError</span>(err, type, contextVNode) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleError 的实现其实很简单，它会从当前报错的组件的父组件实例开始，尝试去查找注册的 errorCaptured 钩子函数，如果有则遍历执行并且判断 errorCaptured 钩子函数的返回值是否为 true，如果是则说明这个错误已经得到了正确的处理，就会直接结束。</p><p>否则会继续遍历，遍历完当前组件实例的 errorCaptured 钩子函数后，如果这个错误还没得到正确处理，则向上查找它的父组件实例，以同样的逻辑去查找是否有正确处理该错误的 errorCaptured 钩子函数，直到查找完毕。</p><p>如果整个链路上都没有正确处理错误的 errorCaptured 钩子函数，则通过 logError 往控制台输出未处理的错误。所以 <strong>errorCaptured 本质上是捕获一个来自子孙组件的错误</strong>，<strong>它返回 true 就可以阻止错误继续向上传播</strong>。</p><p>errorCaptured 在平时工作中可能用的不多，但它的确是一个很实用的功能，比如你可以在根组件注册一个 errorCaptured 钩子函数，去捕获所有子孙组件的错误，并且可以根据错误的类型和信息统计和上报错误。</p><p>接下来，我们来看通过 onRenderTracked 和 onRenderTriggered 注册的钩子函数。</p><h3 id="onRenderTracked-和-onRenderTriggered"><a href="#onRenderTracked-和-onRenderTriggered" class="headerlink" title="onRenderTracked 和 onRenderTriggered"></a>onRenderTracked 和 onRenderTriggered</h3><p>onRenderTracked 和 onRenderTriggered 是 Vue.js 3.0 新增的生命周期 API，它们是在开发阶段渲染调试用的。这里再次回顾一下我们创建的副作用渲染函数的第二个参数（这里你可以去 响应式内部的实现原理是怎样的？ ”中复习一下），在开发环境下它的代码是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">instance.<span class="property">update</span> = <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">componentEffect</span>(<span class="params"></span>) &#123; </span><br><span class="line"><span class="comment">// 创建或者更组件 </span></span><br><span class="line">&#125;, <span class="title function_">createDevEffectOptions</span>(instance)) </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createDevEffectOptions</span>(<span class="params">instance</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">scheduler</span>: queueJob, </span><br><span class="line">    <span class="attr">onTrack</span>: instance.<span class="property">rtc</span> ? <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtc</span>, e) : <span class="keyword">void</span> <span class="number">0</span>, </span><br><span class="line">    <span class="attr">onTrigger</span>: instance.<span class="property">rtg</span> ? <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">invokeArrayFns</span>(instance.<span class="property">rtg</span>, e) : <span class="keyword">void</span> <span class="number">0</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码我们发现，onRenderTracked 和 onRenderTriggered 注册的钩子函数，原来是在副作用渲染函数的 onTrack 和 onTrigger 对应的函数中执行的。</p><p>我们当时介绍 effect 副作用函数的配置时并没有介绍这两个属性，那么它们是做什么用的呢？</p><p>这就要先来看 onTrack 函数的执行时机。我们知道当访问一个响应式对象时，会执行 track 函数做依赖收集，我们来回顾一下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, type, key</span>) &#123; </span><br><span class="line">  <span class="comment">// 执行一些依赖收集的操作 </span></span><br><span class="line">  <span class="keyword">if</span> (!dep.<span class="title function_">has</span>(activeEffect)) &#123;</span><br><span class="line">     dep.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">     activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">     <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; activeEffect.<span class="property">options</span>.<span class="property">onTrack</span>) &#123;</span><br><span class="line">       <span class="comment">// 执行 onTrack 函数 </span></span><br><span class="line">       activeEffect.<span class="property">options</span>.<span class="title function_">onTrack</span>(&#123;</span><br><span class="line">          <span class="attr">effect</span>: activeEffect,</span><br><span class="line">          target,</span><br><span class="line">          type,</span><br><span class="line">          key</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，track 函数先执行依赖收集，然后在非生产环境下检测当前的 activeEffect 的配置有没有定义 onTrack 函数，如果有的则执行该方法。</p><p>因此对应到副作用渲染函数，当它执行的时候，activeEffect 就是这个副作用渲染函数，这时访问响应式数据就会触发 track 函数，<strong>在执行完依赖收集后</strong>，<strong>会执行 onTrack 函数</strong>，<strong>也就是遍历执行我们注册的 renderTracked 钩子函数</strong>。</p><p>接下来，我们再来回顾一下 trigger 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span> (target, type, key, newValue) &#123; </span><br><span class="line">  <span class="comment">// 添加要运行的 effects 集合 </span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect</span>) =&gt; &#123; </span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; effect.<span class="property">options</span>.<span class="property">onTrigger</span>) &#123; </span><br><span class="line">        <span class="comment">// 执行 onTrigger </span></span><br><span class="line">      effect.<span class="property">options</span>.<span class="title function_">onTrigger</span>(&#123; </span><br><span class="line">        effect, </span><br><span class="line">        target, </span><br><span class="line">        key, </span><br><span class="line">        type, </span><br><span class="line">        newValue, </span><br><span class="line">        oldValue, </span><br><span class="line">        oldTarget </span><br><span class="line">      &#125;) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123; </span><br><span class="line">      effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="title function_">effect</span>() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 遍历执行 effects </span></span><br><span class="line">  effects.<span class="title function_">forEach</span>(run) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，trigger 函数首先要创建运行的 effects 集合，然后遍历执行，在执行的过程中，会在非生产环境下检测待执行的 effect 配置中有没有定义 onTrigger 函数，如果有则执行该方法。</p><p>因此对应到我们的副作用渲染函数，当它内部依赖的响应式对象值被修改后，就会触发 trigger 函数 ，这个时候副作用渲染函数就会被添加到要运行的 effects 集合中，<strong>在遍历执行 effects 的时候会执行 onTrigger 函数</strong>，<strong>也就是遍历执行我们注册的 renderTriggered 钩子函数</strong>。</p><p>了解完 renderTracked 和 renderTriggered 钩子函数的执行时机后，我们来看一下实际场景的应用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increase&quot;</span>&gt;</span>Increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref, onRenderTracked, onRenderTriggered &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span><br><span class="line"><span class="language-javascript">    setup () &#123; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">increase</span> () &#123; </span></span><br><span class="line"><span class="language-javascript">        count.<span class="property">value</span>++ </span></span><br><span class="line"><span class="language-javascript">      &#125; </span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">onRenderTracked</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e) </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">debugger</span> </span></span><br><span class="line"><span class="language-javascript">      &#125;) </span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">onRenderTriggered</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e) </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">debugger</span> </span></span><br><span class="line"><span class="language-javascript">      &#125;) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        count, </span></span><br><span class="line"><span class="language-javascript">        increase </span></span><br><span class="line"><span class="language-javascript">      &#125; </span></span><br><span class="line"><span class="language-javascript">    &#125; </span></span><br><span class="line"><span class="language-javascript">  &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>像这样</strong>在开发阶段，我们可以通过注册这两个钩子函数，来追踪组件渲染的依赖来源以及触发组件重新渲染的数据更新来源。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的，到这里我们这一节的学习就结束啦，通过学习，你应该掌握 Vue.js 中生命周期注册的 API，了解各个生命周期的执行时机和应用场景。</p><p>最后，我们通过一张图再来直观地感受一下组件的各个生命周期：</p><img src="/2022/07/07/vue3/life-cycle/Ciqc1F8zkvmAR_QpAAJxUtKU_4s942.png" class=""><p>Vue.js 3.0 还有 2 个生命周期 API，分别是 onActivated 和 onDeactivated，我们将会在介绍 KeepAlive 组件时详细分析。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-core&#x2F;src&#x2F;apiLifecycle.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.ts<br>packages&#x2F;reactivity&#x2F;src&#x2F;effect.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue.js 组件的生命周期包括创建、更新、销毁等过程。在这些过程中也会运行叫生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="life-cycle" scheme="https://xiaozhouguo.github.io/tags/life-cycle/"/>
    
  </entry>
  
  <entry>
    <title>侦听器的实现原理和使用场景 - 上篇</title>
    <link href="https://xiaozhouguo.github.io/2022/07/05/vue3/watcher-one/"/>
    <id>https://xiaozhouguo.github.io/2022/07/05/vue3/watcher-one/</id>
    <published>2022-07-05T07:38:34.000Z</published>
    <updated>2022-07-05T09:00:58.040Z</updated>
    
    <content type="html"><![CDATA[<p>在平时的开发工作中，我们经常使用侦听器帮助我们去观察某个数据的变化然后去执行一段逻辑。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Vue.js 2.x 中，你可以通过 watch 选项去初始化一个侦听器，称作 watcher：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line">  <span class="attr">watch</span>: &#123; </span><br><span class="line">    <span class="title function_">a</span>(<span class="params">newVal, oldVal</span>) &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new: %s, old: %s&#x27;</span>, newVal, oldVal) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以通过 $watch API 去创建一个侦听器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new: %s, old: %s&#x27;</span>, newVal, oldVal) </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>与 watch 选项不同，通过 $watch API 创建的侦听器 watcher 会返回一个 unwatch 函数，你可以随时执行它来停止这个 watcher 对数据的侦听，而对于 watch 选项创建的侦听器，它会随着组件的销毁而停止对数据的侦听。</p><p>在 Vue.js 3.0 中，虽然你仍可以使用 watch 选项，但针对 Composition API，Vue.js 3.0 提供了 watch API 来实现侦听器的效果。</p><p>那么，接下来就随我一起来学习 watch API 吧。</p><h3 id="watch-API-的用法"><a href="#watch-API-的用法" class="headerlink" title="watch API 的用法"></a>watch API 的用法</h3><p>我们先来看 Vue.js 3.0 中 watch API 有哪些用法。</p><ol><li><p>watch API 可以<strong>侦听一个 getter 函数</strong>，但是它必须返回一个响应式对象，当该响应式对象更新后，会执行对应的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;) </span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">count</span>, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 当 state.count 更新，会触发此回调函数 </span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>watch API 也可以直接<strong>侦听一个响应式对象</strong>，当响应式对象更新后，会执行对应的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="title function_">watch</span>(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 当 count.value 更新，会触发此回调函数 </span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>watch API 还可以直接<strong>侦听多个响应式对象</strong>，任意一个响应式对象更新后，就会执行对应的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="keyword">const</span> count2 = <span class="title function_">ref</span>(<span class="number">1</span>) </span><br><span class="line"><span class="title function_">watch</span>([count, count2], <span class="function">(<span class="params">[count, count2], [prevCount, prevCount2]</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 当 count.value 或者 count2.value 更新，会触发此回调函数 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="watch-API-实现原理"><a href="#watch-API-实现原理" class="headerlink" title="watch API 实现原理"></a>watch API 实现原理</h3><p>侦听器的言下之意就是，当侦听的对象或者函数发生了变化则自动执行某个回调函数，这和我们前面说过的副作用函数 effect 很像， 那它的内部实现是不是依赖了 effect 呢？带着这个疑问，我们来探究 watch API 的具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; !<span class="title function_">isFunction</span>(cb)) &#123; </span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">`\`watch(fn, options?)\` signature has been moved to a separate API. `</span> + </span><br><span class="line">      <span class="string">`Use \`watchEffect(fn, options?)\` instead. \`watch\` now only `</span> + </span><br><span class="line">      <span class="string">`supports \`watch(source, cb, options?) signature.`</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doWatch</span>(source, cb, options) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWatch</span>(<span class="params">source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ</span>) &#123; </span><br><span class="line">  <span class="comment">// 标准化 source </span></span><br><span class="line">  <span class="comment">// 构造 applyCb 回调函数 </span></span><br><span class="line">  <span class="comment">// 创建 scheduler 时序执行函数 </span></span><br><span class="line">  <span class="comment">// 创建 effect 副作用函数 </span></span><br><span class="line">  <span class="comment">// 返回侦听器销毁函数 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从代码中可以看到，watch 函数内部调用了 doWatch 函数，调用前会在非生产环境下判断第二个参数 cb 是不是一个函数，如果不是则会报警告以告诉用户应该使用 watchEffect(fn, options) API，<code>watchEffect</code> API 也是侦听器相关的 API，稍后我们会详细介绍。</p><p>这个 doWatch 函数很长，所以我只贴出了需要理解的部分，我用注释将这个函数的实现逻辑拆解成了几个步骤。可以看到，内部确实创建了 effect 副作用函数。接下来，就随我一步步看它具体做了哪些事情吧。</p><h4 id="标准化-source"><a href="#标准化-source" class="headerlink" title="标准化 source"></a>标准化 source</h4><p>我们先来看watch 函数的第一个参数 source。</p><p>通过前文知道 source 可以是 getter 函数，也可以是响应式对象甚至是响应式对象数组，所以我们需要标准化 source，这是<strong>标准化 source 的流程</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source 不合法的时候会报警告 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">warnInvalidSource</span> = (<span class="params">s</span>) =&gt; &#123; </span><br><span class="line">  <span class="title function_">warn</span>(<span class="string">`Invalid watch source: `</span>, s, <span class="string">`A watch source can only be a getter/effect function, a ref, `</span> + </span><br><span class="line">    <span class="string">`a reactive object, or an array of these types.`</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 当前组件实例 </span></span><br><span class="line"><span class="keyword">const</span> instance = currentInstance </span><br><span class="line"><span class="keyword">let</span> getter </span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isArray</span>(source)) &#123; </span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(s)) &#123; </span><br><span class="line">      <span class="keyword">return</span> s.<span class="property">value</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(s)) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">traverse</span>(s) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(s)) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callWithErrorHandling</span>(s, instance, <span class="number">2</span> <span class="comment">/* WATCH_GETTER */</span>) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; <span class="title function_">warnInvalidSource</span>(s) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isRef</span>(source)) &#123; </span><br><span class="line">  getter = <span class="function">() =&gt;</span> source.<span class="property">value</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isReactive</span>(source)) &#123; </span><br><span class="line">  getter = <span class="function">() =&gt;</span> source </span><br><span class="line">  deep = <span class="literal">true</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isFunction</span>(source)) &#123; </span><br><span class="line">  <span class="keyword">if</span> (cb) &#123; </span><br><span class="line">    <span class="comment">// getter with cb </span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">callWithErrorHandling</span>(source, instance, <span class="number">2</span> <span class="comment">/* WATCH_GETTER */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// watchEffect 的逻辑 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">  getter = <span class="variable constant_">NOOP</span> </span><br><span class="line">  (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; <span class="title function_">warnInvalidSource</span>(source) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (cb &amp;&amp; deep) &#123; </span><br><span class="line">  <span class="keyword">const</span> baseGetter = getter </span><br><span class="line">  getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(<span class="title function_">baseGetter</span>()) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，source 标准化主要是根据 source 的类型，将其变成 <del>标准成</del> getter 函数。具体来说：</p><ol><li>如果 source 是 ref 对象，则创建一个访问 source.value 的 getter 函数;</li><li>如果 source 是 reactive 对象，则创建一个访问 source 的 getter 函数，并设置 deep 为 true（deep 的作用我稍后会说）;</li><li>如果 source 是一个函数，则会进一步判断第二个参数 cb 是否存在，对于 watch API 来说，cb 是一定存在且是一个回调函数，这种情况下，getter 就是一个简单的对 source 函数封装的函数。</li></ol><p>如果 source 不满足上述条件，则在非生产环境下报警告，提示 source 类型不合法。</p><p>我们来看一下最终标准化生成的 getter 函数，它会返回一个响应式对象，在后续创建 effect runner 副作用函数需要用到，每次执行 runner 就会把 getter 函数返回的响应式对象作为 watcher 求值的结果，effect runner 的创建流程我们后续会详细分析，这里不需要深入了解。</p><p>最后我们来关注一下 deep 为 true 的情况。此时，我们会发现生成的 getter 函数会被 traverse 函数包装一层。traverse 函数的实现很简单，即通过递归的方式访问 value 的每一个子属性。那么，为什么要递归访问每一个子属性呢？</p><p>其实 deep 属于 watcher 的一个配置选项，Vue.js 2.x 也支持，表面含义是深度侦听，实际上是通过遍历对象的每一个子属性来实现。举个例子你就明白了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; </span><br><span class="line">  <span class="attr">count</span>: &#123; </span><br><span class="line">    <span class="attr">a</span>: &#123; </span><br><span class="line">      <span class="attr">b</span>: <span class="number">1</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br><span class="line"><span class="title function_">watch</span>(state.<span class="property">count</span>, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count) </span><br><span class="line">&#125;) </span><br><span class="line">state.<span class="property">count</span>.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span> </span><br></pre></td></tr></table></figure><p>这里，我们利用 reactive API 创建了一个嵌套层级较深的响应式对象 state，然后再调用 watch API 侦听 state.count 的变化。接下来我们修改内部属性 state.count.a.b 的值，你会发现 watcher 的回调函数执行了，为什么会执行呢？</p><p>学过响应式章节，我们知道只有对象属性先被访问触发了依赖收集，再去修改这个属性，才可以通知对应的依赖更新。而从上述业务代码来看，我们修改 state.count.a.b 的值时并没有访问它 ，但还是触发了 watcher 的回调函数。</p><p>根本原因是，当我们执行 watch 函数的时候，我们知道如果侦听的是一个 reactive 对象，那么内部会设置 deep 为 true，然后执行 traverse 去递归访问对象深层子属性，这个时候就会访问 state.count.a.b 触发依赖收集，这里收集的依赖是 watcher 内部创建的 effect runner。因此，当我们再去修改 state.count.a.b 的时候，就会通知这个 effect ，所以最终会执行 watcher 的回调函数。</p><p>当我们侦听一个通过 reactive API 创建的响应式对象时，内部会执行 traverse 函数，如果这个对象非常复杂，比如嵌套层级很深，那么递归 traverse 就会有一定的性能耗时。因此如果我们需要侦听这个复杂响应式对象内部的某个具体属性，就可以想办法减少 traverse 带来的性能损耗。</p><p>比如刚才的例子，我们就可以直接侦听 state.count.a.b 的变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(state.<span class="property">count</span>.<span class="property">a</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal) </span><br><span class="line">&#125;) </span><br><span class="line">state.<span class="property">count</span>.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span> </span><br></pre></td></tr></table></figure><p>这样就可以减少内部执行 traverse 的次数。你可能会问，直接侦听 state.count.a.b 可以吗？答案是不行，因为 state.count.a.b 已经是一个基础数字类型了，不符合 source 要求的参数类型，所以会在非生产环境下报警告。</p><p>那么有没有办法优化使得 traverse 不执行呢？答案是可以的。我们可以侦听一个 getter 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> state.<span class="property">count</span>.<span class="property">a</span>.<span class="property">b</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal) </span><br><span class="line">&#125;) </span><br><span class="line">state.<span class="property">count</span>.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span> </span><br></pre></td></tr></table></figure><p>这样函数内部会访问并返回 state.count.a.b，一次 traverse 都不会执行并且依然可以侦听到它的变化从而执行 watcher 的回调函数。</p><h4 id="构造回调函数"><a href="#构造回调函数" class="headerlink" title="构造回调函数"></a>构造回调函数</h4><p>处理完 watch API 第一个参数 source 后，接下来处理第二个参数 cb。</p><p>cb 是一个回调函数，它有三个参数：第一个 newValue 代表新值；第二个 oldValue 代表旧值。第三个参数 onInvalidate，我打算放在后面介绍。</p><p>其实这样的 API 设计非常好理解，即侦听一个值的变化，如果值变了就执行回调函数，回调函数里可以访问到新值和旧值。</p><p>接下来我们来看一下构造回调函数的处理逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ssssssslet cleanup </span><br><span class="line"><span class="comment">// 注册无效回调函数 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onInvalidate</span> = (<span class="params">fn</span>) =&gt; &#123; </span><br><span class="line">  cleanup = runner.<span class="property">options</span>.<span class="property">onStop</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="title function_">callWithErrorHandling</span>(fn, instance, <span class="number">4</span> <span class="comment">/* WATCH_CLEANUP */</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 旧值初始值 </span></span><br><span class="line"><span class="keyword">let</span> oldValue = <span class="title function_">isArray</span>(source) ? [] : <span class="variable constant_">INITIAL_WATCHER_VALUE</span> <span class="comment">/*&#123;&#125;*/</span> </span><br><span class="line"><span class="comment">// 回调函数 </span></span><br><span class="line"><span class="keyword">const</span> applyCb = cb </span><br><span class="line">  ? <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 组件销毁，则直接返回 </span></span><br><span class="line">    <span class="keyword">if</span> (instance &amp;&amp; instance.<span class="property">isUnmounted</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 求得新值 </span></span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="title function_">runner</span>() </span><br><span class="line">    <span class="keyword">if</span> (deep || <span class="title function_">hasChanged</span>(newValue, oldValue)) &#123; </span><br><span class="line">      <span class="comment">// 执行清理函数 </span></span><br><span class="line">      <span class="keyword">if</span> (cleanup) &#123; </span><br><span class="line">        <span class="title function_">cleanup</span>() </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="title function_">callWithAsyncErrorHandling</span>(cb, instance, <span class="number">3</span> <span class="comment">/* WATCH_CALLBACK */</span>, [ </span><br><span class="line">        newValue, </span><br><span class="line">        <span class="comment">// 第一次更改时传递旧值为 undefined </span></span><br><span class="line">        oldValue === <span class="variable constant_">INITIAL_WATCHER_VALUE</span> ? <span class="literal">undefined</span> : oldValue, </span><br><span class="line">        onInvalidate </span><br><span class="line">      ]) </span><br><span class="line">      <span class="comment">// 更新旧值 </span></span><br><span class="line">      oldValue = newValue </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  : <span class="keyword">void</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>onInvalidate 函数用来注册无效回调函数 ，我们暂时不需要关注它，我们需要重点来看 applyCb。 这个函数实际上就是对 cb 做一层封装，当侦听的值发生变化时就会执行 applyCb 方法，我们来分析一下它的实现。</p><p>首先，watch API 和组件实例相关，因为通常我们会在组件的 setup 函数中使用它，当组件销毁后，回调函数 cb 不应该被执行而是直接返回。</p><p>接着，执行 runner 求得新值，这里实际上就是执行前面创建的 getter 函数求新值。</p><p>最后进行判断，如果是 deep 的情况或者新旧值发生了变化，则执行回调函数 cb，传入参数 newValue 和 oldValue。注意，第一次执行的时候旧值的初始值是空数组或者 undefined。执行完回调函数 cb 后，把旧值 oldValue 再更新为 newValue，这是为了下一次的比对。</p><h4 id="创建-scheduler"><a href="#创建-scheduler" class="headerlink" title="创建 scheduler"></a>创建 scheduler</h4><p>接下来我们要分析创建 scheduler 过程。</p><p>scheduler 的作用是根据某种调度的方式去执行某种函数，在 watch API 中，主要影响到的是回调函数的执行方式。我们来看一下它的实现逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">invoke</span> <span class="operator">=</span> (fn) =&gt; fn() </span><br><span class="line">let scheduler </span><br><span class="line"><span class="title function_">if</span> <span class="params">(flush === <span class="string">&#x27;sync&#x27;</span>)</span> &#123; </span><br><span class="line">  <span class="comment">// 同步 </span></span><br><span class="line">  scheduler = invoke </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;pre&#x27;</span>) &#123; </span><br><span class="line">  scheduler = job =&gt; &#123; </span><br><span class="line">    <span class="keyword">if</span> (!instance || instance.isMounted) &#123; </span><br><span class="line">      <span class="comment">// 进入异步队列，组件更新前执行 </span></span><br><span class="line">      queueJob(job) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// 如果组件还没挂载，则同步执行确保在组件挂载前 </span></span><br><span class="line">      job() </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 进入异步队列，组件更新后执行 </span></span><br><span class="line">  scheduler = job =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Watch API 的参数除了 source 和 cb，还支持第三个参数 options，不同的配置决定了 watcher 的不同行为。前面我们也分析了 deep 为 true 的情况，除了 source 为 reactive 对象时会默认把 deep 设置为 true，你也可以主动传入第三个参数，把 deep 设置为 true。</p><p>这里，scheduler 的创建逻辑受到了第三个参数 Options 中的 flush 属性值的影响，不同的 flush 决定了 watcher 的执行时机。</p><ul><li>当 flush 为 sync 的时候，表示它是一个同步 watcher，即当数据变化时同步执行回调函数。</li><li>当 flush 为 pre 的时候，回调函数通过 queueJob 的方式在组件更新之前执行，如果组件还没挂载，则同步执行确保回调函数在组件挂载之前执行。</li><li>如果没设置 flush，那么回调函数通过 queuePostRenderEffect 的方式在组件更新之后执行。</li></ul><p>queueJob 和 queuePostRenderEffect 在这里不是重点，所以我们放到后面介绍。总之，你现在要记住，<strong>watcher 的回调函数是通过一定的调度方式执行的</strong>。</p><h4 id="创建-effect"><a href="#创建-effect" class="headerlink" title="创建 effect"></a>创建 effect</h4><p>前面的分析我们提到了 runner，它其实就是 watcher 内部创建的 effect 函数，接下来，我们来分析它逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> runner = <span class="title function_">effect</span>(getter, &#123; </span><br><span class="line">  <span class="comment">// 延时执行 </span></span><br><span class="line">  <span class="attr">lazy</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">// computed effect 可以优先于普通的 effect 先运行，比如组件渲染的 effect </span></span><br><span class="line">  <span class="attr">computed</span>: <span class="literal">true</span>, </span><br><span class="line">  onTrack, </span><br><span class="line">  onTrigger, </span><br><span class="line">  <span class="attr">scheduler</span>: applyCb ? <span class="function">() =&gt;</span> <span class="title function_">scheduler</span>(applyCb) : scheduler </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// 在组件实例中记录这个 effect </span></span><br><span class="line"><span class="title function_">recordInstanceBoundEffect</span>(runner) </span><br><span class="line"><span class="comment">// 初次执行 </span></span><br><span class="line"><span class="keyword">if</span> (applyCb) &#123; </span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123; </span><br><span class="line">    <span class="title function_">applyCb</span>() </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 求旧值 </span></span><br><span class="line">    oldValue = <span class="title function_">runner</span>() </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="comment">// 没有 cb 的情况 </span></span><br><span class="line">  <span class="title function_">runner</span>() </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这块代码逻辑是整个 watcher 实现的核心部分，即通过 effect API 创建一个副作用函数 runner，我们需要关注以下几点。</p><ul><li><strong>runner 是一个 computed effect</strong>。因为 computed effect 可以优先于普通的 effect（比如组件渲染的 effect）先运行，这样就可以实现当配置 flush 为 pre 的时候，watcher 的执行可以优先于组件更新。</li><li><strong>runner 执行的方式</strong>。runner 是 lazy 的，它不会在创建后立刻执行。第一次手动执行 runner 会执行前面的 getter 函数，访问响应式数据并做依赖收集。注意，此时activeEffect 就是 runner，这样在后面更新响应式数据时，就可以触发 runner 执行 scheduler 函数，以一种调度方式来执行回调函数。</li><li><strong>runner 的返回结果</strong>。手动执行 runner 就相当于执行了前面标准化的 getter 函数，getter 函数的返回值就是 watcher 计算出的值，所以我们第一次执行 runner 求得的值可以作为 oldValue。</li><li><strong>配置了 immediate 的情况</strong>。当我们配置了 immediate ，创建完 watcher 会立刻执行 applyCb 函数，此时 oldValue 还是初始值，在 applyCb 执行时也会执行 runner 进而执行前面的 getter 函数做依赖收集，求得新值。</li></ul><p>返回销毁函数</p><p>最后，会返回侦听器销毁函数，也就是 watch API 执行后返回的函数。我们可以通过调用它来停止 watcher 对数据的侦听。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="title function_">stop</span>(runner) </span><br><span class="line">  <span class="keyword">if</span> (instance) &#123; </span><br><span class="line">    <span class="comment">// 移除组件 effects 对这个 runner 的引用 </span></span><br><span class="line">    <span class="title function_">remove</span>(instance.<span class="property">effects</span>, runner) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stop</span>(<span class="params">effect</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (effect.<span class="property">active</span>) &#123; </span><br><span class="line">    <span class="title function_">cleanup</span>(effect) </span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">onStop</span>) &#123; </span><br><span class="line">      effect.<span class="property">options</span>.<span class="title function_">onStop</span>() </span><br><span class="line">    &#125; </span><br><span class="line">    effect.<span class="property">active</span> = <span class="literal">false</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁函数内部会执行 stop 方法让 runner 失活，并清理 runner 的相关依赖，这样就可以停止对数据的侦听。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。</p><p>好了，到这里我们对 watch API 的分析就可以告一段落了。侦听器的内部设计很巧妙，我们可以侦听响应式数据的变化，内部创建 effect runner，首次执行 runner 做依赖收集，然后在数据发生变化后，以某种调度方式去执行回调函数。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-core&#x2F;src&#x2F;apiWatch.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在平时的开发工作中，我们经常使用侦听器帮助我们去观察某个数据的变化然后去执行一段逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="watch" scheme="https://xiaozhouguo.github.io/tags/watch/"/>
    
  </entry>
  
  <entry>
    <title>计算属性：相比普通函数好在哪里？</title>
    <link href="https://xiaozhouguo.github.io/2022/07/04/vue3/computed/"/>
    <id>https://xiaozhouguo.github.io/2022/07/04/vue3/computed/</id>
    <published>2022-07-04T07:17:47.000Z</published>
    <updated>2022-07-04T07:54:50.380Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章，我们学习了响应式的实现原理，这次我们将学习一个非常常用的响应式 API——<strong>计算属性</strong>。</p><span id="more"></span><p>计算属性是 Vue.js 开发中一个非常实用的 API ，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。当依赖发生变化时，计算属性可以自动重新计算获取新值，所以使用起来非常方便。</p><p>在 Vue.js 2.x 中，相信你对计算属性的应用已经如数家珍了，我们可以在组件对象中定义 computed 属性。到了 Vue.js 3.0 ，虽然也可以在组件中沿用 Vue.js 2.x 的使用方式，但是我们也可以单独使用计算属性 API。</p><p>计算属性本质上还是对依赖的计算，那么为什么我们不直接用函数呢？在 Vue.js 3.0 中计算属性的 API 又是如何实现呢？接下来，就请你带着这些疑问，随我一起深入其实现原理的学习吧。</p><h3 id="计算属性-API：-computed"><a href="#计算属性-API：-computed" class="headerlink" title="计算属性 API： computed"></a>计算属性 API： computed</h3><p>Vue.js 3.0 提供了一个 computed 函数作为计算属性 API，我们先来看看它是如何使用的。</p><p>我们举个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span>) <span class="comment">// 2 </span></span><br><span class="line">plusOne.<span class="property">value</span>++ <span class="comment">// error </span></span><br><span class="line">count.<span class="property">value</span>++ </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>从代码中可以看到，我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne，它的值是 count.value + 1，当我们修改 count.value 的时候， plusOne.value 就会自动发生变化。</p><p>注意，这里我们直接修改 plusOne.value 会报一个错误，这是因为如果我们传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。</p><p>在 getter 函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个响应式对象，就是计算属性的依赖。</p><p>当然，有时候我们也希望能够直接修改 computed 的返回值，那么我们可以给 computed 传入一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(&#123; </span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>, </span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="params">val</span> =&gt;</span> &#123; </span><br><span class="line">    count.<span class="property">value</span> = val - <span class="number">1</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br><span class="line">plusOne.<span class="property">value</span> = <span class="number">1</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>在这个例子中，结合上述代码可以看到，我们给 computed 函数传入了一个拥有 getter 函数和 setter 函数的对象，getter 函数和之前一样，还是返回 count.value + 1；而 setter 函数，请注意，这里我们修改 plusOne.value 的值就会触发 setter 函数，其实 setter 函数内部实际上会根据传入的参数修改计算属性的依赖值 count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍 getter，所以这样获取的值也就发生了变化。</p><p>好了，我们现在已经知道了 computed API 的两种使用方式了，接下来就看看它是怎样实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOrOptions</span>) &#123; </span><br><span class="line">  <span class="comment">// getter 函数 </span></span><br><span class="line">  <span class="keyword">let</span> getter </span><br><span class="line">  <span class="comment">// setter 函数 </span></span><br><span class="line">  <span class="keyword">let</span> setter </span><br><span class="line">  <span class="comment">// 标准化参数 </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isFunction</span>(getterOrOptions)) &#123; </span><br><span class="line">    <span class="comment">// 表面传入的是 getter 函数，不能修改计算属性的值 </span></span><br><span class="line">    getter = getterOrOptions </span><br><span class="line">    setter = (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) </span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>) </span><br><span class="line">      &#125; </span><br><span class="line">      : <span class="variable constant_">NOOP</span> </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span> </span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span> </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 数据是否脏的 </span></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span> </span><br><span class="line">  <span class="comment">// 计算结果 </span></span><br><span class="line">  <span class="keyword">let</span> value </span><br><span class="line">  <span class="keyword">let</span> computed </span><br><span class="line">  <span class="comment">// 创建副作用函数 </span></span><br><span class="line">  <span class="keyword">const</span> runner = <span class="title function_">effect</span>(getter, &#123; </span><br><span class="line">    <span class="comment">// 延时执行 </span></span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 </span></span><br><span class="line">    <span class="attr">computed</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 调度执行的实现 </span></span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123; </span><br><span class="line">        dirty = <span class="literal">true</span> </span><br><span class="line">        <span class="comment">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span><br><span class="line">        <span class="title function_">trigger</span>(computed, <span class="string">&quot;set&quot;</span> <span class="comment">/* SET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="comment">// 创建 computed 对象 </span></span><br><span class="line">  computed = &#123; </span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="comment">// 暴露 effect 对象以便计算属性可以停止计算 </span></span><br><span class="line">    <span class="attr">effect</span>: runner, </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123; </span><br><span class="line">      <span class="comment">// 计算属性的 getter </span></span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123; </span><br><span class="line">        <span class="comment">// 只有数据为脏的时候才会重新计算 </span></span><br><span class="line">        value = <span class="title function_">runner</span>() </span><br><span class="line">        dirty = <span class="literal">false</span> </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span><br><span class="line">      <span class="title function_">track</span>(computed, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">      <span class="keyword">return</span> value </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123; </span><br><span class="line">      <span class="comment">// 计算属性的 setter </span></span><br><span class="line">      <span class="title function_">setter</span>(newValue) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> computed </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，computed 函数的流程主要做了三件事情：<strong>标准化参数，创建副作用函数和创建 computed 对象</strong>。我们来详细分析一下这几个步骤。</p><p>首先是<strong>标准化参数</strong>。computed 函数接受两种类型的参数，一个是 getter 函数，一个是拥有 getter 和 setter 函数的对象，通过判断参数的类型，我们初始化了函数内部定义的 getter 和 setter 函数。</p><p>接着是<strong>创建副作用函数 runner</strong>。computed 内部通过 effect 创建了一个副作用函数，它是对 getter 函数做的一层封装，另外我们这里要注意第二个参数，也就是 effect 函数的配置对象。其中 lazy 为 true 表示 effect 函数返回的 runner 并不会立即执行；computed 为 true 用于表示这是一个 computed effect，用于 trigger 阶段的优先级排序，我们稍后会分析；scheduler 表示它的调度运行的方式，我们也稍后分析。</p><p>最后是<strong>创建 computed 对象并返回</strong>，这个对象也拥有 getter 和 setter 函数。当 computed 对象被访问的时候会触发 getter，然后会判断是否 dirty，如果是就执行 runner，然后做依赖收集；当我们直接设置 computed 对象时会触发 setter，即执行 computed 函数内部定义的 setter 函数。</p><h4 id="计算属性的运行机制"><a href="#计算属性的运行机制" class="headerlink" title="计算属性的运行机制"></a>计算属性的运行机制</h4><p>computed 函数的逻辑会有一点绕，不过不要紧，我们可以结合一个应用 computed 计算属性的例子，来理解整个计算属性的运行机制。分析之前我们需要记住 computed 内部两个重要的变量，第一个 dirty 表示一个计算属性的值是否是“脏的”，用来判断需不需要重新计算，第二个 value 表示计算属性每次计算后的结果。</p><p>现在，我们来看这个示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">    &#123;&#123; plusOne &#125;&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;plus&quot;</span>&gt;</span>plus<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> count.<span class="property">value</span> + <span class="number">1</span> </span></span><br><span class="line"><span class="language-javascript">      &#125;) </span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">plus</span> = (<span class="params"></span>)=&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">          count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          plusOne,</span></span><br><span class="line"><span class="language-javascript">          plus</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在这个例子中我们利用 computed API 创建了计算属性对象 plusOne，它传入的是一个 getter 函数，为了和后面计算属性对象的 getter 函数区分，我们把它称作 computed getter。另外，组件模板中引用了 plusOne 变量和 plus 函数。</p><p>组件渲染阶段会访问 plusOne，也就触发了 plusOne 对象的 getter 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123; </span><br><span class="line">  <span class="comment">// 计算属性的 getter </span></span><br><span class="line">  <span class="keyword">if</span> (dirty) &#123; </span><br><span class="line">    <span class="comment">// 只有数据为脏的时候才会重新计算 </span></span><br><span class="line">    value = <span class="title function_">runner</span>() </span><br><span class="line">    dirty = <span class="literal">false</span> </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span><br><span class="line">  <span class="title function_">track</span>(computed, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">  <span class="keyword">return</span> value </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于默认 dirty 是 true，所以这个时候会执行 runner 函数，并进一步执行 computed getter，也就是 count.value + 1，因为访问了 count 的值，并且由于 count 也是一个响应式对象，所以就会触发 count 对象的依赖收集过程。</p><p>请注意，由于是在 runner 执行的时候访问 count，所以这个时候的 activeEffect 是 runner 函数。runner 函数执行完毕，会把 dirty 设置为 false，并进一步执行 track（computed,”get”,’value’) 函数做依赖收集，这个时候 runner 已经执行完了，所以 activeEffect 是组件副作用渲染函数。</p><p>然后当我们点击按钮的时候，会执行 plus 函数，函数内部通过 count.value++ 修改 count 的值，并派发通知。请注意，这里不是直接调用 runner 函数，而是把 runner 作为参数去执行 scheduler 函数。我们来回顾一下 trigger 函数内部对于 effect 函数的执行方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect</span>) =&gt; &#123; </span><br><span class="line">  <span class="comment">// 调度执行 </span></span><br><span class="line">  <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123; </span><br><span class="line">    effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 直接运行 </span></span><br><span class="line">    <span class="title function_">effect</span>() </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>computed API 内部创建副作用函数时，已经配置了 scheduler 函数，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (!dirty) &#123; </span><br><span class="line">    dirty = <span class="literal">true</span> </span><br><span class="line">    <span class="comment">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span><br><span class="line">    <span class="title function_">trigger</span>(computed, <span class="string">&quot;set&quot;</span> <span class="comment">/* SET */</span>, <span class="string">&#x27;value&#x27;</span>) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并没有对计算属性求新值，而仅仅是把 dirty 设置为 true，再执行 trigger(computed, “set” , ‘value’)，去通知执行 plusOne 依赖的组件渲染副作用函数，即触发组件的重新渲染。</p><p>在组件重新渲染的时候，会再次访问 plusOne，我们发现这个时候 dirty 为 true，然后会再次执行 computed getter，此时才会执行 count.value + 1 求得新值。这就是虽然组件没有直接访问 count，但是当我们修改 count 的值的时候，组件仍然会重新渲染的原因。</p><p>为了更加直观展示上述过程，我画了一张图：</p><img src="/2022/07/04/vue3/computed/Ciqc1F8nv6SAMiYhAAJ4vcrA7pg591.png" class=""><p>通过以上分析，我们可以看出 computed 计算属性有两个特点：</p><ol><li><strong>延时计算</strong>，只有当我们访问计算属性的时候，它才会真正运行 computed getter 函数计算；</li><li><strong>缓存</strong>，它的内部会缓存上次的计算结果 value，而且只有 dirty 为 true 时才会重新计算。如果访问计算属性时 dirty 为 false，那么直接返回这个 value。</li></ol><p>现在，我们就可以回答开头提的问题了。和单纯使用普通函数相比，计算属性的优势是：<strong>只要依赖不变化</strong>，<strong>就可以使用缓存的 value 而不用每次在渲染组件的时候都执行函数去计算</strong>，这是典型的空间换时间的优化思想。</p><h4 id="嵌套计算属性"><a href="#嵌套计算属性" class="headerlink" title="嵌套计算属性"></a>嵌套计算属性</h4><p>计算属性也支持嵌套，我们可以针对上述例子做个小修改，即不在渲染函数中访问 plusOne，而在另一个计算属性中访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">count</span> <span class="operator">=</span> ref(<span class="number">0</span>) </span><br><span class="line"><span class="type">const</span> <span class="variable">plusOne</span> <span class="operator">=</span> computed(() =&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> count.value + <span class="number">1</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="type">const</span> <span class="variable">plusTwo</span> <span class="operator">=</span> computed(() =&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> plusOne.value + <span class="number">1</span> </span><br><span class="line">&#125;) </span><br><span class="line">console.log(plusTwo.value)</span><br></pre></td></tr></table></figure><p>从代码中可以看到，当我们访问 plusTwo 的时候，过程和前面都差不多，同样也是两个依赖收集的过程。对于 plusOne 来说，它收集的依赖是 plusTwo 内部的 runner 函数；对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</p><p>接着当我们修改 count 的值时，它会派发通知，先运行 plusOne 内部的 scheduler 函数，把 plusOne 内部的 dirty 变为 true，然后执行 trigger 函数再次派发通知，接着运行 plusTwo 内部的 scheduler 函数，把 plusTwo 内部的 dirty 设置为 true。</p><p>然后当我们再次访问 plusTwo 的值时，发现 dirty 为 true，就会执行 plusTwo 的 computed getter 函数去执行 plusOne.value + 1，进而执行 plusOne 的 computed gette 即 count.value + 1 + 1，求得最终新值 2。</p><p>得益于 computed 这种巧妙的设计，无论嵌套多少层计算属性都可以正常工作。</p><h4 id="计算属性的执行顺序"><a href="#计算属性的执行顺序" class="headerlink" title="计算属性的执行顺序"></a>计算属性的执行顺序</h4><p>我们曾提到计算属性内部创建副作用函数的时候会配置 computed 为 true，标识这是一个 computed effect，用于在 trigger 阶段的优先级排序。我们来回顾一下 trigger 函数执行 effects 的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">effectsToAdd</span>) =&gt; &#123; </span><br><span class="line">  <span class="keyword">if</span> (effectsToAdd) &#123; </span><br><span class="line">    effectsToAdd.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> (effect !== activeEffect || !shouldTrack) &#123; </span><br><span class="line">        <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">computed</span>) &#123; </span><br><span class="line">          computedRunners.<span class="title function_">add</span>(effect) </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">          effects.<span class="title function_">add</span>(effect) </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect</span>) =&gt; &#123; </span><br><span class="line">  <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123; </span><br><span class="line">    effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect) </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_">effect</span>() </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">computedRunners.<span class="title function_">forEach</span>(run) </span><br><span class="line">effects.<span class="title function_">forEach</span>(run)</span><br></pre></td></tr></table></figure><p>在上一节课分析 trigger 函数的时候，为了方便你理解主干逻辑，我省略了 computedRunners 的分支逻辑。实际上，在添加待运行的 effects 的时候，我们会判断每一个 effect 是不是一个 computed effect，如果是的话会添加到 computedRunners 中，在后面运行的时候会优先执行 computedRunners，然后再执行普通的 effects。</p><p>那么为什么要这么设计呢？其实是考虑到了一些特殊场景，我们通过一个示例来说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> &#123; effect &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>) </span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> count.<span class="property">value</span> + <span class="number">1</span> </span><br><span class="line">&#125;) </span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span> + count.<span class="property">value</span>) </span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plus</span>(<span class="params"></span>) &#123; </span><br><span class="line">  count.<span class="property">value</span>++ </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">plus</span>()</span><br></pre></td></tr></table></figure><p>这个示例运行后的结果输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>在执行 effect 函数时运行 console.log(plusOne.value + count.value)，所以第一次输出 1，此时 count.value 是 0，plusOne.value 是 1。</p><p>后面连续输出两次 3 是因为， plusOne 和 count 的依赖都是这个 effect 函数，所以当我们执行 plus 函数修改 count 的值时，会触发并执行这个 effect 函数，因为 plusOne 的 runner 也是 count 的依赖，count 值修改也会执行 plusOne 的 runner，也就会再次执行 plusOne 的依赖即 effect 函数，因此会输出两次。</p><p>那么为什么两次都输出 3 呢？这就跟先执行 computed runner 有关。首先，由于 plusOne 的 runner 和 effect 都是 count 的依赖，当我们修改 count 值的时候， plusOne 的 runner 和 effect 都会执行，那么此时执行顺序就很重要了。</p><p>这里先执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value。这个时候，由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了新值 2， 再加上 1 就得到 3。执行完 plusOne 的 runner 以及依赖更新之后，再去执行 count 的普通effect 依赖，从而去执行 plusOne.value + count.value，这个时候 plusOne dirty 为 false， 直接返回上次的计算结果 2，然后再加 1 就又得到 3。</p><p>如果我们把 computed runner 和 effect 的执行顺序换一下会怎样呢？我来告诉你，会输出如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>第一次输出 1 很好理解，因为流程是一样的。第二次为什么会输出 2 呢？我们来分析一下，当我们执行 plus 函数修改 count 的值时，会触发 plusOne 的 runner 和 effect 的执行，这一次我们先让 effect 执行 plusOne.value + count.value，那么就会访问 plusOne.value，但由于 plusOne 的 runner 还没执行，所以此时 dirty 为 false，得到的值还是上一次的计算结果 1，然后再加 1 得到 2。</p><p>接着再执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value，这个时候由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了 2，然后再加上 1 就得到 3。</p><p>知道原因后，我们再回过头看例子。因为 effect 函数依赖了 plusOne 和 count，所以 plusOne 先计算会更合理，这就是为什么我们需要让 computed runner 的执行优先于普通的 effect 函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的，到这里我们这一节的学习就结束啦，我希望通过学习，你能理解计算属性的工作机制，能搞明白计算属性嵌套场景代码的执行顺序，知道计算属性的两个特点——延时计算和缓存，也希望你能够在组件的开发中合理使用计算属性。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;reactivity&#x2F;src&#x2F;computed.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章，我们学习了响应式的实现原理，这次我们将学习一个非常常用的响应式 API——&lt;strong&gt;计算属性&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="computed" scheme="https://xiaozhouguo.github.io/tags/computed/"/>
    
  </entry>
  
  <entry>
    <title>响应式内部的实现原理是怎样的 - 上篇</title>
    <link href="https://xiaozhouguo.github.io/2022/07/01/vue3/reactive-inner/"/>
    <id>https://xiaozhouguo.github.io/2022/07/01/vue3/reactive-inner/</id>
    <published>2022-07-01T02:13:28.000Z</published>
    <updated>2022-07-04T09:10:15.128Z</updated>
    
    <content type="html"><![CDATA[<p>上一节课我们学习了 <code>Composition API</code> 的核心 <code>setup</code> 函数的实现，在 setup 函数中，我们多次使用一些 API 让数据变成响应式，那么这节课我们就来深入学习响应式内部的实现原理。</p><span id="more"></span><p>除了组件化，Vue.js 另一个核心设计思想就是<strong>响应式</strong>。它的本质是当数据变化后会自动执行某个函数，映射到组件的实现就是，当数据变化后，会自动触发组件的重新渲染。<strong>响应式是 Vue.js 组件化更新渲染的一个核心机制</strong>。</p><p>在介绍 Vue.js 3.0 响应式实现之前，我们先来回顾一下 Vue.js 2.x 响应式实现的部分： 它在内部通过 <code>Object.defineProperty</code> API 劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新。我们用一张图可以直观地看清这个流程。</p><img src="/2022/07/01/vue3/reactive-inner/CgqCHl8YAPSAYotsAAG17TKWHiQ421.png" class=""><p>在 Vue.js 2.x 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。注意这里有两个流程，首先是<strong>依赖收集流程</strong>，组件在 render 的时候会访问模板中的数据，触发 getter 把 render watcher 作为依赖收集，并和数据建立联系；然后是<strong>派发通知流程</strong>，当我对这些数据修改的时候，会触发 setter，通知 render watcher 更新，进而触发了组件的重新渲染。</p><blockquote><p>我们知道 <code>Object.defineProperty</code> API 的一些缺点：不能监听对象属性新增和删除；初始化阶段递归执行 <code>Object.defineProperty</code> 带来的性能负担。</p></blockquote><p>Vue.js 3.0 为了解决 Object.defineProperty 的这些缺陷，使用 Proxy API 重写了响应式部分，并独立维护和发布整个 reactivity 库，下面我们就一起来深入学习 Vue.js 3.0 响应式部分的实现原理。</p><h3 id="响应式对象的实现差异"><a href="#响应式对象的实现差异" class="headerlink" title="响应式对象的实现差异"></a>响应式对象的实现差异</h3><p>在 <strong>Vue.js 2.x 中</strong>构建组件时，只要我们在 data、props、computed 中定义数据，那么它就是响应式的，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;random&quot;</span>&gt;</span>Random msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;msg reactive&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">random</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述组件初次渲染会显示“msg reactive”，当我们点击按钮的时候，会执行 random 函数，random 函数会修改 this.msg，就会发现组件重新渲染了。</p><p>我们对这个例子做一些改动，模板部分不变，我们把 msg 数据的定义放到created 钩子中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;msg not reactive&#x27;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">random</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，组件初次渲染显示“msg not reactive”，但是我们再次点击按钮就会发现组件并没有重新渲染。</p><p>这个问题相信你可能遇到过，其中的根本原因是我们在 created 中定义的 this.msg 并不是响应式对象，所以 Vue.js 内部不会对它做额外的处理。而 data 中定义的数据，Vue.js 内部在组件初始化的过程中会把它变成响应式，这是一个相对黑盒的过程，用户通常不会感知到。</p><p>你可能会好奇，为什么我在 created 钩子函数中定义数据而不在 data 中去定义？其实在 data 中定义数据最终也是挂载到组件实例 this 上，这和我直接在 created 钩子函数通过 this.xxx 定义的数据唯一区别就是，在 data 中定义的数据<strong>是响应式的</strong>。</p><p>在一些场景下，如果我们仅仅想在组件上下文中共享某个变量，而不必去监测它的<del>这个数据</del>变化，这时就特别适合在 created 钩子函数中去定义这个变量，因为创建响应式的过程是有性能代价的，这相当于一种 Vue.js 应用的性能优化小技巧，你掌握了这一点就可以在合适的场景中应用了。</p><p>到了 <strong>Vue.js 3.0</strong> 构建组件时，你可以不依赖于 Options API，而<strong>使用 Composition API</strong> 去编写。对于刚才的例子，我们可以用 Composition API 这样改写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; state.msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;random&quot;</span>&gt;</span>Random msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;msg reactive&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">random</span> =(<span class="params"></span>)=&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">          state.<span class="property">msg</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          state,</span></span><br><span class="line"><span class="language-javascript">          random</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们通过 setup 函数实现和前面示例同样的功能。请注意，这里我们引入了 <strong>reactive API，它可以把一个对象数据变成响应式。</strong> 可以看出来 Composition API 更推荐用户主动定义响应式对象，而非内部的黑盒处理。这样用户可以更加明确哪些数据是响应式的，如果你不想让数据变成响应式，就定义成它的原始数据类型即可。</p><h3 id="Reactive-API"><a href="#Reactive-API" class="headerlink" title="Reactive API"></a>Reactive API</h3><p>我们先来看一下 reactive 函数的具体实现过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span> (target) &#123;</span><br><span class="line">   <span class="comment">// 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; target.<span class="property">__v_isReadonly</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> target</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(target, <span class="literal">false</span>, mutableHandlers, mutableCollectionHandlers)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadonly, baseHandlers, collectionHandlers</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="comment">// 目标必须是对象或数组类型</span></span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">__v_raw</span> &amp;&amp; !(isReadonly &amp;&amp; target.<span class="property">__v_isReactive</span>)) &#123;</span><br><span class="line">    <span class="comment">// target 已经是 Proxy 对象，直接返回</span></span><br><span class="line">    <span class="comment">// 有个例外，如果是 readonly 作用于一个响应式对象，则继续</span></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">hasOwn</span>(target, isReadonly ? <span class="string">&quot;__v_readonly&quot;</span> <span class="comment">/* readonly */</span> : <span class="string">&quot;__v_reactive&quot;</span> <span class="comment">/* reactive */</span>)) &#123;</span><br><span class="line">    <span class="comment">// target 已经有对应的 Proxy 了</span></span><br><span class="line">    <span class="keyword">return</span> isReadonly ? target.<span class="property">__v_readonly</span> : target.<span class="property">__v_reactive</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有在白名单里的数据类型才能变成响应式</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">canObserve</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用 Proxy 创建响应式</span></span><br><span class="line">  <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, collectionTypes.<span class="title function_">has</span>(target.<span class="property">constructor</span>) ? collectionHandlers : baseHandlers)</span><br><span class="line">  <span class="comment">// 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了</span></span><br><span class="line">  <span class="title function_">def</span>(target, isReadonly ? <span class="string">&quot;__v_readonly&quot;</span> <span class="comment">/* readonly */</span> : <span class="string">&quot;__v_reactive&quot;</span> <span class="comment">/* reactive */</span>, observed)</span><br><span class="line">  <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，reactive 内部通过 <code>createReactiveObject</code> 函数把 target 变成了一个响应式对象。</p><p>在这个过程中，<code>createReactiveObject</code> 函数主要做了以下几件事情。</p><ol><li><p>函数首先判断 target 是不是数组或者对象类型，如果不是则直接返回。所以<strong>原始数据 target 必须是对象或者数组</strong>。</p></li><li><p>如果对一个已经是响应式的对象再次执行 reactive，还应该返回这个响应式对象，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> observed = <span class="title function_">reactive</span>(original)</span><br><span class="line"><span class="keyword">const</span> observed2 = <span class="title function_">reactive</span>(observed)</span><br><span class="line">observed === observed2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以看到 observed 已经是响应式结果了，如果对它再去执行 reactive，返回的值 observed2 和 observed 还是同一个对象引用。</p><p>因为这里 reactive 函数会通过 <code>target.__v_raw</code> 属性来判断 target 是否已经是一个响应式对象（因为响应式对象的 __v_raw 属性会指向它自身，后面会提到），如果是的话则直接返回响应式对象。</p></li></ol><p>​</p><ol start="3"><li><p>如果对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> observed = <span class="title function_">reactive</span>(original)</span><br><span class="line"><span class="keyword">const</span> observed2 = <span class="title function_">reactive</span>(original)</span><br><span class="line">observed === observed2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>canObserve</code> 函数对 target 对象做一进步限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">canObserve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (!value.<span class="property">__v_skip</span> &amp;&amp;</span><br><span class="line">   <span class="title function_">isObservableType</span>(<span class="title function_">toRawType</span>(value)) &amp;&amp;</span><br><span class="line">   !<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(value))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isObservableType = <span class="comment">/*#__PURE__*/</span> <span class="title function_">makeMap</span>(<span class="string">&#x27;Object,Array,Map,Set,WeakMap,WeakSet&#x27;</span>)</span><br></pre></td></tr></table></figure><p>比如，带有 __v_skip 属性的对象、被冻结的对象，以及不在白名单内的对象如 Date 类型的对象实例是不能变成响应式的。</p></li><li><p>通过 Proxy API 劫持 target 对象，把它变成响应式。我们把 Proxy 函数返回的结果称作响应式对象，这里 Proxy 对应的处理器对象会根据数据类型的不同而不同，我们稍后会重点分析基本数据类型的 Proxy 处理器对象，reactive 函数传入的 baseHandlers 值是 mutableHandlers。</p></li><li><p>给原始数据打个标识，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="property">__v_reactive</span> = observed</span><br></pre></td></tr></table></figure><p>这就是前面“对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象”逻辑的判断依据。</p></li></ol><p>仔细想想看，响应式的实现方式无非就是劫持数据，Vue.js 3.0 的 reactive API 就是通过 Proxy 劫持数据，而且由于 Proxy 劫持的是整个对象，所以我们可以检测到任何对对象的修改，弥补了 Object.defineProperty API 的不足。</p><p>接下来，我们继续看 Proxy 处理器对象 mutableHandlers 的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableHandlers = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实就是劫持了我们对 observed 对象的一些操作，比如：</p><ul><li>访问对象属性会触发 get 函数；</li><li>设置对象属性会触发 set 函数；</li><li>删除对象属性会触发 deleteProperty 函数；</li><li>in 操作符会触发 has 函数；</li><li>通过 Object.getOwnPropertyNames 访问对象属性名会触发 ownKeys 函数。</li></ul><p>因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的 get 和 set 函数就可以了。</p><h4 id="依赖收集：get-函数"><a href="#依赖收集：get-函数" class="headerlink" title="依赖收集：get 函数"></a>依赖收集：get 函数</h4><p><strong>依赖收集发生在数据访问的阶段</strong>，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性被访问的时候就会执行 get 函数，我们来看一下 get 函数的实现，其实它是执行 createGetter 函数的返回值，为了分析主要流程，这里省略了 get 函数中的一些分支逻辑，isReadonly 也默认为 false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&quot;__v_isReactive&quot;</span> <span class="comment">/* isReactive */</span>) &#123;</span><br><span class="line">      <span class="comment">// 代理 observed.__v_isReactive</span></span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&quot;__v_isReadonly&quot;</span> <span class="comment">/* isReadonly */</span>) &#123;</span><br><span class="line">      <span class="comment">// 代理 observed.__v_isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&quot;__v_raw&quot;</span> <span class="comment">/* raw */</span>) &#123;</span><br><span class="line">      <span class="comment">// 代理 observed.__v_raw</span></span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)</span><br><span class="line">    <span class="comment">// arrayInstrumentations 包含对数组一些方法修改的函数</span></span><br><span class="line">    <span class="keyword">if</span> (targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    <span class="comment">// 内置 Symbol key 不需要依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) &amp;&amp; builtInSymbols.<span class="title function_">has</span>(key) || key === <span class="string">&#x27;__proto__&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    !isReadonly &amp;&amp; <span class="title function_">track</span>(target, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isObject</span>(res)</span><br><span class="line">      ? isReadonly</span><br><span class="line">        ?</span><br><span class="line">        <span class="title function_">readonly</span>(res)</span><br><span class="line">        <span class="comment">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span></span><br><span class="line">        : <span class="title function_">reactive</span>(res)</span><br><span class="line">      : res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上述代码来看，get 函数主要做了四件事情，<strong>首先对特殊的 key 做了代理</strong>，这就是为什么我们在 createReactiveObject 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</p><p><strong>接着通过 Reflect.get 方法求值</strong>，如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数，我们可以大概看一下 arrayInstrumentations 的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayInstrumentations = &#123;&#125;</span><br><span class="line">[<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  arrayInstrumentations[key] = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// toRaw 可以把响应式对象转成原始数据</span></span><br><span class="line">    <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      <span class="title function_">track</span>(arr, <span class="string">&quot;get&quot;</span> <span class="comment">/* GET */</span>, i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先尝试用参数本身，可能是响应式数据</span></span><br><span class="line">    <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">    <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果失败，再尝试把参数转成原始数据</span></span><br><span class="line">      <span class="keyword">return</span> arr[key](...args.<span class="title function_">map</span>(toRaw))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也就是说，当 target 是一个数组的时候，我们去访问 target.includes、target.indexOf 或者 target.lastIndexOf 就会执行 arrayInstrumentations 代理的函数，除了调用数组本身的方法求值外，还对数组每个元素做了依赖收集。因为一旦数组的元素被修改，数组的这几个 API 的返回结果都可能发生变化，所以我们需要跟踪数组每个元素的变化。</p><p>回到 get 函数，第三步就是<strong>通过 Reflect.get 求值，然后会执行 track 函数收集依赖</strong>，我们稍后重点分析这个过程。</p><p>函数最后<strong>会对计算的值 res 进行判断</strong>，如果它也是数组或对象，则递归执行 reactive 把 res 变成响应式对象。这么做是因为 Proxy 劫持的是对象本身，并不能劫持子对象的变化，这点和 Object.defineProperty API 一致。但是 Object.defineProperty 是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而 Proxy 是在对象属性被访问的时候才递归执行下一步 reactive，这其实是一种延时定义子对象响应式的实现，在性能上会有较大的提升。</p><p>整个 get 函数最核心的部分其实是<strong>执行 track 函数收集依赖</strong>，下面我们重点分析这个过程。</p><p>我们先来看一下 track 函数的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否应该收集依赖</span></span><br><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 当前激活的 effect</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="comment">// 原始数据对象 map</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, type, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// 每个 target 对应一个 depsMap</span></span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    <span class="comment">// 每个 key 对应一个 dep 集合</span></span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (dep = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.<span class="title function_">has</span>(activeEffect)) &#123;</span><br><span class="line">    <span class="comment">// 收集当前激活的 effect 作为依赖</span></span><br><span class="line">    dep.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">   <span class="comment">// 当前激活的 effect 收集 dep 集合作为依赖</span></span><br><span class="line">    activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这个函数的实现前，我们先想一下要收集的依赖是什么，我们的目的是实现响应式，就是当数据变化的时候可以自动做一些事情，比如执行某些函数，所以我们<strong>收集的依赖就是数据变化后执行的副作用函数</strong>。</p><p>再来看实现，我们把 target 作为原始的数据，key 作为访问的属性。我们创建了全局的 targetMap 作为原始数据对象的 Map，它的键是 target，值是 depsMap，作为依赖的 Map；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数。为了方便理解，可以通过下图表示它们之间的关系：</p><img src="/2022/07/01/vue3/reactive-inner/Ciqc1F8YAL6Afvr-AAEj_nQbDuE332-16569255890917.png" class=""><p>所以每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。</p><p>了解完依赖收集的过程，下节课我们来分析派发通知的过程。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;reactivity&#x2F;src&#x2F;baseHandlers.ts<br>packages&#x2F;reactivity&#x2F;src&#x2F;effect.ts<br>packages&#x2F;reactivity&#x2F;src&#x2F;reactive.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节课我们学习了 &lt;code&gt;Composition API&lt;/code&gt; 的核心 &lt;code&gt;setup&lt;/code&gt; 函数的实现，在 setup 函数中，我们多次使用一些 API 让数据变成响应式，那么这节课我们就来深入学习响应式内部的实现原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="reactive" scheme="https://xiaozhouguo.github.io/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>setup：组件渲染前的初始化过程是怎样的？</title>
    <link href="https://xiaozhouguo.github.io/2022/06/29/vue3/setup/"/>
    <id>https://xiaozhouguo.github.io/2022/06/29/vue3/setup/</id>
    <published>2022-06-29T02:23:30.000Z</published>
    <updated>2022-07-26T07:31:47.110Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 3.0 允许我们在编写组件的时候添加一个 setup 启动函数，它是 Composition API 逻辑组织的入口，我们这就来分析一下这个函数。</p><span id="more"></span><p>我们先通过一段代码认识它，在这里编写一个 button 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span><br><span class="line">    Count is: &#123;&#123; state.count &#125;&#125;, double is: &#123;&#123; state.double &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; reactive, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">double</span>: <span class="title function_">computed</span>(<span class="function">() =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      state.<span class="property">count</span>++</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      state,</span></span><br><span class="line"><span class="language-javascript">      increment</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，这段代码和 Vue.js 2.x 组件的写法相比，多了一个 setup 启动函数，另外组件中也没有定义 props、data、computed 这些 options。</p><p>在 setup 函数内部，定义了一个响应式对象 state，它是通过 reactive API 创建的。state 对象有 count 和 double 两个属性，其中 count 对应一个数字属性的值；而double 通过 computed API 创建，对应一个计算属性的值。reactive API 和 computed API 不是我们关注的重点，在后续响应式章节我会详细介绍。</p><p>这里需要注意的是，<strong>模板中引用到的变量 state 和 increment 包含在 setup 函数的返回对象中，那么它们是如何建立联系的呢？</strong></p><p>我们先来回想一下 Vue.js 2.x 编写组件的时候，会在 props、data、methods、computed 等 options 中定义一些变量。在组件初始化阶段，Vue.js 内部会处理这些 options，即把定义的变量添加到了组件实例上。等模板编译成 render 函数的时候，内部通过 with(this){} 的语法去访问在组件实例中的变量。</p><p>那么到了 Vue.js 3.0，既支持组件定义 setup 函数，而且在模板 render 的时候，又可以访问到 setup 函数返回的值，这是如何实现的？我们来一探究竟。</p><h3 id="创建和设置组件实例"><a href="#创建和设置组件实例" class="headerlink" title="创建和设置组件实例"></a>创建和设置组件实例</h3><p>首先，我们来回顾一下组件的渲染流程：创建 vnode 、渲染 vnode 和生成 DOM。</p><img src="/2022/06/29/vue3/setup/Ciqc1F8VZpKAVYWOAABLt08AfuQ883.png" class=""><p>其中渲染 vnode 的过程主要就是在挂载组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mountComponent</span> = (<span class="params">initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (initialVNode.<span class="property">component</span> = <span class="title function_">createComponentInstance</span>(initialVNode, parentComponent, parentSuspense))</span><br><span class="line">  <span class="comment">// 设置组件实例</span></span><br><span class="line">  <span class="title function_">setupComponent</span>(instance)</span><br><span class="line">  <span class="comment">// 设置并运行带副作用的渲染函数</span></span><br><span class="line">  <span class="title function_">setupRenderEffect</span>(instance, initialVNode, container, anchor, </span><br><span class="line">  parentSuspense, isSVG, optimized)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，这段挂载组件的代码主要做了三件事情：创建组件实例、设置组件实例和设置并运行带副作用的渲染函数。前两个流程就跟我们今天提到的问题息息相关，所以这一节课我们将重点分析它们。</p></blockquote><h4 id="创建组件实例"><a href="#创建组件实例" class="headerlink" title="创建组件实例"></a>创建组件实例</h4><p>我们要关注 createComponentInstance 方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComponentInstance</span> (vnode, parent, suspense) &#123;</span><br><span class="line">  <span class="comment">// 继承父组件实例上的 appContext，如果是根组件，则直接从根 vnode 中取。</span></span><br><span class="line">  <span class="keyword">const</span> appContext = (parent ? parent.<span class="property">appContext</span> : vnode.<span class="property">appContext</span>) || emptyAppContext;</span><br><span class="line">  <span class="keyword">const</span> instance = &#123;</span><br><span class="line">    <span class="comment">// 组件唯一 id</span></span><br><span class="line">    <span class="attr">uid</span>: uid++,</span><br><span class="line">    <span class="comment">// 组件 vnode</span></span><br><span class="line">    vnode,</span><br><span class="line">    <span class="comment">// 父组件实例</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// app 上下文</span></span><br><span class="line">    appContext,</span><br><span class="line">    <span class="comment">// vnode 节点类型</span></span><br><span class="line">    <span class="attr">type</span>: vnode.<span class="property">type</span>,</span><br><span class="line">    <span class="comment">// 根组件实例</span></span><br><span class="line">    <span class="attr">root</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 新的组件 vnode</span></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 子节点 vnode</span></span><br><span class="line">    <span class="attr">subTree</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 带副作用更新函数</span></span><br><span class="line">    <span class="attr">update</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染函数</span></span><br><span class="line">    <span class="attr">render</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染上下文代理</span></span><br><span class="line">    <span class="attr">proxy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 带有 with 区块的渲染上下文代理</span></span><br><span class="line">    <span class="attr">withProxy</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 响应式相关对象</span></span><br><span class="line">    <span class="attr">effects</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 依赖注入相关</span></span><br><span class="line">    <span class="attr">provides</span>: parent ? parent.<span class="property">provides</span> : <span class="title class_">Object</span>.<span class="title function_">create</span>(appContext.<span class="property">provides</span>),</span><br><span class="line">    <span class="comment">// 渲染代理的属性访问缓存</span></span><br><span class="line">    <span class="attr">accessCache</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 渲染缓存</span></span><br><span class="line">    <span class="attr">renderCache</span>: [],</span><br><span class="line">    <span class="comment">// 渲染上下文</span></span><br><span class="line">    <span class="attr">ctx</span>: <span class="variable constant_">EMPTY_OBJ</span>,</span><br><span class="line">    <span class="comment">// data 数据</span></span><br><span class="line">    <span class="attr">data</span>: <span class="variable constant_">EMPTY_OBJ</span>,</span><br><span class="line">    <span class="comment">// props 数据</span></span><br><span class="line">    <span class="attr">props</span>: <span class="variable constant_">EMPTY_OBJ</span>,</span><br><span class="line">    <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="attr">attrs</span>: <span class="variable constant_">EMPTY_OBJ</span>,</span><br><span class="line">    <span class="comment">// 插槽相关</span></span><br><span class="line">    <span class="attr">slots</span>: <span class="variable constant_">EMPTY_OBJ</span>,</span><br><span class="line">    <span class="comment">// 组件或者 DOM 的 ref 引用</span></span><br><span class="line">    <span class="attr">refs</span>: <span class="variable constant_">EMPTY_OBJ</span>,</span><br><span class="line">    <span class="comment">// setup 函数返回的响应式结果</span></span><br><span class="line">    <span class="attr">setupState</span>: <span class="variable constant_">EMPTY_OBJ</span>,</span><br><span class="line">    <span class="comment">// setup 函数上下文数据</span></span><br><span class="line">    <span class="attr">setupContext</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 注册的组件</span></span><br><span class="line">    <span class="attr">components</span>: <span class="title class_">Object</span>.<span class="title function_">create</span>(appContext.<span class="property">components</span>),</span><br><span class="line">    <span class="comment">// 注册的指令</span></span><br><span class="line">    <span class="attr">directives</span>: <span class="title class_">Object</span>.<span class="title function_">create</span>(appContext.<span class="property">directives</span>),</span><br><span class="line">    <span class="comment">// suspense 相关</span></span><br><span class="line">    suspense,</span><br><span class="line">    <span class="comment">// suspense 异步依赖</span></span><br><span class="line">    <span class="attr">asyncDep</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// suspense 异步依赖是否都已处理</span></span><br><span class="line">    <span class="attr">asyncResolved</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否挂载</span></span><br><span class="line">    <span class="attr">isMounted</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否卸载</span></span><br><span class="line">    <span class="attr">isUnmounted</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否激活</span></span><br><span class="line">    <span class="attr">isDeactivated</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before create</span></span><br><span class="line">    <span class="attr">bc</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，created</span></span><br><span class="line">    <span class="attr">c</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before mount</span></span><br><span class="line">    <span class="attr">bm</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，mounted</span></span><br><span class="line">    <span class="attr">m</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before update</span></span><br><span class="line">    <span class="attr">bu</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，updated</span></span><br><span class="line">    <span class="attr">u</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，unmounted</span></span><br><span class="line">    <span class="attr">um</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期，before unmount</span></span><br><span class="line">    <span class="attr">bum</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期, deactivated</span></span><br><span class="line">    <span class="attr">da</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 activated</span></span><br><span class="line">    <span class="attr">a</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 render triggered</span></span><br><span class="line">    <span class="attr">rtg</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 render tracked</span></span><br><span class="line">    <span class="attr">rtc</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 生命周期 error captured</span></span><br><span class="line">    <span class="attr">ec</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 派发事件方法</span></span><br><span class="line">    <span class="attr">emit</span>: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化渲染上下文</span></span><br><span class="line">  instance.<span class="property">ctx</span> = &#123; <span class="attr">_</span>: instance &#125;</span><br><span class="line">  <span class="comment">// 初始化根组件指针</span></span><br><span class="line">  instance.<span class="property">root</span> = parent ? parent.<span class="property">root</span> : instance</span><br><span class="line">  <span class="comment">// 初始化派发事件方法</span></span><br><span class="line">  instance.<span class="property">emit</span> = emit.<span class="title function_">bind</span>(<span class="literal">null</span>, instance)</span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，组件实例 instance 上定义了很多属性，你千万不要被这茫茫多的属性吓到，因为其中一些属性是为了实现某个场景或者某个功能所定义的，你只需要通过我在代码中的注释大概知道它们是做什么的即可。</p><p>Vue.js 2.x 使用 new Vue 来初始化一个组件的实例，到了 Vue.js 3.0，我们直接通过创建对象去创建组件的实例。这两种方式并无本质的区别，都是引用一个对象，在整个组件的生命周期中去维护组件的状态数据和上下文环境。</p><p>创建好 instance 实例后，接下来就是设置它的一些属性。目前已完成了组件的上下文、根组件指针以及派发事件方法的设置。我们在后面会继续分析更多 instance 实例属性的设置逻辑。</p><h4 id="设置组件实例"><a href="#设置组件实例" class="headerlink" title="设置组件实例"></a>设置组件实例</h4><p>接着是<strong>组件实例的设置流程</strong>，对 setup 函数的处理就在这里完成，我们来看一下 setupComponent 方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupComponent</span> (instance, isSSR = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; props, children, shapeFlag &#125; = instance.<span class="property">vnode</span></span><br><span class="line">  <span class="comment">// 判断是否是一个有状态的组件</span></span><br><span class="line">  <span class="keyword">const</span> isStateful = shapeFlag &amp; <span class="number">4</span></span><br><span class="line">  <span class="comment">// 初始化 props</span></span><br><span class="line">  <span class="title function_">initProps</span>(instance, props, isStateful, isSSR)</span><br><span class="line">  <span class="comment">// 初始化 插槽</span></span><br><span class="line">  <span class="title function_">initSlots</span>(instance, children)</span><br><span class="line">  <span class="comment">// 设置有状态的组件实例</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? <span class="title function_">setupStatefulComponent</span>(instance, isSSR)</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> setupResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们从组件 vnode 中获取了 props、children、shapeFlag 等属性，然后分别<strong>对 props 和插槽进行初始化</strong>，这两部分逻辑在后续的章节再详细分析。根据 shapeFlag 的值，我们可以判断这是不是一个有状态组件，如果是则要进一步去设置有状态组件的实例。</p><p>接下来我们要关注到 <code>setupStatefulComponent</code> 函数，它主要做了三件事：<strong>创建渲染上下文代理、判断处理 setup 函数和完成组件实例设置</strong>。它代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupStatefulComponent</span> (instance, isSSR) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Component</span> = instance.<span class="property">type</span></span><br><span class="line">  <span class="comment">// 创建渲染代理的属性访问缓存</span></span><br><span class="line">  instance.<span class="property">accessCache</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// 创建渲染上下文代理</span></span><br><span class="line">  instance.<span class="property">proxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(instance.<span class="property">ctx</span>, <span class="title class_">PublicInstanceProxyHandlers</span>)</span><br><span class="line">  <span class="comment">// 判断处理 setup 函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = <span class="title class_">Component</span></span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="comment">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.<span class="property">setupContext</span> =</span><br><span class="line">      setup.<span class="property">length</span> &gt; <span class="number">1</span> ? <span class="title function_">createSetupContext</span>(instance) : <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 执行 setup 函数，获取结果</span></span><br><span class="line">    <span class="keyword">const</span> setupResult = <span class="title function_">callWithErrorHandling</span>(setup, instance,</span><br><span class="line">          <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>, [instance.<span class="property">props</span>, setupContext])</span><br><span class="line">    <span class="comment">// 处理 setup 执行结果</span></span><br><span class="line">    <span class="title function_">handleSetupResult</span>(instance, setupResult)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 完成组件实例设置</span></span><br><span class="line">    <span class="title function_">finishComponentSetup</span>(instance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建渲染上下文代理"><a href="#创建渲染上下文代理" class="headerlink" title="创建渲染上下文代理"></a>创建渲染上下文代理</h5><p>首先是创建渲染上下文代理的流程，它主要对 <code>instance.ctx</code> 做了代理。在分析实现前，我们需要思考一个问题，这里为什么需要代理呢？</p><p>其实在 Vue.js 2.x 中，也有类似的数据代理逻辑，比如 props 求值后的数据，实际上存储在 <code>this._props</code> 上，而 data 中定义的数据存储在 <code>this._data</code>上。举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">msg</span>: <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在初始化组件的时候，data 中定义的 msg 在组件内部是存储在 <code>this._data</code> 上的，而模板渲染的时候访问 this.msg，实际上访问的是 <code>this._data.msg</code>，这是因为 Vue.js 2.x 在初始化 data 的时候，做了一层 proxy 代理。</p><p>到了 Vue.js 3.0，为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到 setupState、ctx、data、props 中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 instance.ctx 中的属性，所以我们也要做一层 proxy，对渲染上下文 instance.ctx 属性的访问和修改，代理到对 setupState、ctx、data、props 中的数据的访问和修改。</p><p>明确了代理的需求后，我们接下来就要分析 proxy 的几个方法： get、set 和 has。</p><p>当我们<strong>访问 instance.ctx 渲染上下文中的属性</strong>时，就会<strong>进入 get 函数</strong>。我们来看一下它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class="line">  get (&#123; <span class="attr">_</span>: instance &#125;, key) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] !== <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// setupState / data / props / ctx</span></span><br><span class="line">      <span class="comment">// 渲染代理的属性访问缓存中</span></span><br><span class="line">      <span class="keyword">const</span> n = accessCache[key]</span><br><span class="line">      <span class="keyword">if</span> (n !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 从缓存中取</span></span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* SETUP */</span></span><br><span class="line">            <span class="keyword">return</span> setupState[key]</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> :<span class="comment">/* DATA */</span></span><br><span class="line">            <span class="keyword">return</span> data[key]</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span> :<span class="comment">/* CONTEXT */</span></span><br><span class="line">            <span class="keyword">return</span> ctx[key]</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* PROPS */</span></span><br><span class="line">            <span class="keyword">return</span> props[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (setupState !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(setupState, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 从 setupState 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> setupState[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(data, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 从 data 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> data[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        type.<span class="property">props</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">hasOwn</span>(<span class="title function_">normalizePropsOptions</span>(type.<span class="property">props</span>)[<span class="number">0</span>], key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">2</span></span><br><span class="line">        <span class="comment">// 从 props 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> props[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ctx !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(ctx, key)) &#123;</span><br><span class="line">        accessCache[key] = <span class="number">3</span></span><br><span class="line">        <span class="comment">// 从 ctx 中取数据</span></span><br><span class="line">        <span class="keyword">return</span> ctx[key]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 都取不到</span></span><br><span class="line">        accessCache[key] = <span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> publicGetter = publicPropertiesMap[key]</span><br><span class="line">    <span class="keyword">let</span> cssModule, globalProperties</span><br><span class="line">    <span class="comment">// 公开的 $xxx 属性或方法</span></span><br><span class="line">    <span class="keyword">if</span> (publicGetter) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">publicGetter</span>(instance)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// css 模块，通过 vue-loader 编译的时候注入</span></span><br><span class="line">      (cssModule = type.<span class="property">__cssModules</span>) &amp;&amp;</span><br><span class="line">      (cssModule = cssModule[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> cssModule</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(ctx, key)) &#123;</span><br><span class="line">      <span class="comment">// 用户自定义的属性，也用 `$` 开头</span></span><br><span class="line">      accessCache[key] = <span class="number">3</span></span><br><span class="line">      <span class="keyword">return</span> ctx[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// 全局定义的属性</span></span><br><span class="line">      ((globalProperties = appContext.<span class="property">config</span>.<span class="property">globalProperties</span>),</span><br><span class="line">        <span class="title function_">hasOwn</span>(globalProperties, key))) &#123;</span><br><span class="line">      <span class="keyword">return</span> globalProperties[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp;</span><br><span class="line">      currentRenderingInstance &amp;&amp; key.<span class="title function_">indexOf</span>(<span class="string">&#x27;__v&#x27;</span>) !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; key[<span class="number">0</span>] === <span class="string">&#x27;$&#x27;</span> &amp;&amp; <span class="title function_">hasOwn</span>(data, key)) &#123;</span><br><span class="line">        <span class="comment">// 如果在 data 中定义的数据以 $ 开头，会报警告，因为 $ 是保留字符，不会做代理</span></span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span> must be accessed via $data because it starts with a reserved `</span> +</span><br><span class="line">          <span class="string">`character and is not proxied on the render context.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在模板中使用的变量如果没有定义，报警告</span></span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span> was accessed during render `</span> +</span><br><span class="line">          <span class="string">`but is not defined on instance.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，函数首先判断 key 不以 $ 开头的情况，这部分数据可能是 setupState、data、props、ctx 中的一种，其中 data、props 我们已经很熟悉了；setupState 就是 setup 函数返回的数据，稍后我们会详细说；ctx 包括了计算属性、组件方法和用户自定义的一些数据。</p><p>如果 key 不以 $ 开头，那么就依次判断 setupState、data、props、ctx 中是否包含这个 key，如果包含就返回对应值。<strong>注意这个判断顺序很重要</strong>，<strong>在 key 相同时它会决定数据获取的优先级</strong>，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;msg from data&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;msg from setup&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        msg</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在 data 和 setup 中都定义了 msg 变量，但最终输出到界面上的是”msg from setup”，这是因为 setupState 的判断优先级要高于 data。</p><p>再回到 get 函数中，我们可以看到这里定义了 accessCache 作为渲染代理的属性访问缓存，它具体是干什么的呢？组件在渲染时会经常访问数据进而触发 get 函数，这其中最昂贵的部分就是多次调用 hasOwn 去判断 key 在不在某个类型的数据中，但是在普通对象上执行简单的属性访问相对要快得多。所以在第一次获取 key 对应的数据后，我们利用 accessCache[key] 去缓存数据，下一次再次根据 key 查找数据，我们就可以直接通过 accessCache[key] 获取对应的值，就不需要依次调用 hasOwn 去判断了。这也是一个性能优化的小技巧。</p><p>如果 key 以 $ 开头，那么接下来又会有一系列的判断，首先判断是不是 Vue.js 内部公开的 $xxx 属性或方法（比如 $parent）；然后判断是不是 vue-loader 编译注入的 css 模块内部的 key；接着判断是不是用户自定义以 $ 开头的 key；最后判断是不是全局属性。如果都不满足，就剩两种情况了，即在非生产环境下就会报两种类型的警告，第一种是在 data 中定义的数据以 $ 开头的警告，因为 $ 是保留字符，不会做代理；第二种是在模板中使用的变量没有定义的警告。</p><p>接下来是 set 代理过程，当我们<strong>修改 instance.ctx 渲染上下文中的属性</strong>的时候，就会<strong>进入 set 函数</strong>。我们来看一下 set 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class="line">  set (&#123; <span class="attr">_</span>: instance &#125;, key, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data, setupState, ctx &#125; = instance</span><br><span class="line">    <span class="keyword">if</span> (setupState !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(setupState, key)) &#123;</span><br><span class="line">      <span class="comment">// 给 setupState 赋值</span></span><br><span class="line">      setupState[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(data, key)) &#123;</span><br><span class="line">      <span class="comment">// 给 data 赋值</span></span><br><span class="line">      data[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key <span class="keyword">in</span> instance.<span class="property">props</span>) &#123;</span><br><span class="line">      <span class="comment">// 不能直接给 props 赋值</span></span><br><span class="line">      (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Attempting to mutate prop &quot;<span class="subst">$&#123;key&#125;</span>&quot;. Props are readonly.`</span>, instance)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;$&#x27;</span> &amp;&amp; key.<span class="title function_">slice</span>(<span class="number">1</span>) <span class="keyword">in</span> instance) &#123;</span><br><span class="line">      <span class="comment">// 不能给 Vue 内部以 $ 开头的保留属性赋值</span></span><br><span class="line">      (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Attempting to mutate public property &quot;<span class="subst">$&#123;key&#125;</span>&quot;. `</span> +</span><br><span class="line">        <span class="string">`Properties starting with $ are reserved and readonly.`</span>, instance)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用户自定义数据赋值</span></span><br><span class="line">      ctx[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合代码来看，函数主要做的事情就是对渲染上下文 instance.ctx 中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和 get 一样，优先判断 setupState，然后是 data，接着是 props。</p><p>我们对之前的例子做点修改，添加一个方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;random&quot;</span>&gt;</span>Random msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;msg from data&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;msg from setup&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        msg</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">random</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们点击按钮会执行 random 函数，这里的 this 指向的就是 instance.ctx，我们修改 this.msg 会触发 set 函数，所以最终修改的是 setupState 中的 msg 对应的值。</p><p>注意，如果我们直接对 props 中的数据赋值，在非生产环境中会收到一条警告，这是因为直接修改 props 不符合数据单向流动的设计思想；如果对 Vue.js 内部以 $ 开头的保留属性赋值，同样也会收到一条警告。</p><p>如果是用户自定义的数据，比如在 created 生命周期内定义的数据，它仅用于组件上下文的共享，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">userMsg</span> = <span class="string">&#x27;msg from user&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 this.userMsg 赋值的时候，会触发 set 函数，最终 userMsg 会被保留到 ctx 中。</p><p>最后是 has 代理过程，当我们<strong>判断属性是否存在于 instance.ctx 渲染上下文中</strong>时，就<strong>会进入 has 函数</strong>，这个在平时项目中用的比较少，同样来举个例子，当执行 created 钩子函数中的 ‘msg’ in this 时，就会触发 has 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;msg&#x27;</span> <span class="keyword">in</span> <span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来看一下 has 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PublicInstanceProxyHandlers</span> = &#123;</span><br><span class="line">  has</span><br><span class="line">    (&#123; <span class="attr">_</span>: &#123; data, setupState, accessCache, ctx, type, appContext &#125; &#125;, key) &#123;</span><br><span class="line">    <span class="comment">// 依次判断</span></span><br><span class="line">    <span class="keyword">return</span> (accessCache[key] !== <span class="literal">undefined</span> ||</span><br><span class="line">      (data !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(data, key)) ||</span><br><span class="line">      (setupState !== <span class="variable constant_">EMPTY_OBJ</span> &amp;&amp; <span class="title function_">hasOwn</span>(setupState, key)) ||</span><br><span class="line">      (type.<span class="property">props</span> &amp;&amp; <span class="title function_">hasOwn</span>(<span class="title function_">normalizePropsOptions</span>(type.<span class="property">props</span>)[<span class="number">0</span>], key)) ||</span><br><span class="line">      <span class="title function_">hasOwn</span>(ctx, key) ||</span><br><span class="line">      <span class="title function_">hasOwn</span>(publicPropertiesMap, key) ||</span><br><span class="line">      <span class="title function_">hasOwn</span>(appContext.<span class="property">config</span>.<span class="property">globalProperties</span>, key))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的实现很简单，依次判断 key 是否存在于 accessCache、data、setupState、props 、用户数据、公开属性以及全局属性中，然后返回结果。</p><p>至此，我们就搞清楚了创建上下文代理的过程，让我们回到 setupStatefulComponent 函数中，接下来分析第二个流程——判断处理 setup 函数。</p><h5 id="判断处理-setup-函数"><a href="#判断处理-setup-函数" class="headerlink" title="判断处理 setup 函数"></a>判断处理 setup 函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断处理 setup 函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; setup &#125; = <span class="title class_">Component</span></span><br><span class="line"><span class="keyword">if</span> (setup) &#123;</span><br><span class="line">  <span class="comment">// 如果 setup 函数带参数，则创建一个 setupContext</span></span><br><span class="line">  <span class="keyword">const</span> setupContext = (instance.<span class="property">setupContext</span> =</span><br><span class="line">    setup.<span class="property">length</span> &gt; <span class="number">1</span> ? <span class="title function_">createSetupContext</span>(instance) : <span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 执行 setup 函数获取结果</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = <span class="title function_">callWithErrorHandling</span>(setup, instance, <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>, [instance.<span class="property">props</span>, setupContext])</span><br><span class="line">  <span class="comment">// 处理 setup 执行结果</span></span><br><span class="line">  <span class="title function_">handleSetupResult</span>(instance, setupResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在组件中定义了 setup 函数，接下来就是处理 setup 函数的流程，主要是三个步骤：创建 setup 函数上下文、执行 setup 函数并获取结果和处理 setup 函数的执行结果。接下来我们就逐个来分析。</p><p>首先<strong>判断 setup 函数的参数长度</strong>，<strong>如果大于 1</strong>，<strong>则创建 setupContext 上下文</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setupContext = (instance.<span class="property">setupContext</span> =</span><br><span class="line">    setup.<span class="property">length</span> &gt; <span class="number">1</span> ? <span class="title function_">createSetupContext</span>(instance) : <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>举个例子，我们有个 HelloWorld 子组件，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>Toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">msg</span>: <span class="title class_">String</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    setup (props, &#123; emit &#125;) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">onClick</span> () &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">emit</span>(<span class="string">&#x27;toggle&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        onClick</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在父组件引用这个组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">HelloWorld</span> @<span class="attr">toggle</span>=<span class="string">&quot;toggle&quot;</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>: &#123; <span class="title class_">HelloWorld</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">    setup () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">toggle</span> () &#123;</span></span><br><span class="line"><span class="language-javascript">        msg.<span class="property">value</span> = msg.<span class="property">value</span> === <span class="string">&#x27;Hello World&#x27;</span> ? <span class="string">&#x27;Hello Vue&#x27;</span> : <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        toggle,</span></span><br><span class="line"><span class="language-javascript">        msg</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，HelloWorld 子组件的 setup 函数接收两个参数，第一个参数 props 对应父组件传入的 props 数据，第二个参数是一个对象，实际上就是 setupContext。</p><p>下面我们来看一下用 createSetupContext 函数来创建 setupContext：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSetupContext</span> (instance) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">attrs</span>: instance.<span class="property">attrs</span>,</span><br><span class="line">    <span class="attr">slots</span>: instance.<span class="property">slots</span>,</span><br><span class="line">    <span class="attr">emit</span>: instance.<span class="property">emit</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回了一个对象，包括 attrs、slots 和 emit 三个属性。setupContext 让我们在 setup 函数内部可以获取到组件的属性、插槽以及派发事件的方法 emit。</p><p>可以预见的是，这个 setupContext 对应的就是 setup 函数第二个参数，我们接下来看一下 setup 函数具体是如何执行的。</p><p>我们通过下面这行代码来<strong>执行 setup 函数并获取结果</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">setupResult</span> <span class="operator">=</span> callWithErrorHandling(setup, instance, <span class="number">0</span> <span class="comment">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])</span><br></pre></td></tr></table></figure><p>我们具体来看一下 callWithErrorHandling 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callWithErrorHandling</span> (fn, instance, type, args) &#123;</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = args ? <span class="title function_">fn</span>(...args) : <span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">handleError</span>(err, instance, type)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它其实就是对 fn 做的一层包装，内部还是执行了 fn，并在有参数的时候传入参数，所以 setup 的第一个参数是 instance.props，第二个参数是 setupContext。函数执行过程中如果有 JavaScript 执行错误就会捕获错误，并执行 handleError 函数来处理。</p><p>执行 setup 函数并拿到了返回的结果，那么接下来就要<strong>用 handleSetupResult 函数来处理结果</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleSetupResult</span>(instance, setupResult)</span><br></pre></td></tr></table></figure><p>我们详细看一下 handleSetupResult 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleSetupResult</span>(<span class="params">instance, setupResult</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isFunction</span>(setupResult)) &#123;</span><br><span class="line">    <span class="comment">// setup 返回渲染函数</span></span><br><span class="line">    instance.<span class="property">render</span> = setupResult</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isObject</span>(setupResult)) &#123;</span><br><span class="line">    <span class="comment">// 把 setup 返回结果变成响应式</span></span><br><span class="line">    instance.<span class="property">setupState</span> = <span class="title function_">reactive</span>(setupResult)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">finishComponentSetup</span>(instance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当 setupResult 是一个对象的时候，我们把它变成了响应式并赋值给 instance.setupState，这样在模板渲染的时候，依据前面的代理规则，instance.ctx 就可以从 instance.setupState 上获取到对应的数据，这就在 setup 函数与模板渲染间建立了联系。</p><p>另外 setup 不仅仅支持返回一个对象，也可以返回一个函数作为组件的渲染函数。我们可以改写前面的示例，来看一下这时的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="title class_">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    setup (props, &#123; emit &#125;) &#123;</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">onClick</span> () &#123;</span><br><span class="line">        <span class="title function_">emit</span>(<span class="string">&#x27;toggle&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, ctx.<span class="property">msg</span>),</span><br><span class="line">          <span class="title function_">h</span>(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">onClick</span>: onClick &#125;, <span class="string">&#x27;Toggle&#x27;</span>)</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里，我们删除了 HelloWorld 子组件的 template 部分，并把 setup 函数的返回结果改成了函数，也就是说它会作为组件的渲染函数，一切运行正常。</p><p>在 handleSetupResult 的最后，会执行 finishComponentSetup 函数完成组件实例的设置，其实这个函数和 setup 函数的执行结果已经没什么关系了，提取到外面放在 handleSetupResult 函数后面执行更合理一些。</p><p>另外当组件没有定义的 setup 的时候，也会执行 finishComponentSetup 函数去完成组件实例的设置。</p><h5 id="完成组件实例设置"><a href="#完成组件实例设置" class="headerlink" title="完成组件实例设置"></a>完成组件实例设置</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">finishComponentSetup</span> (instance) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Component</span> = instance.<span class="property">type</span></span><br><span class="line">  <span class="comment">// 对模板或者渲染函数的标准化</span></span><br><span class="line">  <span class="keyword">if</span> (!instance.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compile &amp;&amp; <span class="title class_">Component</span>.<span class="property">template</span> &amp;&amp; !<span class="title class_">Component</span>.<span class="property">render</span>) &#123;</span><br><span class="line">      <span class="comment">// 运行时编译</span></span><br><span class="line">      <span class="title class_">Component</span>.<span class="property">render</span> = <span class="title function_">compile</span>(<span class="title class_">Component</span>.<span class="property">template</span>, &#123;</span><br><span class="line">        <span class="attr">isCustomElement</span>: instance.<span class="property">appContext</span>.<span class="property">config</span>.<span class="property">isCustomElement</span> || <span class="variable constant_">NO</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="title class_">Component</span>.<span class="property">render</span>.<span class="property">_rc</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; !<span class="title class_">Component</span>.<span class="property">render</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!compile &amp;&amp; <span class="title class_">Component</span>.<span class="property">template</span>) &#123;</span><br><span class="line">        <span class="comment">// 只编写了 template 但使用了 runtime-only 的版本</span></span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Component provided template option but `</span> +</span><br><span class="line">          <span class="string">`runtime compilation is not supported in this build of Vue.`</span> +</span><br><span class="line">          (<span class="string">` Configure your bundler to alias &quot;vue&quot; to &quot;vue/dist/vue.esm-bundler.js&quot;.`</span></span><br><span class="line">          ) <span class="comment">/* should not happen */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 既没有写 render 函数，也没有写 template 模板</span></span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Component is missing template or render function.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组件对象的 render 函数赋值给 instance</span></span><br><span class="line">    instance.<span class="property">render</span> = (<span class="title class_">Component</span>.<span class="property">render</span> || <span class="variable constant_">NOOP</span>)</span><br><span class="line">    <span class="keyword">if</span> (instance.<span class="property">render</span>.<span class="property">_rc</span>) &#123;</span><br><span class="line">      <span class="comment">// 对于使用 with 块的运行时编译的渲染函数，使用新的渲染上下文的代理</span></span><br><span class="line">      instance.<span class="property">withProxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(instance.<span class="property">ctx</span>, <span class="title class_">RuntimeCompiledPublicInstanceProxyHandlers</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 兼容 Vue.js 2.x Options API</span></span><br><span class="line">  &#123;</span><br><span class="line">    currentInstance = instance</span><br><span class="line">    <span class="title function_">applyOptions</span>(instance, <span class="title class_">Component</span>)</span><br><span class="line">    currentInstance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数主要做了两件事情：<strong>标准化模板或者渲染函数和兼容 Options API</strong>。接下来我们详细分析这两个流程。</p><h6 id="标准化模板或者渲染函数"><a href="#标准化模板或者渲染函数" class="headerlink" title="标准化模板或者渲染函数"></a>标准化模板或者渲染函数</h6><p>在分析这个过程之前，我们需要了解一些背景知识。组件最终通过运行 render 函数生成子树 vnode，但是我们很少直接去编写 render 函数，通常会使用两种方式开发组件。</p><p><strong>第一种是使用 SFC（Single File Components）单文件的开发方式来开发组件</strong>，即通过编写组件的 template 模板去描述一个组件的 DOM 结构。我们知道 .vue 类型的文件无法在 Web 端直接加载，因此在 webpack 的编译阶段，它会通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分转换成 render 函数添加到组件对象的属性中。</p><p><strong>另外一种开发方式</strong>是不借助 webpack 编译，<strong>直接引入 Vue.js</strong>，开箱即用，我们直接在组件对象 template 属性中编写组件的模板，然后在运行阶段编译生成 render 函数，这种方式通常用于有一定历史包袱的古老项目。</p><p>因此 Vue.js 在 Web 端有两个版本：runtime-only 和 runtime-compiled。我们更推荐用 runtime-only 版本的 Vue.js，因为相对而言它体积更小，而且在运行时不用编译，不仅耗时更少而且性能更优秀。遇到一些不得已的情况比如上述提到的古老项目，我们也可以选择 runtime-compiled 版本。</p><p>runtime-only 和 runtime-compiled 的主要区别在于是否注册了这个 compile 方法。</p><p>在 Vue.js 3.0 中，compile 方法是通过外部注册的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compile;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">registerRuntimeCompiler</span>(<span class="params">_compile</span>) &#123;</span><br><span class="line">    compile = _compile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到标准化模板或者渲染函数逻辑，我们先看 instance.render 是否存在，如果不存在则开始标准化流程，这里主要需要处理以下三种情况。</p><ol><li><strong>compile 和组件 template 属性存在</strong>，<strong>render 方法不存在的情况</strong>。此时， runtime-compiled 版本会在 JavaScript 运行时进行模板编译，生成 render 函数。</li><li><strong>compile 和 render 方法不存在，组件 template 属性存在的情况</strong>。此时由于没有 compile，这里用的是 runtime-only 的版本，因此要报一个警告来告诉用户，想要运行时编译得使用 runtime-compiled 版本的 Vue.js。</li><li><strong>组件既没有写 render 函数，也没有写 template 模板</strong>，此时要报一个警告，告诉用户组件缺少了 render 函数或者 template 模板。</li></ol><p>处理完以上情况后，就要把组件的 render 函数赋值给 instance.render。到了组件渲染的时候，就可以运行 instance.render 函数生成组件的子树 vnode 了。</p><p>另外对于使用 with 块运行时编译的渲染函数，渲染上下文的代理是 RuntimeCompiledPublicInstanceProxyHandlers，它是在之前渲染上下文代理 PublicInstanceProxyHandlers 的基础上进行的扩展，主要对 has 函数的实现做了优化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">RuntimeCompiledPublicInstanceProxyHandlers</span> = &#123;</span><br><span class="line">  ...<span class="title class_">PublicInstanceProxyHandlers</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="title class_">Symbol</span>.<span class="property">unscopables</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">PublicInstanceProxyHandlers</span>.<span class="title function_">get</span>(target, key, target)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">_, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 key 以 _ 开头或者 key 在全局变量白名单内，则 has 为 false</span></span><br><span class="line">    <span class="keyword">const</span> has = key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span> &amp;&amp; !<span class="title function_">isGloballyWhitelisted</span>(key)</span><br><span class="line">    <span class="keyword">if</span> ((process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &amp;&amp; !has &amp;&amp; <span class="title class_">PublicInstanceProxyHandlers</span>.<span class="title function_">has</span>(_, key)) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(key)&#125;</span> should not start with _ which is a reserved prefix for Vue internals.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> has</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果 key 以 _ 开头，或者 key 在全局变量的白名单内，则 has 为 false，此时则直接命中警告，不用再进行之前那一系列的判断了。</p><p>了解完标准化模板或者渲染函数流程，我们来看完成组件实例设置的最后一个流程——兼容 Vue.js 2.x 的 Options API。</p><h6 id="Options-API：兼容-Vue-js-2-x"><a href="#Options-API：兼容-Vue-js-2-x" class="headerlink" title="Options API：兼容 Vue.js 2.x"></a>Options API：兼容 Vue.js 2.x</h6><p>我们知道 Vue.js 2.x 是通过组件对象的方式去描述一个组件，之前我们也说过，Vue.js 3.0 仍然支持 Vue.js 2.x Options API 的写法，这主要就是通过 applyOptions方法实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyOptions</span>(<span class="params">instance, options, deferredData = [], deferredWatch = [], asMixin = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// 组合</span></span><br><span class="line">    mixins, <span class="attr">extends</span>: extendsOptions,</span><br><span class="line">    <span class="comment">// 数组状态</span></span><br><span class="line">    <span class="attr">props</span>: propsOptions, <span class="attr">data</span>: dataOptions, <span class="attr">computed</span>: computedOptions, methods, <span class="attr">watch</span>: watchOptions, <span class="attr">provide</span>: provideOptions, <span class="attr">inject</span>: injectOptions,</span><br><span class="line">    <span class="comment">// 组件和指令</span></span><br><span class="line">    components, directives,</span><br><span class="line">    <span class="comment">// 生命周期</span></span><br><span class="line">    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured &#125; = options;</span><br><span class="line">  <span class="comment">// instance.proxy 作为 this</span></span><br><span class="line">  <span class="keyword">const</span> publicThis = instance.<span class="property">proxy</span>;</span><br><span class="line">  <span class="keyword">const</span> ctx = instance.<span class="property">ctx</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 处理全局 mixin</span></span><br><span class="line">  <span class="comment">// 处理 extend</span></span><br><span class="line">  <span class="comment">// 处理本地 mixins</span></span><br><span class="line">  <span class="comment">// props 已经在外面处理过了</span></span><br><span class="line">  <span class="comment">// 处理 inject</span></span><br><span class="line">  <span class="comment">// 处理 methods</span></span><br><span class="line">  <span class="comment">// 处理 data</span></span><br><span class="line">  <span class="comment">// 处理 computed</span></span><br><span class="line">  <span class="comment">// 处理 watch</span></span><br><span class="line">  <span class="comment">// 处理 provide</span></span><br><span class="line">  <span class="comment">// 处理组件</span></span><br><span class="line">  <span class="comment">// 处理指令</span></span><br><span class="line">  <span class="comment">// 处理生命周期 option</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 applyOptions 的代码特别长，所以这里我用注释列出了它主要做的事情，感兴趣的同学可以去翻阅它的源码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这节课我们主要分析了组件的初始化流程，主要包括创建组件实例和设置组件实例。通过进一步细节的深入，我们也了解了渲染上下文的代理过程；了解了 Composition API 中的 setup 启动函数执行的时机，以及如何建立 setup 返回结果和模板渲染之间的联系；了解了组件定义的模板或者渲染函数的标准化过程；了解了如何兼容 Vue.js 2.x 的 Options API。</p><p>我们通过一张图再直观感受一下 Vue.js 3.0 组件的初始化流程：</p><img src="/2022/06/29/vue3/setup/Ciqc1F8VZvaAYCgKAAHVSzimXjw614.png" class=""><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;component.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;componentProxy.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;errorHandling.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue.js 3.0 允许我们在编写组件的时候添加一个 setup 启动函数，它是 Composition API 逻辑组织的入口，我们这就来分析一下这个函数。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="setup" scheme="https://xiaozhouguo.github.io/tags/setup/"/>
    
  </entry>
  
  <entry>
    <title>完整的 DOM diff 流程下篇</title>
    <link href="https://xiaozhouguo.github.io/2022/06/28/vue3/dom-diff-process2/"/>
    <id>https://xiaozhouguo.github.io/2022/06/28/vue3/dom-diff-process2/</id>
    <published>2022-06-28T02:08:41.000Z</published>
    <updated>2022-07-26T07:46:43.984Z</updated>
    
    <content type="html"><![CDATA[<p>下面我们来继续讲解上节课提到的<strong>核心 diff 算法</strong>。</p><span id="more"></span><p>新子节点数组相对于旧子节点数组的变化，无非是通过更新、删除、添加和移动节点来完成，而核心 diff 算法，就是在已知旧子节点的 DOM 结构、vnode 和新子节点的 vnode 情况下，以较低的成本完成子节点的更新为目的，求解生成新子节点 DOM 的系列操作。</p><p>为了方便你理解，我先举个例子，假设有这样一个列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;d&quot;</span>&gt;</span>d<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们在中间插入一行，得到一个新列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;e&quot;</span>&gt;</span>e<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;d&quot;</span>&gt;</span>d<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在插入操作的前后，它们对应渲染生成的 vnode 可以用一张图表示：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8QHwmAHuQrAAB7807ZTzY864.png" class=""><p>从图中我们可以直观地感受到，差异主要在新子节点中的 b 节点后面多了一个 e 节点。</p><p>我们再把这个例子稍微修改一下，多添加一个 e 节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;d&quot;</span>&gt;</span>d<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;e&quot;</span>&gt;</span>e<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们删除中间一项，得到一个新列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;d&quot;</span>&gt;</span>d<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;e&quot;</span>&gt;</span>e<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在删除操作的前后，它们对应渲染生成的 vnode 可以用一张图表示：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxNCAbTueAABtqP8l5JI050.png" class=""><p>我们可以看到，这时差异主要在新子节点中的 b 节点后面少了一个 c 节点。</p><p>综合这两个例子，我们很容易发现新旧 children 拥有相同的头尾节点。对于相同的节点，我们只需要做对比更新即可，所以 diff 算法的第一步<strong>从头部开始同步</strong>。</p><h3 id="同步头部节点"><a href="#同步头部节点" class="headerlink" title="同步头部节点"></a>同步头部节点</h3><p>我们先来看一下头部节点同步的实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[i]</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="comment">// 相同的节点，递归执行 patch 更新节点</span></span><br><span class="line">      <span class="title function_">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个 diff 的过程，我们需要维护几个变量：头部的索引 i、旧子节点的尾部索引 e1和新子节点的尾部索引 e2。</p><p>同步头部节点就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。</p><p>我们拿第一个例子来说，通过下图看一下同步头部节点后的结果：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxN6AMzbfAACPna55Fmk255.png" class=""><p>可以看到，完成头部节点同步后：i 是 2，e1 是 3，e2 是 4。</p><h3 id="同步尾部节点"><a href="#同步尾部节点" class="headerlink" title="同步尾部节点"></a>同步尾部节点</h3><p>接着从尾部开始<strong>同步尾部节点</strong>，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1 = c1[e1]</span><br><span class="line">    <span class="keyword">const</span> n2 = c2[e2]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    e1--</span><br><span class="line">    e2--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。</p><p>我们来通过下图看一下同步尾部节点后的结果：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxO2AffFhAACJ52ATnwQ480.png" class=""><p>可以看到，完成尾部节点同步后：i 是 2，e1 是 1，e2 是 2。</p><p>接下来只有 3 种情况要处理：</p><ul><li>新子节点有剩余要添加的新节点；</li><li>旧子节点有剩余要删除的多余节点；</li><li>未知子序列。</li></ul><p>我们继续看一下具体是怎样操作的。</p><h3 id="添加新的节点"><a href="#添加新的节点" class="headerlink" title="添加新的节点"></a>添加新的节点</h3><p>首先要判断新子节点是否有剩余的情况，如果满足则添加新子节点，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) c d</span></span><br><span class="line">  <span class="comment">// (a b) e c d</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 3, e2 = 4</span></span><br><span class="line">  <span class="comment">// (a b) (c d)</span></span><br><span class="line">  <span class="comment">// (a b) e (c d)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 3. 挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 1, e2 = 2</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span></span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; l2 ? c2[nextPos].<span class="property">el</span> : parentAnchor</span><br><span class="line">      <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">        <span class="comment">// 挂载新节点</span></span><br><span class="line">        <span class="title function_">patch</span>(<span class="literal">null</span>, c2[i], container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class="line">        i++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果索引 i 大于尾部索引 e1 且 i 小于 e2，那么从索引 i 开始到索引 e2 之间，我们直接挂载新子树这部分的节点。</p><p>对我们的例子而言，同步完尾部节点后 i 是 2，e1 是 1，e2 是 2，此时满足条件需要添加新的节点，我们来通过下图看一下添加后的结果：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8OxQKAd7fjAACNTHXEkuQ335.png" class=""><p>添加完 e 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。</p><h3 id="删除多余节点"><a href="#删除多余节点" class="headerlink" title="删除多余节点"></a>删除多余节点</h3><p>如果不满足添加新节点的情况，我就要接着判断旧子节点是否有剩余，如果满足则删除旧子节点，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c d e</span></span><br><span class="line">  <span class="comment">// (a b) d e</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 4, e2 = 3</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="comment">// 不满足</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 2, e2 = 1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">      <span class="comment">// 删除节点</span></span><br><span class="line">      <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果索引 i 大于尾部索引 e2，那么从索引 i 开始到索引 e1 之间，我们直接删除旧子树这部分的节点。</p><p>第二个例子是就删除节点的情况，我们从同步头部节点开始，用图的方式演示这一过程。</p><p>首先从头部同步节点：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxQ-ADmRcAACCSIpni8Y429.png" class=""><p>此时的结果：i 是 2，e1 是 4，e2 是 3。</p><p>接着从尾部同步节点：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxRqANXzyAACGFb9dacI061.png" class=""><p>此时的结果：i 是 2，e1 是 2，e2 是 1，满足删除条件，因此删除子节点中的多余节点：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8OxSeAMW8gAACCvYcKESo055.png" class=""><p>删除完 c 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。</p><h3 id="处理未知子序列"><a href="#处理未知子序列" class="headerlink" title="处理未知子序列"></a>处理未知子序列</h3><p>单纯的添加和删除节点都是比较理想的情况，操作起来也很容易，但是有些时候并非这么幸运，我们会遇到比较复杂的未知子序列，这时候 diff 算法会怎么做呢？</p><p>我们再通过例子来演示存在未知子序列的情况，假设一个按照字母表排列的列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;d&quot;</span>&gt;</span>d<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;e&quot;</span>&gt;</span>e<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;f&quot;</span>&gt;</span>f<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;g&quot;</span>&gt;</span>g<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;h&quot;</span>&gt;</span>h<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们打乱之前的顺序得到一个新列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;e&quot;</span>&gt;</span>e<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;d&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;c&quot;</span>&gt;</span>d<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;i&quot;</span>&gt;</span>i<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;g&quot;</span>&gt;</span>g<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;h&quot;</span>&gt;</span>h<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在操作前，它们对应渲染生成的 vnode 可以用一张图表示：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxT6AVycJAAClkNghf-k681.png" class=""><p>我们还是从同步头部节点开始，用图的方式演示这一过程。</p><p>首先从头部同步节点：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8OxUyAaCXvAAC6Lv79hSs090.png" class=""><p>同步头部节点后的结果：i 是 2，e1 是 7，e2 是 7。</p><p>接着从尾部同步节点：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxVeAYV_ZAADCIt6XIHI609.png" class=""><p>同步尾部节点后的结果：i 是 2，e1 是 5，e2 是 5。可以看到它既不满足添加新节点的条件，也不满足删除旧节点的条件。那么对于这种情况，我们应该怎么处理呢？</p><p>结合上图可以知道，要把旧子节点的 c、d、e、f 转变成新子节点的 e、c、d、i。从直观上看，我们把 e 节点移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点即可。</p><p>其实无论多复杂的情况，最终无非都是通过更新、删除、添加、移动这些动作来操作节点，而我们要做的就是找到相对优的解。</p><p>当两个节点类型相同时，我们执行更新操作；当新子节点中没有旧子节点中的某些节点时，我们执行删除操作；当新子节点中多了旧子节点中没有的节点时，我们执行添加操作，这些操作我们在前面已经阐述清楚了。相对来说这些操作中最麻烦的就是移动，我们既要判断哪些节点需要移动也要清楚如何移动。</p><h4 id="移动子节点"><a href="#移动子节点" class="headerlink" title="移动子节点"></a>移动子节点</h4><p>那么什么时候需要移动呢，就是当子节点排列顺序发生变化的时候，举个简单的例子具体看一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> prev = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> next = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>可以看到，从 prev 变成 next，数组里的一些元素的顺序发生了变化，我们可以把子节点类比为元素，现在问题就简化为我们如何用最少的移动使元素顺序从 prev 变化为 next 。</p><p>一种思路是在 next 中找到一个递增子序列，比如 [1, 3, 6] 、[1, 2, 4, 5]。之后对 next 数组进行倒序遍历，移动所有不在递增序列中的元素即可。</p><p>如果选择了 [1, 3, 6] 作为递增子序列，那么在倒序遍历的过程中，遇到 6、3、1 不动，遇到 5、4、2 移动即可，从<code>prev</code> -&gt; <code>next</code> 子节点移动如下图所示：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8OxWOAKRnGAAAzjDtkQJI201.png" class=""><p>如果选择了 [1, 2, 4, 5] 作为递增子序列，那么在倒序遍历的过程中，遇到 5、4、2、1 不动，遇到 6、3 移动即可，如下图所示：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8OxW6APB5gAAAshOjdgMY518.png" class=""><p>可以看到从第一种移动了三次，而第二种只移动了两次，递增子序列越长，所需要移动元素的次数越少，所以如何移动的问题就回到了求解<code>最长递增子序列</code>的问题。我们稍后会详细讲求解最长递增子序列的算法，所以先回到我们这里的问题，对未知子序列的处理。</p><blockquote><p>我们现在要做的是在新旧子节点序列中找出相同节点并更新，找出多余的节点删除，找出新的节点添加，找出是否有需要移动的节点，如果有该如何移动。</p></blockquote><p>在查找过程中需要对比新旧子序列，那么我们就要遍历某个序列，如果在遍历旧子序列的过程中需要判断某个节点是否在新子序列中存在，这就需要双重循环，而双重循环的复杂度是 O(n2) ，为了优化这个复杂度，我们可以用一种空间换时间的思路，建立索引图，把时间复杂度降低到 O(n)。</p><h4 id="建立索引图"><a href="#建立索引图" class="headerlink" title="建立索引图"></a>建立索引图</h4><p>所以处理未知子序列的第一步，就是建立索引图。</p><blockquote><p>通常我们在开发过程中， 会给 v-for 生成的列表中的每一项分配唯一 key 作为项的唯一 ID，这个 key 在 diff 过程中起到很关键的作用。对于新旧子序列中的节点，我们认为 key 相同的就是同一个节点，直接执行 patch 更新即可。</p></blockquote><p>我们根据 key 建立新子序列的索引图，实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 5, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i</span><br><span class="line">  <span class="comment">// 新子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="keyword">const</span> keyToNewIndexMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[i]</span><br><span class="line">    keyToNewIndexMap.<span class="title function_">set</span>(nextChild.<span class="property">key</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新旧子序列是从 i 开始的，所以我们先用 s1、s2 分别作为新旧子序列的开始索引，接着建立一个 <code>keyToNewIndexMap</code> 的 <code>Map&lt;key, index&gt;</code> 结构，遍历新子序列，把节点的 key 和 index 添加到这个 Map 中，注意我们这里假设所有节点都是有 key 标识的。</p><p><code>keyToNewIndexMap</code> 存储的就是新子序列中每个节点在新子序列中的索引，我们来看一下示例处理后的结果，如下图所示：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8OxciAQJ6GAADhf7zD47s944.png" class=""><p>我们得到了一个值为 {e:2,c:3,d:4,i:5} 的新子序列索引图。</p><h4 id="更新和移除旧节点"><a href="#更新和移除旧节点" class="headerlink" title="更新和移除旧节点"></a>更新和移除旧节点</h4><p>接下来，我们就需要遍历旧子序列，有相同的节点就通过 patch 更新，并且移除那些不在新子序列中的节点，同时找出是否有需要移动的节点，我们来看一下这部分逻辑的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g h</span></span><br><span class="line">  <span class="comment">// (a b) e c d i g h</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 7, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f (g h)</span></span><br><span class="line">  <span class="comment">// (a b) e c d i (g h)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点，不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的旧节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 5, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i</span><br><span class="line">  <span class="comment">// 新子序列开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i</span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 新子序列已更新节点的数量</span></span><br><span class="line">  <span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 新子序列待更新节点的数量，等于新子序列的长度</span></span><br><span class="line">  <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span></span><br><span class="line">  <span class="comment">// 是否存在要移动的节点</span></span><br><span class="line">  <span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 用于跟踪判断是否有节点移动</span></span><br><span class="line">  <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 这个数组存储新子序列中的元素在旧子序列节点的索引，用于确定最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)</span><br><span class="line">  <span class="comment">// 初始化数组，每个元素的值都是 0</span></span><br><span class="line">  <span class="comment">// 0 是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明这个新节点没有对应的旧节点</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++)</span><br><span class="line">    newIndexToOldIndexMap[i] = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 正序遍历旧子序列</span></span><br><span class="line">  <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">    <span class="comment">// 拿到每一个旧子序列节点</span></span><br><span class="line">    <span class="keyword">const</span> prevChild = c1[i]</span><br><span class="line">    <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">      <span class="comment">// 所有新的子序列节点都已经更新，剩余的节点删除</span></span><br><span class="line">      <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找旧子序列中的节点在新子序列中的索引</span></span><br><span class="line">    <span class="keyword">let</span> newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)</span><br><span class="line">    <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 找不到说明旧子序列已经不存在于新子序列中，则删除该节点</span></span><br><span class="line">      <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新新子序列中的元素在旧子序列中的索引，这里加 1 偏移，是为了避免 i 为 0 的特殊情况，影响对后续最长递增子序列的求解</span></span><br><span class="line">      newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line">      <span class="comment">// maxNewIndexSoFar 始终存储的是上次求值的 newIndex，如果不是一直递增，则说明有移动</span></span><br><span class="line">      <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">        maxNewIndexSoFar = newIndex</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        moved = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新新旧子序列中匹配的节点</span></span><br><span class="line">      <span class="title function_">patch</span>(prevChild, c2[newIndex], container, <span class="literal">null</span>, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      patched++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们建立了一个 newIndexToOldIndexMap 的数组，来存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，用于确定最长递增子序列，这个数组的长度为新子序列的长度，每个元素的初始值设为 0， 它是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明遍历旧子序列的过程中没有处理过这个节点，这个节点是新添加的。</p><p>下面我们说说具体的操作过程：正序遍历旧子序列，根据前面建立的 keyToNewIndexMap 查找旧子序列中的节点在新子序列中的索引，如果找不到就说明新子序列中没有该节点，就删除它；如果找得到则将它在旧子序列中的索引更新到 newIndexToOldIndexMap 中。</p><p>注意这里索引加了长度为 1 的偏移，是为了应对 i 为 0 的特殊情况，如果不这样处理就会影响后续求解最长递增子序列。</p><p>遍历过程中，我们用变量 maxNewIndexSoFar 跟踪判断节点是否移动，maxNewIndexSoFar 始终存储的是上次求值的 newIndex，一旦本次求值的 newIndex 小于 maxNewIndexSoFar，这说明顺序遍历旧子序列的节点在新子序列中的索引并不是一直递增的，也就说明存在移动的情况。</p><p>除此之外，这个过程中我们也会更新新旧子序列中匹配的节点，另外如果所有新的子序列节点都已经更新，而对旧子序列遍历还未结束，说明剩余的节点就是多余的，删除即可。</p><p>至此，我们完成了新旧子序列节点的更新、多余旧节点的删除，并且建立了一个 newIndexToOldIndexMap 存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，并确定是否有移动。</p><p>我们来看一下示例处理后的结果，如下图所示：</p><img src="/2022/06/28/vue3/dom-diff-process2/CgqCHl8OxdeAVdPEAAEh9JAOZ_E654.png" class=""><p>可以看到， c、d、e 节点被更新，f 节点被删除，newIndexToOldIndexMap 的值为 [5, 3, 4 ,0]，此时 moved 也为 true，也就是存在节点移动的情况。</p><h4 id="移动和挂载新节点"><a href="#移动和挂载新节点" class="headerlink" title="移动和挂载新节点"></a>移动和挂载新节点</h4><p>接下来，就到了处理未知子序列的最后一个流程，移动和挂载新节点，我们来看一下这部分逻辑的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchKeyedChildren</span> = (<span class="params">c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> l2 = c2.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 旧子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e1 = c1.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 新子节点的尾部索引</span></span><br><span class="line">  <span class="keyword">let</span> e2 = l2 - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 1. 从头部开始同步</span></span><br><span class="line">  <span class="comment">// i = 0, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c d e f g</span></span><br><span class="line">  <span class="comment">// (a b) e c d h f g</span></span><br><span class="line">  <span class="comment">// 2. 从尾部开始同步</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 6, e2 = 7</span></span><br><span class="line">  <span class="comment">// (a b) c (d e)</span></span><br><span class="line">  <span class="comment">// (a b) (d e)</span></span><br><span class="line">  <span class="comment">// 3. 普通序列挂载剩余的新节点， 不满足</span></span><br><span class="line">  <span class="comment">// 4. 普通序列删除多余的节点，不满足</span></span><br><span class="line">  <span class="comment">// i = 2, e1 = 5, e2 = 5</span></span><br><span class="line">  <span class="comment">// 旧子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s1 = i</span><br><span class="line">  <span class="comment">// 新子节点开始索引，从 i 开始记录</span></span><br><span class="line">  <span class="keyword">const</span> s2 = i <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 5.1 根据 key 建立新子序列的索引图</span></span><br><span class="line">  <span class="comment">// 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点</span></span><br><span class="line">  <span class="comment">// 5.3 移动和挂载新节点</span></span><br><span class="line">  <span class="comment">// 仅当节点移动时生成最长递增子序列</span></span><br><span class="line">  <span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">    ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)</span><br><span class="line">    : <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">  <span class="keyword">let</span> j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 倒序遍历以便我们可以使用最后更新的节点作为锚点</span></span><br><span class="line">  <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextIndex = s2 + i</span><br><span class="line">    <span class="keyword">const</span> nextChild = c2[nextIndex]</span><br><span class="line">    <span class="comment">// 锚点指向上一个更新的节点，如果 nextIndex 超过新子节点的长度，则指向 parentAnchor</span></span><br><span class="line">    <span class="keyword">const</span> anchor = nextIndex + <span class="number">1</span> &lt; l2 ? c2[nextIndex + <span class="number">1</span>].<span class="property">el</span> : parentAnchor</span><br><span class="line">    <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 挂载新的子节点</span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, nextChild, container, anchor, parentComponent, parentSuspense, isSVG)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">      <span class="comment">// 没有最长递增子序列（reverse 的场景）或者当前的节点索引不在最长递增子序列中，需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">        <span class="title function_">move</span>(nextChild, container, anchor, <span class="number">2</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 倒序递增子序列</span></span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面已经判断了是否移动，如果 moved 为 true 就通过 getSequence(newIndexToOldIndexMap) 计算最长递增子序列，这部分算法我会放在后文详细介绍。</p><p>接着我们采用倒序的方式遍历新子序列，因为倒序遍历可以方便我们使用最后更新的节点作为锚点。在倒序的过程中，锚点指向上一个更新的节点，然后判断 newIndexToOldIndexMap[i] 是否为 0，如果是则表示这是新节点，就需要挂载它；接着判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果在则倒序最长递增子序列，否则把它移动到锚点的前面。</p><p>为了便于你更直观地理解，我们用前面的例子展示一下这个过程，此时 toBePatched 的值为 4，j 的值为 1，最长递增子序列 increasingNewIndexSequence 的值是 [1, 2]。在倒序新子序列的过程中，首先遇到节点 i，发现它在 newIndexToOldIndexMap 中的值是 0，则说明它是新节点，我们需要挂载它；然后继续遍历遇到节点 d，因为 moved 为 true，且 d 的索引存在于最长递增子序列中，则执行 j– 倒序最长递增子序列，j 此时为 0；接着继续遍历遇到节点 c，它和 d 一样，索引也存在于最长递增子序列中，则执行 j–，j 此时为 -1；接着继续遍历遇到节点 e，此时 j 是 -1 并且 e 的索引也不在最长递增子序列中，所以做一次移动操作，把 e 节点移到上一个更新的节点，也就是 c 节点的前面。</p><p>新子序列倒序完成，即完成了新节点的插入和旧节点的移动操作，也就完成了整个核心 diff 算法对节点的更新。</p><p>我们来看一下示例处理后的结果，如下图所示：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxeiAIp0WAAFBcsdATCI981.png" class=""><p>可以看到新子序列中的新节点 i 被挂载，旧子序列中的节点 e 移动到了 c 节点前面，至此，我们就在已知旧子节点 DOM 结构和 vnode、新子节点 vnode 的情况下，求解出生成新子节点的 DOM 的更新、移动、删除、新增等系列操作，并且以一种较小成本的方式完成 DOM 更新。</p><p>我们知道了子节点更新调用的是 patch 方法， Vue.js 正是通过这种递归的方式完成了整个组件树的更新。</p><p>核心 diff 算法中最复杂就是求解最长递增子序列，下面我们再来详细学习一下这个算法。</p><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><p>求解最长递增子序列是一道经典的算法题，多数解法是使用动态规划的思想，算法的时间复杂度是 O(n^2)，而 Vue.js 内部使用的是维基百科提供的一套“贪心 + 二分查找”的算法，贪心算法的时间复杂度是 O(n)，二分查找的时间复杂度是 O(logn)，所以它的总时间复杂度是 O(nlogn)。</p><p>单纯地看代码并不好理解，我们用示例来看一下这个子序列的求解过程。</p><p>假设我们有这个样一个数组 arr：[2, 1, 5, 3, 6, 4, 8, 9, 7]，求解它最长递增子序列的步骤如下：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8O342ATpU7AMfwii64x74028.gif" class=""><p>最终求得最长递增子序列的值就是 [1, 3, 4, 8, 9]。</p><p>通过演示我们可以得到这个算法的主要思路：对数组遍历，依次求解长度为 i 时的最长递增子序列，当 i 元素大于 i - 1 的元素时，添加 i 元素并更新最长子序列；否则往前查找直到找到一个比 i 小的元素，然后插在该元素后面并更新对应的最长递增子序列。</p><p>这种做法的主要目的是让递增序列的差尽可能的小，从而可以获得更长的递增子序列，这便是一种贪心算法的思想。</p><p>了解了算法的大致思想后，接下来我们看一下源码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSequence</span> (arr) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = arr.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">const</span> result = [<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> i, j, u, v, c</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> arrI = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">      j = result[result.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class="line">        <span class="comment">// 存储在 result 更新前的最后一个索引的值</span></span><br><span class="line">        p[i] = j</span><br><span class="line">        result.<span class="title function_">push</span>(i)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      u = <span class="number">0</span></span><br><span class="line">      v = result.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="comment">// 二分搜索，查找比 arrI 小的节点，更新 result 的值</span></span><br><span class="line">      <span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line">        c = ((u + v) / <span class="number">2</span>) | <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">          u = c + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          v = c</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          p[i] = result[u - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        result[u] = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  u = result.<span class="property">length</span></span><br><span class="line">  v = result[u - <span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 回溯数组 p，找到最终的索引</span></span><br><span class="line">  <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   result[u] = v</span><br><span class="line">   v = p[v] </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 result 存储的是长度为 i 的递增子序列最小末尾值的索引。比如我们上述例子的第九步，在对数组 p 回溯之前， result 值就是 [1, 3, 4, 7, 9] ，这不是最长递增子序列，它只是存储的对应长度递增子序列的最小末尾。因此在整个遍历过程中会额外用一个数组 p，来存储在每次更新 result 前最后一个索引的值，并且它的 key 是这次要更新的 result 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">j = result[result.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">p[i] = j</span><br><span class="line">result.<span class="title function_">push</span>(i)</span><br></pre></td></tr></table></figure><p>可以看到，result 添加的新值 i 是作为 p 存储 result 最后一个值 j 的 key。上述例子遍历后 p 的结果如图所示：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OxgOALDcQAABERFRRNqo370.png" class=""><p>从 result 最后一个元素 9 对应的索引 7 开始回溯，可以看到 p[7] &#x3D; 6，p[6] &#x3D; 5，p[5] &#x3D; 3，p[3] &#x3D; 1，所以通过对 p 的回溯，得到最终的 result 值是 [1, 3 ,5 ,6 ,7]，也就找到最长递增子序列的最终索引了。这里要注意，我们求解的是最长子序列索引值，它的每个元素其实对应的是数组的下标。对于我们的例子而言，[2, 1, 5, 3, 6, 4, 8, 9, 7] 的最长子序列是 [1, 3, 4, 8, 9]，而我们求解的 [1, 3 ,5 ,6 ,7] 就是最长子序列中元素在原数组中的下标所构成的新数组。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这两节课我们主要分析了组件的更新流程，知道了 Vue.js 的更新粒度是组件级别的，并且 Vue.js 在 patch 某个组件的时候，如果遇到组件这类抽象节点，在某些条件下也会触发子组件的更新。</p><p>对于普通元素节点的更新，主要是更新一些属性，以及它的子节点。子节点的更新又分为多种情况，其中最复杂的情况为数组到数组的更新，内部又根据不同情况分成几个流程去 diff，遇到需要移动的情况还要去求解子节点的最长递增子序列。</p><p>整个更新过程还是利用了树的深度遍历，递归执行 patch 方法，最终完成了整个组件树的更新。</p><p>下面，我们通过一张图来更加直观感受组件的更新流程：</p><img src="/2022/06/28/vue3/dom-diff-process2/Ciqc1F8OyzuASuJ7AAHSjr5SVlc999.png" class=""><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;下面我们来继续讲解上节课提到的&lt;strong&gt;核心 diff 算法&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="DOM-diff" scheme="https://xiaozhouguo.github.io/tags/DOM-diff/"/>
    
  </entry>
  
  <entry>
    <title>完整的 DOM diff 流程上篇</title>
    <link href="https://xiaozhouguo.github.io/2022/06/27/vue3/dom-diff-process1/"/>
    <id>https://xiaozhouguo.github.io/2022/06/27/vue3/dom-diff-process1/</id>
    <published>2022-06-27T01:36:20.000Z</published>
    <updated>2022-07-26T07:40:13.337Z</updated>
    
    <content type="html"><![CDATA[<p>上一节课我们梳理了组件渲染的过程，本质上就是把各种类型的 vnode 渲染成真实 DOM。我们也知道了组件是由模板、组件描述对象和数据构成的，数据的变化会影响组件的变化。组件的渲染过程中创建了一个带副作用的渲染函数，当数据变化的时候就会执行这个渲染函数来触发组件的更新。那么接下来，我们就具体分析一下组件的更新过程。</p><span id="more"></span><h3 id="副作用渲染函数更新组件的过程"><a href="#副作用渲染函数更新组件的过程" class="headerlink" title="副作用渲染函数更新组件的过程"></a>副作用渲染函数更新组件的过程</h3><p>我们先来回顾一下带副作用渲染函数 <code>setupRenderEffect</code> 的实现，但是这次我们要重点关注更新组件部分的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setupRenderEffect</span> = (<span class="params">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数</span></span><br><span class="line">  instance.<span class="property">update</span> = <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">componentEffect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123;</span><br><span class="line">      <span class="comment">// 渲染组件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新组件</span></span><br><span class="line">      <span class="keyword">let</span> &#123; next, vnode &#125; = instance</span><br><span class="line">      <span class="comment">// next 表示新的组件 vnode</span></span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">        <span class="title function_">updateComponentPreRender</span>(instance, next, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        next = vnode</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 渲染新的子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> nextTree = <span class="title function_">renderComponentRoot</span>(instance)</span><br><span class="line">      <span class="comment">// 缓存旧的子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> prevTree = instance.<span class="property">subTree</span></span><br><span class="line">      <span class="comment">// 更新子树 vnode</span></span><br><span class="line">      instance.<span class="property">subTree</span> = nextTree</span><br><span class="line">      <span class="comment">// 组件更新核心逻辑，根据新旧子树 vnode 做 patch</span></span><br><span class="line">      <span class="title function_">patch</span>(prevTree, nextTree,</span><br><span class="line">        <span class="comment">// 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点</span></span><br><span class="line">        <span class="title function_">hostParentNode</span>(prevTree.<span class="property">el</span>),</span><br><span class="line">        <span class="comment">// 参考节点在 fragment 的情况可能改变，所以直接找旧树 DOM 元素的下一个节点</span></span><br><span class="line">        <span class="title function_">getNextHostNode</span>(prevTree),</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG)</span><br><span class="line">      <span class="comment">// 缓存更新后的 DOM 节点</span></span><br><span class="line">      next.<span class="property">el</span> = nextTree.<span class="property">el</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prodEffectOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，更新组件主要做三件事情：<strong>更新组件 vnode 节点、渲染新的子树 vnode、根据新旧子树 vnode 执行 patch 逻辑</strong>。</p><p>首先是更新组件 vnode 节点，这里会有一个条件判断，判断组件实例中是否有新的组件 vnode（用 next 表示），有则更新组件 vnode，没有 next 指向之前的组件 vnode。为什么需要判断，这其实涉及一个组件更新策略的逻辑，我们稍后会讲。</p><p>接着是渲染新的子树 vnode，因为数据发生了变化，模板又和数据相关，所以渲染生成的子树 vnode 也会发生相应的变化。</p><p>最后就是<strong>核心的 patch 逻辑</strong>，用来找出新旧子树 vnode 的不同，并找到一种合适的方式更新 DOM，接下来我们就来分析这个过程。</p><h3 id="核心逻辑：patch-流程"><a href="#核心逻辑：patch-流程" class="headerlink" title="核心逻辑：patch 流程"></a>核心逻辑：patch 流程</h3><p>我们先来看 patch 流程的实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2, container, anchor = <span class="literal">null</span>, parentComponent = <span class="literal">null</span>, parentSuspense = <span class="literal">null</span>, isSVG = <span class="literal">false</span>, optimized = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; !<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    anchor = <span class="title function_">getNextHostNode</span>(n1)</span><br><span class="line">    <span class="title function_">unmount</span>(n1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// n1 设置为 null 保证后续都走 mount 逻辑</span></span><br><span class="line">    n1 = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, shapeFlag &#125; = n2</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Text</span>:</span><br><span class="line">      <span class="comment">// 处理文本节点</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Comment</span>:</span><br><span class="line">      <span class="comment">// 处理注释节点</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Static</span>:</span><br><span class="line">      <span class="comment">// 处理静态节点</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">      <span class="comment">// 处理 Fragment 元素</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">        <span class="title function_">processElement</span>(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">6</span> <span class="comment">/* COMPONENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理组件</span></span><br><span class="line">        <span class="title function_">processComponent</span>(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">64</span> <span class="comment">/* TELEPORT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 TELEPORT</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">128</span> <span class="comment">/* SUSPENSE */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSameVNodeType</span> (n1, n2) &#123;</span><br><span class="line">  <span class="comment">// n1 和 n2 节点的 type 和 key 都相同，才是相同节点</span></span><br><span class="line">  <span class="keyword">return</span> n1.<span class="property">type</span> === n2.<span class="property">type</span> &amp;&amp; n1.<span class="property">key</span> === n2.<span class="property">key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中，首先判断新旧节点是否是相同的 vnode 类型，如果不同，比如一个 div 更新成一个 ul，那么最简单的操作就是删除旧的 div 节点，再去挂载新的 ul 节点。</p><p>如果是相同的 vnode 类型，就需要走 diff 更新流程了，接着会根据不同的 vnode 类型执行不同的处理逻辑，这里我们仍然只分析普通元素类型和组件类型的处理过程。</p><h5 id="1-处理组件"><a href="#1-处理组件" class="headerlink" title="1. 处理组件"></a>1. 处理组件</h5><p>如何<strong>处理组件</strong>的呢？举个例子，我们在父组件 App 中里引入了 Hello 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an app.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span> <span class="attr">:msg</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span>Toggle msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;Vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">toggle</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="variable language_">this</span>.<span class="property">msg</span> ==== <span class="string">&#x27;Vue&#x27;</span>? <span class="string">&#x27;World&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hello 组件中是 <code>&lt;div&gt;</code> 包裹着一个 <code>&lt;p&gt;</code> 标签， 如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">msg</span>: <span class="title class_">String</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击 App 组件中的按钮执行 toggle 函数，就会修改 data 中的 msg，并且会触发App 组件的重新渲染。</p><p>结合前面对渲染函数的流程分析，这里 App 组件的根节点是 div 标签，重新渲染的子树 vnode 节点是一个普通元素的 vnode，应该先走 processElement 逻辑。组件的更新最终还是要转换成内部真实 DOM 的更新，而实际上普通元素的处理流程才是真正做 DOM 的更新，由于稍后我们会详细分析普通元素的处理流程，所以我们先跳过这里，继续往下看。</p><p>和渲染过程类似，更新过程也是一个树的深度优先遍历过程，更新完当前节点后，就会遍历更新它的子节点，因此在遍历的过程中会遇到 hello 这个组件 vnode 节点，就会执行到 processComponent 处理逻辑中，我们再来看一下它的实现，我们重点关注一下组件更新的相关逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processComponent</span> = (<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新子组件</span></span><br><span class="line">    <span class="title function_">updateComponent</span>(n1, n2, parentComponent, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">updateComponent</span> = (<span class="params">n1, n2, parentComponent, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = (n2.<span class="property">component</span> = n1.<span class="property">component</span>)</span><br><span class="line">  <span class="comment">// 根据新旧子组件 vnode 判断是否需要更新子组件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">shouldUpdateComponent</span>(n1, n2, parentComponent, optimized)) &#123;</span><br><span class="line">    <span class="comment">// 新的子组件 vnode 赋值给 instance.next</span></span><br><span class="line">    instance.<span class="property">next</span> = n2</span><br><span class="line">    <span class="comment">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span></span><br><span class="line">    <span class="title function_">invalidateJob</span>(instance.<span class="property">update</span>)</span><br><span class="line">    <span class="comment">// 执行子组件的副作用渲染函数</span></span><br><span class="line">    instance.<span class="title function_">update</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要更新，只复制属性</span></span><br><span class="line">    n2.<span class="property">component</span> = n1.<span class="property">component</span></span><br><span class="line">    n2.<span class="property">el</span> = n1.<span class="property">el</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，processComponent 主要通过执行 updateComponent 函数来更新子组件，updateComponent 函数在更新子组件的时候，会先执行 shouldUpdateComponent 函数，根据新旧子组件 vnode 来判断是否需要更新子组件。这里你只需要知道，在 shouldUpdateComponent 函数的内部，主要是通过检测和对比组件 vnode 中的 props、chidren、dirs、transiton 等属性，来决定子组件是否需要更新。</p><p>这是很好理解的，因为在一个组件的子组件是否需要更新，我们主要依据子组件 vnode 是否存在一些会影响组件更新的属性变化进行判断，如果存在就会更新子组件。</p><p>虽然 Vue.js 的更新粒度是组件级别的，组件的数据变化只会影响当前组件的更新，但是在组件更新的过程中，也会对子组件做一定的检查，判断子组件是否也要更新，并通过某种机制避免子组件重复更新。</p><p>我们接着看 updateComponent 函数，如果 shouldUpdateComponent 返回 true ，那么在它的最后，先执行 invalidateJob（instance.update）避免子组件由于自身数据变化导致的重复更新，然后又执行了子组件的副作用渲染函数 instance.update 来主动触发子组件的更新。</p><p>再回到副作用渲染函数中，有了前面的讲解，我们再看组件更新的这部分代码，就能很好地理解它的逻辑了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新组件</span></span><br><span class="line"><span class="keyword">let</span> &#123; next, vnode &#125; = instance</span><br><span class="line"><span class="comment">// next 表示新的组件 vnode</span></span><br><span class="line"><span class="keyword">if</span> (next) &#123;</span><br><span class="line">  <span class="comment">// 更新组件 vnode 节点信息</span></span><br><span class="line">  <span class="title function_">updateComponentPreRender</span>(instance, next, optimized)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  next = vnode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">updateComponentPreRender</span> = (<span class="params">instance, nextVNode, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 新组件 vnode 的 component 属性指向组件实例</span></span><br><span class="line">  nextVNode.<span class="property">component</span> = instance</span><br><span class="line">  <span class="comment">// 旧组件 vnode 的 props 属性</span></span><br><span class="line">  <span class="keyword">const</span> prevProps = instance.<span class="property">vnode</span>.<span class="property">props</span></span><br><span class="line">  <span class="comment">// 组件实例的 vnode 属性指向新的组件 vnode</span></span><br><span class="line">  instance.<span class="property">vnode</span> = nextVNode</span><br><span class="line">  <span class="comment">// 清空 next 属性，为了下一次重新渲染准备</span></span><br><span class="line">  instance.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  <span class="title function_">updateProps</span>(instance, nextVNode.<span class="property">props</span>, prevProps, optimized)</span><br><span class="line">  <span class="comment">// 更新 插槽</span></span><br><span class="line">  <span class="title function_">updateSlots</span>(instance, nextVNode.<span class="property">children</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的代码，我们在更新组件的 DOM 前，需要先更新组件 vnode 节点信息，包括更改组件实例的 vnode 指针、更新 props 和更新插槽等一系列操作，因为组件在稍后执行 renderComponentRoot 时会重新渲染新的子树 vnode ，它依赖了更新后的组件 vnode 中的 props 和 slots 等数据。</p><p>所以我们现在知道了一个组件重新渲染可能会有两种场景，一种是组件本身的数据变化，这种情况下 next 是 null；另一种是父组件在更新的过程中，遇到子组件节点，先判断子组件是否需要更新，如果需要则主动执行子组件的重新渲染方法，这种情况下 next 就是新的子组件 vnode。</p><p>你可能还会有疑问，这个子组件对应的新的组件 vnode 是什么时候创建的呢？答案很简单，它是在父组件重新渲染的过程中，通过 renderComponentRoot 渲染子树 vnode 的时候生成，因为子树 vnode 是个树形结构，通过遍历它的子节点就可以访问到其对应的组件 vnode。再拿我们前面举的例子说，当 App 组件重新渲染的时候，在执行 renderComponentRoot 生成子树 vnode 的过程中，也生成了 hello 组件对应的新的组件 vnode。</p><p>所以 processComponent 处理组件 vnode，本质上就是去判断子组件是否需要更新，如果需要则递归执行子组件的副作用渲染函数来更新，否则仅仅更新一些 vnode 的属性，并让子组件实例保留对组件 vnode 的引用，用于子组件自身数据变化引起组件重新渲染的时候，在渲染函数内部可以拿到新的组件 vnode。</p><p>前面也说过，组件是抽象的，组件的更新最终还是会落到对普通 DOM 元素的更新。所以接下来我们详细分析一下组件更新中<strong>对普通元素</strong>的处理流程。</p><h5 id="2-处理普通元素"><a href="#2-处理普通元素" class="headerlink" title="2. 处理普通元素"></a>2. 处理普通元素</h5><p>我们再来看如何处理普通元素，我把之前的示例稍加修改，将其中的 Hello 组件删掉，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is &#123;&#123;msg&#125;&#125;.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toggle&quot;</span>&gt;</span>Toggle msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;Vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">toggle</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">msg</span> = <span class="string">&#x27;Vue&#x27;</span>? <span class="string">&#x27;World&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们点击 App 组件中的按钮会执行 toggle 函数，然后修改 data 中的 msg，这就触发了 App 组件的重新渲染。</p><p>App 组件的根节点是 div 标签，重新渲染的子树 vnode 节点是一个普通元素的 vnode，所以应该先走 processElement 逻辑，我们来看这个函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processElement</span> = (<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  isSVG = isSVG || n2.<span class="property">type</span> === <span class="string">&#x27;svg&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 挂载元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新元素</span></span><br><span class="line">    <span class="title function_">patchElement</span>(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">patchElement</span> = (<span class="params">n1, n2, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> el = (n2.<span class="property">el</span> = n1.<span class="property">el</span>)</span><br><span class="line">  <span class="keyword">const</span> oldProps = (n1 &amp;&amp; n1.<span class="property">props</span>) || <span class="variable constant_">EMPTY_OBJ</span></span><br><span class="line">  <span class="keyword">const</span> newProps = n2.<span class="property">props</span> || <span class="variable constant_">EMPTY_OBJ</span></span><br><span class="line">  <span class="comment">// 更新 props</span></span><br><span class="line">  <span class="title function_">patchProps</span>(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)</span><br><span class="line">  <span class="keyword">const</span> areChildrenSVG = isSVG &amp;&amp; n2.<span class="property">type</span> !== <span class="string">&#x27;foreignObject&#x27;</span></span><br><span class="line">  <span class="comment">// 更新子节点</span></span><br><span class="line">  <span class="title function_">patchChildren</span>(n1, n2, el, <span class="literal">null</span>, parentComponent, parentSuspense, areChildrenSVG)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，更新元素的过程主要做两件事情：更新 props 和更新子节点。其实这是很好理解的，因为一个 DOM 节点元素就是由它自身的一些属性和子节点构成的。</p><p>首先是更新 props，这里的 patchProps 函数就是在更新 DOM 节点的 class、style、event 以及其它的一些 DOM 属性，这个过程我不再深入分析了，感兴趣的同学可以自己看这部分代码。</p><p>其次是更新子节点，我们来看一下这里的 patchChildren 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patchChildren</span> = (<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> prevShapeFlag = n1 ? n1.<span class="property">shapeFlag</span> : <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> c2 = n2.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = n2</span><br><span class="line">  <span class="comment">// 子节点有 3 种可能情况：文本、数组、空</span></span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">      <span class="comment">// 数组 -&gt; 文本，则删除之前的子节点</span></span><br><span class="line">      <span class="title function_">unmountChildren</span>(c1, parentComponent, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c2 !== c1) &#123;</span><br><span class="line">      <span class="comment">// 文本对比不同，则替换为新文本</span></span><br><span class="line">      <span class="title function_">hostSetElementText</span>(container, c2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">      <span class="comment">// 之前的子节点是数组</span></span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 新的子节点仍然是数组，则做完整地 diff</span></span><br><span class="line">        <span class="title function_">patchKeyedChildren</span>(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组 -&gt; 空，则仅仅删除之前的子节点</span></span><br><span class="line">        <span class="title function_">unmountChildren</span>(c1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 之前的子节点是文本节点或者为空</span></span><br><span class="line">      <span class="comment">// 新的子节点是数组或者为空</span></span><br><span class="line">      <span class="keyword">if</span> (prevShapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前子节点是文本，则把它清空</span></span><br><span class="line">        <span class="title function_">hostSetElementText</span>(container, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果新的子节点是数组，则挂载新子节点</span></span><br><span class="line">        <span class="title function_">mountChildren</span>(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个元素的子节点 vnode 可能会有三种情况：纯文本、vnode 数组和空。那么根据排列组合对于新旧子节点来说就有九种情况，我们可以通过三张图来表示。</p><p>首先来看一下<strong>旧子节点是纯文本</strong>的情况：</p><ul><li>如果新子节点也是纯文本，那么做简单地文本替换即可；</li><li>如果新子节点是空，那么删除旧子节点即可；</li><li>如果新子节点是 vnode 数组，那么先把旧子节点的文本清空，再去旧子节点的父容器下添加多个新子节点。</li></ul><img src="/2022/06/27/vue3/dom-diff-process1/Ciqc1F8MBDWAfUAXAADe59XvjHY701.png" class=""><p>接下来看一下<strong>旧子节点是空</strong>的情况：</p><ul><li>如果新子节点是纯文本，那么在旧子节点的父容器下添加新文本节点即可；</li><li>如果新子节点也是空，那么什么都不需要做；</li><li>如果新子节点是 vnode 数组，那么直接去旧子节点的父容器下添加多个新子节点即可。</li></ul><img src="/2022/06/27/vue3/dom-diff-process1/CgqCHl8MBEOANnFmAADYr-_R5mM894.png" class=""><p>最后来看一下<strong>旧子节点是 vnode 数组</strong>的情况：</p><ul><li>如果新子节点是纯文本，那么先删除旧子节点，再去旧子节点的父容器下添加新文本节点；</li><li>如果新子节点是空，那么删除旧子节点即可；</li><li>如果新子节点也是 vnode 数组，那么就需要做完整的 diff 新旧子节点了，这是最复杂的情况，内部运用了核心 diff 算法。</li></ul><img src="/2022/06/27/vue3/dom-diff-process1/CgqCHl8MBCuAUZksAADplAU2718113.png" class=""><p>下节课我们就来深入探究一下这个复杂的 diff 算法。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;componentRenderUtils.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节课我们梳理了组件渲染的过程，本质上就是把各种类型的 vnode 渲染成真实 DOM。我们也知道了组件是由模板、组件描述对象和数据构成的，数据的变化会影响组件的变化。组件的渲染过程中创建了一个带副作用的渲染函数，当数据变化的时候就会执行这个渲染函数来触发组件的更新。那么接下来，我们就具体分析一下组件的更新过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="DOM-diff" scheme="https://xiaozhouguo.github.io/tags/DOM-diff/"/>
    
  </entry>
  
  <entry>
    <title>组件渲染，从VNode到真实DOM的转变</title>
    <link href="https://xiaozhouguo.github.io/2022/06/24/vue3/component-render/"/>
    <id>https://xiaozhouguo.github.io/2022/06/24/vue3/component-render/</id>
    <published>2022-06-24T03:23:34.000Z</published>
    <updated>2022-10-13T08:18:59.435Z</updated>
    
    <content type="html"><![CDATA[<p>在 Vue.js 中，组件是一个非常重要的概念，整个应用的页面都是通过组件渲染来实现的，但是你知道当我们编写这些组件的时候，它的内部是如何工作的吗？从我们编写组件开始，到最终真实的 DOM 又是怎样的一个转变过程呢？这节课，我们将会学习 Vue.js 3.0 中的组件是如何渲染的，通过学习，你的这些问题将会迎刃而解。</p><span id="more"></span><p>首先，组件是一个抽象的概念，它是对一棵 DOM 树的抽象，我们在页面中写一个组件节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello-world</span>&gt;</span><span class="tag">&lt;/<span class="name">hello-world</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码并不会在页面上渲染一个<code>&lt;hello-world&gt;</code>标签，而它具体渲染成什么，取决于你怎么编写 HelloWorld 组件的模板。举个例子，HelloWorld 组件内部的模板定义是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，模板内部最终会在页面上渲染一个 div，内部包含一个 p 标签，用来显示 Hello World 文本。</p><p>所以，从表现上来看，组件的模板决定了组件生成的 DOM 标签，而在 Vue.js 内部，一个组件想要真正的渲染生成 DOM，还需要经历“创建 vnode - 渲染 vnode - 生成 DOM” 这几个步骤：</p><img src="/2022/06/24/vue3/component-render/Ciqc1F8EO_OAOS86AABTGXEAHqA770.png" class=""><p>你可能会问，什么是 vnode，它和组件什么关系呢？先不要着急，我们在后面会详细说明。这里，你只需要记住它就是一个可以描述组件信息的 JavaScript 对象即可。</p><p>接下来，我们就从应用程序的入口开始，逐步来看 Vue.js 3.0 中的组件是如何渲染的。</p><h3 id="应用程序初始化"><a href="#应用程序初始化" class="headerlink" title="应用程序初始化"></a>应用程序初始化</h3><p>一个组件可以通过“模板加对象描述”的方式创建，组件创建好以后是如何被调用并初始化的呢？因为整个组件树是由根组件开始渲染的，为了找到根组件的渲染入口，我们需要从应用程序的初始化过程开始分析。</p><p>在这里，我分别给出了通过 Vue.js 2.x 和 Vue.js 3.0 来初始化应用的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Vue.js 2.x 中，初始化一个应用的方式如下</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 在 Vue.js 3.0 中，初始化一个应用的方式如下</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，Vue.js 3.0 初始化应用的方式和 Vue.js 2.x 差别并不大，本质上都是把 App 组件挂载到 id 为 app 的 DOM 节点上。</p><p>但是，在 Vue.js 3.0 中还导入了一个 <code>createApp</code>，其实这是个入口函数，它是 Vue.js 对外暴露的一个函数，我们来看一下它的内部实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createApp = (<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 app 对象</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">ensureRenderer</span>().<span class="title function_">createApp</span>(...args)</span><br><span class="line">  <span class="keyword">const</span> &#123; mount &#125; = app</span><br><span class="line">  <span class="comment">// 重写 mount 方法</span></span><br><span class="line">  app.<span class="property">mount</span> = <span class="function">(<span class="params">containerOrSelector</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从代码中可以看出 createApp 主要做了两件事情：创建 app 对象和重写 app.mount 方法。接下来，我们就具体来分析一下它们。</p><h4 id="1-创建-app-对象"><a href="#1-创建-app-对象" class="headerlink" title="1. 创建 app 对象"></a>1. 创建 app 对象</h4><p>首先，我们使用 ensureRenderer().createApp() 来创建 app 对象 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">app</span> <span class="operator">=</span> ensureRenderer().createApp(...args)</span><br></pre></td></tr></table></figure><p>其中 ensureRenderer() 用来创建一个渲染器对象，它的内部代码是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法</span></span><br><span class="line"><span class="keyword">const</span> rendererOptions = &#123;</span><br><span class="line">  patchProp,</span><br><span class="line">  ...nodeOps</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> renderer</span><br><span class="line"><span class="comment">// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRenderer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> renderer || (renderer = <span class="title function_">createRenderer</span>(rendererOptions))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRenderer</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">baseCreateRenderer</span>(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baseCreateRenderer</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">vnode, container</span>) &#123;</span><br><span class="line">    <span class="comment">// 组件渲染的核心逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    <span class="attr">createApp</span>: <span class="title function_">createAppAPI</span>(render)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAppAPI</span>(<span class="params">render</span>) &#123;</span><br><span class="line">  <span class="comment">// createApp createApp 方法接受的两个参数：根组件的对象和 prop</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> app = &#123;</span><br><span class="line">      <span class="attr">_component</span>: rootComponent,</span><br><span class="line">      <span class="attr">_props</span>: rootProps,</span><br><span class="line">      <span class="title function_">mount</span>(<span class="params">rootContainer</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建根组件的 vnode</span></span><br><span class="line">        <span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(rootComponent, rootProps)</span><br><span class="line">        <span class="comment">// 利用渲染器渲染 vnode</span></span><br><span class="line">        <span class="title function_">render</span>(vnode, rootContainer)</span><br><span class="line">        app.<span class="property">_container</span> = rootContainer</span><br><span class="line">        <span class="keyword">return</span> vnode.<span class="property">component</span>.<span class="property">proxy</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里先用 ensureRenderer() 来延时创建渲染器，这样做的好处是当用户只依赖响应式包的时候，就不会创建渲染器，因此可以通过 tree-shaking 的方式移除核心渲染逻辑相关的代码。</p><p>这里涉及了渲染器的概念，它是为跨平台渲染做准备的，之后我会在自定义渲染器的相关内容中详细说明。在这里，你可以简单地把渲染器理解为包含平台渲染核心逻辑的 JavaScript 对象。</p><p>我们结合上面的代码继续深入，在 Vue.js 3.0 内部通过 createRenderer 创建一个渲染器，这个渲染器内部会有一个 createApp 方法，它是执行 createAppAPI 方法返回的函数，接受了 rootComponent 和 rootProps 两个参数，我们在应用层面执行 createApp(App) 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象，它会提供 mount 方法，这个方法是用来挂载组件的。</p><p>在整个 app 对象创建过程中，Vue.js 利用闭包和函数柯里化的技巧，很好地实现了参数保留。比如，在执行 app.mount 的时候，并不需要传入渲染器 render，这是因为在执行 createAppAPI 的时候渲染器 render 参数已经被保留下来了。</p><h4 id="2-重写-app-mount-方法"><a href="#2-重写-app-mount-方法" class="headerlink" title="2. 重写 app.mount 方法"></a>2. 重写 app.mount 方法</h4><p>接下来，是重写 app.mount 方法。</p><p>根据前面的分析，我们知道 createApp 返回的 app 对象已经拥有了 mount 方法了，但在入口函数中，接下来的逻辑却是对 app.mount 方法的重写。先思考一下，为什么要重写这个方法，而不把相关逻辑放在 app 对象的 mount 方法内部来实现呢？</p><p>这是因为 Vue.js 不仅仅是为 Web 平台服务，它的目标是支持跨平台渲染，而 createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mount</span>(<span class="params">rootContainer</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建根组件的 vnode</span></span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(rootComponent, rootProps)</span><br><span class="line">  <span class="comment">// 利用渲染器渲染 vnode</span></span><br><span class="line">  <span class="title function_">render</span>(vnode, rootContainer)</span><br><span class="line">  app.<span class="property">_container</span> = rootContainer</span><br><span class="line">  <span class="keyword">return</span> vnode.<span class="property">component</span>.<span class="property">proxy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的跨平台渲染流程是先创建 vnode，再渲染 vnode。此外参数 rootContainer 也可以是不同类型的值，比如，在 Web 平台它是一个 DOM 对象，而在其他平台（比如 Weex 和小程序）中可以是其他类型的值。所以这里面的代码不应该包含任何特定平台相关的逻辑，也就是说这些代码的执行逻辑都是与平台无关的。因此我们需要在外部重写这个方法，来完善 Web 平台下的渲染逻辑。</p><p>接下来，我们再来看 app.mount 重写都做了哪些事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="property">mount</span> = <span class="function">(<span class="params">containerOrSelector</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 标准化容器</span></span><br><span class="line">  <span class="keyword">const</span> container = <span class="title function_">normalizeContainer</span>(containerOrSelector)</span><br><span class="line">  <span class="keyword">if</span> (!container)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> component = app.<span class="property">_component</span></span><br><span class="line">   <span class="comment">// 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isFunction</span>(component) &amp;&amp; !component.<span class="property">render</span> &amp;&amp; !component.<span class="property">template</span>) &#123;</span><br><span class="line">    component.<span class="property">template</span> = container.<span class="property">innerHTML</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 挂载前清空容器内容</span></span><br><span class="line">  container.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// 真正的挂载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mount</span>(container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是通过 normalizeContainer 标准化容器（这里可以传字符串选择器或者 DOM 对象，但如果是字符串选择器，就需要把它转成 DOM 对象，作为最终挂载的容器），然后做一个 if 判断，如果组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容；接着在挂载前清空容器内容，最终再调用 app.mount 的方法走标准的组件渲染流程。</p><p>在这里，重写的逻辑都是和 Web 平台相关的，所以要放在外部实现。此外，这么做的目的是既能让用户在使用 API 时可以更加灵活，也兼容了 Vue.js 2.x 的写法，比如 app.mount 的第一个参数就同时支持选择器字符串和 DOM 对象两种类型。</p><p>从 app.mount 开始，才算真正进入组件渲染流程，那么接下来，我们就重点看一下核心渲染流程做的两件事情：创建 vnode 和渲染 vnode。</p><h3 id="核心渲染流程：创建-vnode-和渲染-vnode"><a href="#核心渲染流程：创建-vnode-和渲染-vnode" class="headerlink" title="核心渲染流程：创建 vnode 和渲染 vnode"></a>核心渲染流程：创建 vnode 和渲染 vnode</h3><h4 id="1-创建-vnode"><a href="#1-创建-vnode" class="headerlink" title="1. 创建 vnode"></a>1. 创建 vnode</h4><p>首先，是创建 vnode 的过程。</p><p>vnode 本质上是用来描述 DOM 的 JavaScript 对象，它在 Vue.js 中可以描述不同类型的节点，比如普通元素节点、组件节点等。</p><p>什么是<strong>普通元素节点</strong>呢？举个例子，在 HTML 中我们使用 <code>&lt;button&gt;</code> 标签来写一个按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100px;height:50px&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以用 vnode 这样表示<code>&lt;button&gt;</code>标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;btn&#x27;</span>,</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">width</span>: <span class="string">&#x27;100px&#x27;</span>,</span><br><span class="line">      <span class="attr">height</span>: <span class="string">&#x27;50px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: <span class="string">&#x27;click me&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，type 属性表示 DOM 的标签类型，props 属性表示 DOM 的一些附加信息，比如 style 、class 等，children 属性表示 DOM 的子节点，它也可以是一个 vnode 数组，只不过 vnode 可以用字符串表示简单的文本 。</p><p>什么是<strong>组件节点</strong>呢？其实， vnode 除了可以像上面那样用于描述一个真实的 DOM，也可以用来描述组件。</p><p>我们先在模板中引入一个组件标签 <code>&lt;custom-component&gt;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-component</span> <span class="attr">msg</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以用 vnode 这样表示 <code>&lt;custom-component&gt;</code> 组件标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CustomComponent</span> = &#123;</span><br><span class="line">  <span class="comment">// 在这里定义组件对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> vnode = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">CustomComponent</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件 vnode 其实是<strong>对抽象事物的描述</strong>，这是因为我们并不会在页面上真正渲染一个 <code>&lt;custom-component&gt;</code> 标签，而是渲染组件内部定义的 HTML 标签。</p><p>除了上两种 vnode 类型外，还有纯文本 vnode、注释 vnode 等等，但鉴于我们的主线只需要研究组件 vnode 和普通元素 vnode，所以我在这里就不赘述了。</p><p>另外，Vue.js 3.0 内部还针对 vnode 的 type，做了更详尽的分类，包括 Suspense、Teleport 等，且把 vnode 的类型信息做了编码，以便在后面的 patch 阶段，可以根据不同的类型执行相应的处理逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeFlag = <span class="title function_">isString</span>(type)</span><br><span class="line">  ? <span class="number">1</span> <span class="comment">/* ELEMENT */</span></span><br><span class="line">  : <span class="title function_">isSuspense</span>(type)</span><br><span class="line">    ? <span class="number">128</span> <span class="comment">/* SUSPENSE */</span></span><br><span class="line">    : <span class="title function_">isTeleport</span>(type)</span><br><span class="line">      ? <span class="number">64</span> <span class="comment">/* TELEPORT */</span></span><br><span class="line">      : <span class="title function_">isObject</span>(type)</span><br><span class="line">        ? <span class="number">4</span> <span class="comment">/* STATEFUL_COMPONENT */</span></span><br><span class="line">        : <span class="title function_">isFunction</span>(type)</span><br><span class="line">          ? <span class="number">2</span> <span class="comment">/* FUNCTIONAL_COMPONENT */</span></span><br><span class="line">          : <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>知道什么是 vnode 后，你可能会好奇，那么 vnode 有什么优势呢？为什么一定要设计 vnode 这样的数据结构呢？</strong></p><p>首先是<strong>抽象</strong>，引入 vnode，可以把渲染过程抽象化，从而使得组件的抽象能力也得到提升。</p><p>其次是<strong>跨平台</strong>，因为 patch vnode 的过程不同平台可以有自己的实现，基于 vnode 再做服务端渲染、Weex 平台、小程序平台的渲染都变得容易了很多。</p><p>不过这里要特别注意，使用 vnode 并不意味着不用操作 DOM 了，很多同学会误以为 vnode 的性能一定比手动操作原生 DOM 好，这个其实是不一定的。</p><p>因为，首先这种基于 vnode 实现的 MVVM 框架，在每次 render to vnode 的过程中，渲染组件会有一定的 JavaScript 耗时，特别是大组件，比如一个 1000 * 10 的 Table 组件，render to vnode 的过程会遍历 1000 * 10 次去创建内部 cell vnode，整个耗时就会变得比较长，加上 patch vnode 的过程也会有一定的耗时，当我们去更新组件的时候，用户会感觉到明显的卡顿。虽然 diff 算法在减少 DOM 操作方面足够优秀，但最终还是免不了操作 DOM，所以说性能并不是 vnode 的优势。</p><p><strong>那么，Vue.js 内部是如何创建这些 vnode 的呢？</strong></p><p>回顾 app.mount 函数的实现，内部是通过 createVNode 函数创建了根组件的 vnode ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(rootComponent, rootProps)</span><br></pre></td></tr></table></figure><p>我们来看一下 createVNode 函数的大致实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createVNode</span>(<span class="params">type, props = <span class="literal">null</span></span></span><br><span class="line"><span class="params">,children = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props 相关逻辑，标准化 class 和 style</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 vnode 类型信息编码</span></span><br><span class="line">  <span class="keyword">const</span> shapeFlag = <span class="title function_">isString</span>(type)</span><br><span class="line">    ? <span class="number">1</span> <span class="comment">/* ELEMENT */</span></span><br><span class="line">    : <span class="title function_">isSuspense</span>(type)</span><br><span class="line">      ? <span class="number">128</span> <span class="comment">/* SUSPENSE */</span></span><br><span class="line">      : <span class="title function_">isTeleport</span>(type)</span><br><span class="line">        ? <span class="number">64</span> <span class="comment">/* TELEPORT */</span></span><br><span class="line">        : <span class="title function_">isObject</span>(type)</span><br><span class="line">          ? <span class="number">4</span> <span class="comment">/* STATEFUL_COMPONENT */</span></span><br><span class="line">          : <span class="title function_">isFunction</span>(type)</span><br><span class="line">            ? <span class="number">2</span> <span class="comment">/* FUNCTIONAL_COMPONENT */</span></span><br><span class="line">            : <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    <span class="comment">// 一些其他属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 标准化子节点，把不同数据类型的 children 转成数组或者文本类型</span></span><br><span class="line">  <span class="title function_">normalizeChildren</span>(vnode, children)</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可以看到，其实 <code>createVNode</code> 做的事情很简单，就是：对 props 做标准化处理、对 vnode 的类型信息编码、创建 vnode 对象，标准化子节点 children 。</p><p>我们现在拥有了这个 vnode 对象，接下来要做的事情就是把它渲染到页面中去。</p><h4 id="2-渲染-vnode"><a href="#2-渲染-vnode" class="headerlink" title="2. 渲染 vnode"></a>2. 渲染 vnode</h4><p>接下来，是渲染 vnode 的过程。</p><p>回顾 app.mount 函数的实现，内部通过执行这段代码去渲染创建好的 vnode：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(vnode, rootContainer)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 销毁组件</span></span><br><span class="line">    <span class="keyword">if</span> (container.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(container.<span class="property">_vnode</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或者更新组件</span></span><br><span class="line">    <span class="title function_">patch</span>(container.<span class="property">_vnode</span> || <span class="literal">null</span>, vnode, container)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存 vnode 节点，表示已经渲染</span></span><br><span class="line">  container.<span class="property">_vnode</span> = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个渲染函数 render 的实现很简单，如果它的第一个参数 vnode 为空，则执行销毁组件的逻辑，否则执行创建或者更新组件的逻辑。</p><p>接下来我们接着看一下上面渲染 vnode 的代码中涉及的 patch 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2, container, anchor = <span class="literal">null</span>, parentComponent = <span class="literal">null</span>, parentSuspense = <span class="literal">null</span>, isSVG = <span class="literal">false</span>, optimized = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span></span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; !<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    anchor = <span class="title function_">getNextHostNode</span>(n1)</span><br><span class="line">    <span class="title function_">unmount</span>(n1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    n1 = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, shapeFlag &#125; = n2</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Text</span>:</span><br><span class="line">      <span class="comment">// 处理文本节点</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Comment</span>:</span><br><span class="line">      <span class="comment">// 处理注释节点</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Static</span>:</span><br><span class="line">      <span class="comment">// 处理静态节点</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Fragment</span>:</span><br><span class="line">      <span class="comment">// 处理 Fragment 元素</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (shapeFlag &amp; <span class="number">1</span> <span class="comment">/* ELEMENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理普通 DOM 元素</span></span><br><span class="line">        <span class="title function_">processElement</span>(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">6</span> <span class="comment">/* COMPONENT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理组件</span></span><br><span class="line">        <span class="title function_">processComponent</span>(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">64</span> <span class="comment">/* TELEPORT */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 TELEPORT</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">128</span> <span class="comment">/* SUSPENSE */</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 SUSPENSE</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>patch 本意是打补丁的意思，这个函数有两个功能，一个是根据 vnode 挂载 DOM，一个是根据新旧 vnode 更新 DOM。对于初次渲染，我们这里只分析创建过程，更新过程在后面的章节分析。</p><p>在创建的过程中，patch 函数接受多个参数，这里我们目前只重点关注前三个：</p><ol><li>第一个参数 <strong>n1 表示旧的 vnode</strong>，当 n1 为 null 的时候，表示是一次挂载的过程；</li><li>第二个参数 <strong>n2 表示新的 vnode 节点</strong>，后续会根据这个 vnode 类型执行不同的处理逻辑；</li><li>第三个参数 <strong>container 表示 DOM 容器</strong>，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。</li></ol><p>对于渲染的节点，我们这里重点关注两种类型节点的渲染逻辑：对组件的处理和对普通 DOM 元素的处理。</p><p><strong>先来看对组件的处理</strong>。由于初始化渲染的是 App 组件，它是一个组件 vnode，所以我们来看一下组件的处理逻辑是怎样的。首先是用来处理组件的 processComponent 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processComponent</span> = (<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 挂载组件</span></span><br><span class="line">   <span class="title function_">mountComponent</span>(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新组件</span></span><br><span class="line">    <span class="title function_">updateComponent</span>(n1, n2, parentComponent, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的逻辑很简单，如果 n1 为 null，则执行挂载组件的逻辑，否则执行更新组件的逻辑。</p><p>我们接着来看挂载组件的 mountComponent 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mountComponent</span> = (<span class="params">initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (initialVNode.<span class="property">component</span> = <span class="title function_">createComponentInstance</span>(initialVNode, parentComponent, parentSuspense))</span><br><span class="line">  <span class="comment">// 设置组件实例</span></span><br><span class="line">  <span class="title function_">setupComponent</span>(instance)</span><br><span class="line">  <span class="comment">// 设置并运行带副作用的渲染函数</span></span><br><span class="line">  <span class="title function_">setupRenderEffect</span>(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，挂载组件函数 mountComponent 主要做三件事情：创建组件实例、设置组件实例、设置并运行带副作用的渲染函数。</p><p>首先是创建组件实例，Vue.js 3.0 虽然不像 Vue.js 2.x 那样通过类的方式去实例化组件，但内部也通过对象的方式去创建了当前渲染的组件实例。</p><p>其次设置组件实例，instance 保留了很多组件相关的数据，维护了组件的上下文，包括对 props、插槽，以及其他实例的属性的初始化处理。</p><p>创建和设置组件实例这两个流程我们这里不展开讲，会在后面的章节详细分析。</p><p>最后是运行带副作用的渲染函数 setupRenderEffect，我们重点来看一下这个函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setupRenderEffect</span> = (<span class="params">instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建响应式的副作用渲染函数</span></span><br><span class="line">  instance.<span class="property">update</span> = <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">componentEffect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.<span class="property">isMounted</span>) &#123;</span><br><span class="line">      <span class="comment">// 渲染组件生成子树 vnode</span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.<span class="property">subTree</span> = <span class="title function_">renderComponentRoot</span>(instance))</span><br><span class="line">      <span class="comment">// 把子树 vnode 挂载到 container 中</span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, subTree, container, anchor, instance, parentSuspense, isSVG)</span><br><span class="line">      <span class="comment">// 保留渲染生成的子树根 DOM 节点</span></span><br><span class="line">      initialVNode.<span class="property">el</span> = subTree.<span class="property">el</span></span><br><span class="line">      instance.<span class="property">isMounted</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prodEffectOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数利用响应式库的 effect 函数创建了一个副作用渲染函数 <code>componentEffect </code>（effect 的实现我们后面讲响应式章节会具体说）。<strong>副作用</strong>，这里你可以简单地理解为，当组件的数据发生变化时，effect 函数包裹的内部渲染函数 <code>componentEffect</code> 会重新执行一遍，从而达到重新渲染组件的目的。</p><p>渲染函数内部也会判断这是一次初始渲染还是组件更新。这里我们只分析初始渲染流程。</p><p><strong>初始渲染主要做两件事情：渲染组件生成 subTree、把 subTree 挂载到 container 中。</strong></p><p>首先，是渲染组件生成 subTree，它也是一个 vnode 对象。这里要注意别把 subTree 和 initialVNode 弄混了（其实在 Vue.js 3.0 中，根据命名我们已经能很好地区分它们了，而在 Vue.js 2.x 中它们分别命名为 _vnode 和 $vnode）。我来举个例子说明，在父组件 App 中里引入了 Hello 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an app.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Hello 组件中是 <code>&lt;div&gt;</code> 标签包裹着一个 <code>&lt;p&gt;</code> 标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, Vue 3.0!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 App 组件中， <code>&lt;hello&gt;</code> 节点渲染生成的 vnode ，对应的就是 Hello 组件的 initialVNode ，为了好记，你也可以把它称作“组件 vnode”。而 Hello 组件内部整个 DOM 节点对应的 vnode 就是执行 renderComponentRoot 渲染生成对应的 subTree，我们可以把它称作“子树 vnode”。</p><p>我们知道每个组件都会有对应的 render 函数，即使你写 template，也会编译成 render 函数，而 renderComponentRoot 函数就是去执行 render 函数创建整个组件树内部的 vnode，把这个 vnode 再经过内部一层标准化，就得到了该函数的返回结果：子树 vnode。</p><p>渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了。</p><p>那么我们又再次回到了 patch 函数，会继续对这个子树 vnode 类型进行判断，对于上述例子，App 组件的根节点是 <code>&lt;div&gt;</code> 标签，那么对应的子树 vnode 也是一个普通元素 vnode，那么我们<strong>接下来看对普通 DOM 元素的处理流程。</strong></p><p>首先我们来看一下处理普通 DOM元素的 <code>processElement</code> 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">processElement</span> = (<span class="params">n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  isSVG = isSVG || n2.<span class="property">type</span> === <span class="string">&#x27;svg&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//挂载元素节点</span></span><br><span class="line">    <span class="title function_">mountElement</span>(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//更新元素节点</span></span><br><span class="line">    <span class="title function_">patchElement</span>(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的逻辑很简单，如果 n1 为 null，走挂载元素节点的逻辑，否则走更新元素节点逻辑。</p><p>我们接着来看挂载元素的 <code>mountElement</code> 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mountElement</span> = (<span class="params">vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> el</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props, shapeFlag &#125; = vnode</span><br><span class="line">  <span class="comment">// 创建 DOM 元素节点</span></span><br><span class="line">  el = vnode.<span class="property">el</span> = <span class="title function_">hostCreateElement</span>(vnode.<span class="property">type</span>, isSVG, props &amp;&amp; props.<span class="property">is</span>)</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 处理 props，比如 class、style、event 等属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isReservedProp</span>(key)) &#123;</span><br><span class="line">        <span class="title function_">hostPatchProp</span>(el, key, <span class="literal">null</span>, props[key], isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (shapeFlag &amp; <span class="number">8</span> <span class="comment">/* TEXT_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是纯文本的情况</span></span><br><span class="line">    <span class="title function_">hostSetElementText</span>(el, vnode.<span class="property">children</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; <span class="number">16</span> <span class="comment">/* ARRAY_CHILDREN */</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点是数组的情况</span></span><br><span class="line">    <span class="title function_">mountChildren</span>(vnode.<span class="property">children</span>, el, <span class="literal">null</span>, parentComponent, parentSuspense, isSVG &amp;&amp; type !== <span class="string">&#x27;foreignObject&#x27;</span>, optimized || !!vnode.<span class="property">dynamicChildren</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把创建的 DOM 元素节点挂载到 container 上</span></span><br><span class="line">  <span class="title function_">hostInsert</span>(el, container, anchor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，挂载元素函数主要做四件事：创建 DOM 元素节点、处理 props、处理 children、挂载 DOM 元素到 container 上。</p><p>首先是创建 DOM 元素节点，通过 <code>hostCreateElement</code> 方法创建，这是一个平台相关的方法，我们来看一下它在 Web 环境下的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">tag, isSVG, is</span>) &#123;</span><br><span class="line">  isSVG ? <span class="variable language_">document</span>.<span class="title function_">createElementNS</span>(svgNS, tag)</span><br><span class="line">    : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tag, is ? &#123; is &#125; : <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了底层的 DOM API document.createElement 创建元素，所以本质上 Vue.js 强调不去操作 DOM ，只是希望用户不直接碰触 DOM，它并没有什么神奇的魔法，底层还是会操作 DOM。</p><p>另外，如果是其他平台比如 Weex，hostCreateElement 方法就不再是操作 DOM ，而是平台相关的 API 了，这些平台相关的方法是在创建渲染器阶段作为参数传入的。</p><p>创建完 DOM 节点后，接下来要做的是判断如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的，这里就不展开讲了。</p><p>接下来是对子节点的处理，我们知道 DOM 是一棵树，vnode 同样也是一棵树，并且它和 DOM 结构是一一映射的。</p><p>如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setElementText</span>(<span class="params">el, text</span>) &#123;</span><br><span class="line">  el.<span class="property">textContent</span> = text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子节点是数组，则执行 mountChildren 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mountChildren</span> = (<span class="params">children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 预处理 child</span></span><br><span class="line">    <span class="keyword">const</span> child = (children[i] = optimized</span><br><span class="line">      ? <span class="title function_">cloneIfMounted</span>(children[i])</span><br><span class="line">      : <span class="title function_">normalizeVNode</span>(children[i]))</span><br><span class="line">    <span class="comment">// 递归 patch 挂载 child</span></span><br><span class="line">    <span class="title function_">patch</span>(<span class="literal">null</span>, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点的挂载逻辑同样很简单，遍历 children 获取到每一个 child，然后递归执行 patch 方法挂载每一个 child 。注意，这里有对 child 做预处理的情况（后面编译优化的章节会详细分析）。</p><p>可以看到，mountChildren 函数的第二个参数是 container，而我们调用 mountChildren 方法传入的第二个参数是在 mountElement 时创建的 DOM 节点，这就很好地建立了父子关系。</p><p>另外，通过递归 patch 这种深度优先遍历树的方式，我们就可以构造完整的 DOM 树，完成组件的渲染。</p><p>处理完所有子节点后，最后通过 hostInsert 方法把创建的 DOM 元素节点挂载到 container 上，它在 Web 环境下这样定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">child, parent, anchor</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (anchor) &#123;</span><br><span class="line">    parent.<span class="title function_">insertBefore</span>(child, anchor)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    parent.<span class="title function_">appendChild</span>(child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会做一个 if 判断，如果有参考元素 anchor，就执行 parent.insertBefore ，否则执行 parent.appendChild 来把 child 添加到 parent 下，完成节点的挂载。</p><p>因为 insert 的执行是在处理子节点后，所以挂载的顺序是先子节点，后父节点，最终挂载到最外层的容器上。</p><blockquote><p><strong>知识延伸：嵌套组件</strong><br>细心的你可能会发现，在 mountChildren 的时候递归执行的是 patch 函数，而不是 mountElement 函数，这是因为子节点可能有其他类型的 vnode，比如组件 vnode。</p><p>在真实开发场景中，嵌套组件场景是再正常不过的了，前面我们举的 App 和 Hello 组件的例子就是嵌套组件的场景。组件 vnode 主要维护着组件的定义对象，组件上的各种 props，而组件本身是一个抽象节点，它自身的渲染其实是通过执行组件定义的 render 函数渲染生成的子树 vnode 来完成，然后再 patch 。通过这种递归的方式，无论组件的嵌套层级多深，都可以完成整个组件树的渲染。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OK，到这里我们这一节的学习也要结束啦，这节课我们主要分析了组件的渲染流程，从入口开始，一层层分析组件渲染。</p><p>你可能发现了，文中提到的很多技术点我会放在后面的章节去讲，这样做是为了让我们不跑题，重点放在理解组件的渲染流程上。下节课我将会带你具体分析一下组件的更新过程。</p><p>这里，我用一张图来带你更加直观地感受下整个组件渲染流程：</p><img src="/2022/06/24/vue3/component-render/CgqCHl8EPLKAF8u5AAJHdNl56bM640.png" class=""><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong><br>packages&#x2F;runtime-dom&#x2F;src&#x2F;index.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;apiCreateApp.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;vnode.ts<br>packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.ts<br>packages&#x2F;runtime-dom&#x2F;src&#x2F;nodeOps.ts</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Vue.js 中，组件是一个非常重要的概念，整个应用的页面都是通过组件渲染来实现的，但是你知道当我们编写这些组件的时候，它的内部是如何工作的吗？从我们编写组件开始，到最终真实的 DOM 又是怎样的一个转变过程呢？这节课，我们将会学习 Vue.js 3.0 中的组件是如何渲染的，通过学习，你的这些问题将会迎刃而解。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3.0的优化简述</title>
    <link href="https://xiaozhouguo.github.io/2022/06/23/vue3/vue3-optimization-summary/"/>
    <id>https://xiaozhouguo.github.io/2022/06/23/vue3/vue3-optimization-summary/</id>
    <published>2022-06-23T09:23:05.000Z</published>
    <updated>2022-07-26T07:36:27.623Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 从 1.x 到 2.0 版本，最大的升级就是引入了虚拟 DOM 的概念，它为后续做服务端渲染以及跨端框架 <code>Weex</code> 提供了基础。</p><span id="more"></span><p>Vue.js 2.x 发展了很久，现在周边的生态设施都已经非常完善了，而且对于 Vue.js 用户而言，它几乎满足了我们日常开发的所有需求。你可能觉得 Vue.js 2.x 已经足够优秀，但是在 Vue.js 作者尤尤大的眼中它还不够完美。在迭代 2.x 版本的过程中，尤大发现了很多需要解决的痛点，比如源码自身的维护性，数据量大后带来的渲染和更新的性能问题，一些想舍弃但为了兼容一直保留的鸡肋 API 等；另外，尤大还希望能给开发人员带来更好的编程体验，比如更好的 TypeScript 支持、更好的逻辑复用实践等，所以他希望能从源码、性能和语法 API 三个大的方面优化框架。</p><p>那么接下来，我们就一起来看一下 Vue.js 3.0 具体做了哪些优化。相信你学习完这篇文章，不仅能知道 Vue.js 3.0 的升级给我们开发带来的收益，还能学习到一些设计思想和理念，并在自己的开发工作中应用，获得提升。</p><h2 id="源码优化"><a href="#源码优化" class="headerlink" title="源码优化"></a>源码优化</h2><p>首先是源码优化，也就是尤大对于 Vue.js 框架本身开发的优化，它的目的是让代码更易于开发和维护。源码的优化主要体现在使用 <code>monorepo</code> 和 <code>TypeScript</code> 管理和开发源码，这样做的目标是提升自身代码可维护性。接下来我们就来看一下这两个方面的具体变化。</p><h3 id="更好的代码管理方式：monorepo"><a href="#更好的代码管理方式：monorepo" class="headerlink" title="更好的代码管理方式：monorepo"></a>更好的代码管理方式：<code>monorepo</code></h3><p>首先，源码的优化体现在代码管理方式上。Vue.js 2.x 的源码托管在 src 目录，然后依据功能拆分出了 compiler（模板编译的相关代码）、core（与平台无关的通用运行时代码）、platforms（平台专有代码）、server（服务端渲染的相关代码）、sfc（.vue 单文件解析相关代码）、shared（共享工具代码） 等目录：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/Ciqc1F8Cn6mAHaUrAACzRBFsL1g844.png" class=""><p>而到了 Vue.js 3.0 ，整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/Ciqc1F8Cn7KAELkqAAJkxFes1zw593.png" class=""><p>可以看出相对于 Vue.js 2.x 的源码组织方式，monorepo 把这些模块拆分到不同的 package 中，每个 package 有各自的 API、类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。<br>另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue.js 使用的，这样用户如果只想使用 Vue.js 3.0 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue.js，减小了引用包的体积大小，而 Vue.js 2 .x 是做不到这一点的。</p><h3 id="有类型的-JavaScript：TypeScript"><a href="#有类型的-JavaScript：TypeScript" class="headerlink" title="有类型的 JavaScript：TypeScript"></a>有类型的 JavaScript：TypeScript</h3><p>其次，源码的优化还体现在 Vue.js 3.0 自身采用了 TypeScript 开发。Vue.js 1.x 版本的源码是没有用类型语言的，尤大用 JavaScript 开发了整个框架，但对于复杂的框架项目开发，使用类型语言非常有利于代码的维护，因为它可以在编码期间帮你做类型检查，避免一些因类型问题导致的错误；也可以利于它去定义接口的类型，利于 IDE 对变量类型的推导。<br>因此在重构 2.0 的时候，尤大选型了 Flow，但是在 Vue.js 3.0 的时候抛弃 Flow 转而采用 TypeScript 重构了整个项目，这里有两方面原因，接下来我们具体说一下。<br>首先，Flow 是 Facebook 出品的 JavaScript 静态类型检查工具，它可以以非常小的成本对已有的 JavaScript 代码迁入，非常灵活，这也是 Vue.js 2.0 当初选型它时一方面的考量。但是 Flow 对于一些复杂场景类型的检查，支持得并不好。记得在看 Vue.js 2.x 源码的时候，在某行代码的注释中看到了对 Flow 的吐槽，比如在组件更新 props 的地方出现了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">propOptions</span>: <span class="built_in">any</span> = vm.<span class="property">$options</span>.<span class="property">props</span> <span class="comment">// wtf flow?</span></span><br></pre></td></tr></table></figure><p>什么意思呢？其实是由于这里 Flow 并没有正确推导出 vm.$options.props 的类型 ，开发人员不得不强制申明 propsOptions 的类型为 any，显得很不合理；另外他也在社区平台吐槽过 Flow 团队的烂尾。<br>其次，Vue.js 3.0 抛弃 Flow 后，使用 TypeScript 重构了整个项目。 TypeScript提供了更好的类型检查，能支持复杂的类型推导；由于源码就使用 TypeScript 编写，也省去了单独维护 d.ts 文件的麻烦；就整个 TypeScript 的生态来看，TypeScript 团队也是越做越好，TypeScript 本身保持着一定频率的迭代和更新，支持的 feature 也越来越多。<br>此外，尤大和 TypeScript 团队也一直保持了良好的沟通，我们可以期待 TypeScript 对 Vue.js 的支持会越来越好。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>性能优化一直是前端老生常谈的问题。那么对于 Vue.js 2.x 已经足够优秀的前端框架，它的性能优化可以从哪些方面进行突破呢？</p><h3 id="源码体积优化"><a href="#源码体积优化" class="headerlink" title="源码体积优化"></a>源码体积优化</h3><p>首先是源码体积优化，我们在平时工作中也经常会尝试优化静态资源的体积，因为 JavaScript 包体积越小，意味着网络传输时间越短，JavaScript 引擎解析包的速度也越快。<br>那么，Vue.js 3.0 在源码体积的减少方面做了哪些工作呢？</p><p>+<br>  首先，移除一些冷门的 feature（比如 filter、inline-template 等）；</p><p>+<br>  其次，引入 tree-shaking 的技术，减少打包体积。</p><p>第一点很好理解，所以这里我们来看看 tree-shaking，它的原理很简单，tree-shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块并打上标记。<br>举个例子，一个 math 模块定义了 2 个方法 square(x) 和 cube(x) ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这个模块外面只引入了 cube 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span></span><br><span class="line"><span class="comment">// do something with cube</span></span><br></pre></td></tr></table></figure><p>最终 math 模块会被 webpack 打包生成如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span>, __webpack_exports__, __webpack_require__</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">/* unused harmony export square */</span></span><br><span class="line">  <span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&#x27;a&#x27;</span>] = cube;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，未被引入的 square 模块被标记了， 然后压缩阶段会利用例如 uglify-js、terser 等压缩工具真正地删除这些没有用到的代码。<br>也就是说，利用 tree-shaking 技术，如果你在项目中没有引入 Transition、KeepAlive 等组件，那么它们对应的代码就不会打包，这样也就间接达到了减少项目引入的 Vue.js 包体积的目的。</p><h3 id="数据劫持优化"><a href="#数据劫持优化" class="headerlink" title="数据劫持优化"></a>数据劫持优化</h3><p>其次是数据劫持优化。Vue.js 区别于 React 的一大特色是它的数据是响应式的，这个特性从 Vue.js 1.x 版本就一直伴随着，这也是 Vue.js 粉喜欢 Vue.js 的原因之一，DOM 是数据的一种映射，数据发生变化后可以自动更新 DOM，用户只需要专注于数据的修改，没有其余的心智负担。<br>在 Vue.js 内部，想实现这个功能是要付出一定代价的，那就是必须劫持数据的访问和更新。其实这点很好理解，当数据改变后，为了自动更新 DOM，那么就必须劫持数据的更新，也就是说当数据发生改变后能自动执行一些代码去更新 DOM，那么问题来了，Vue.js 怎么知道更新哪一片 DOM 呢？因为在渲染 DOM 的时候访问了数据，我们可以对它进行访问劫持，这样就在内部建立了依赖关系，也就知道数据对应的 DOM 是什么了。以上只是大体的思路，具体实现要比这更复杂，内部还依赖了一个 watcher 的数据结构做依赖管理，参考下图：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/CgqCHl8CudyAJc3tAAGkPxYyp9k501.png" class=""><p>Vue.js 1.x 和 Vue.js 2.x 内部都是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter，具体是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但这个 API 有一些缺陷，它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法，但是对于用户来说，还是增加了一定的心智负担。</p><p>另外 Object.defineProperty 的方式还有一个问题，举个例子，比如这个嵌套层级比较深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">c</span>: &#123;</span><br><span class="line">          <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Vue.js 无法判断你在运行时到底会访问到哪个属性，所以对于这样一个嵌套层级较深的对象，如果要劫持它内部深层次的对象变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的。毫无疑问，如果我们定义的响应式数据过于复杂，这就会有相当大的性能负担。</p><p>为了解决上述 2 个问题，Vue.js 3.0 使用了 Proxy API 做数据劫持，它的内部是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于它劫持的是整个对象，那么自然对于对象的属性的增加和删除都能检测到。</p><p>但要注意的是，Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能，我会在后面分析响应式章节详细介绍它的具体实现原理。</p><h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><p>最后是编译优化，为了便于理解，我们先来看一张图：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/CgqCHl8Cuf2AZw70AAEFU2EMA50521.png" class=""><p>这是 Vue.js 2.x 从 new Vue 开始渲染成 DOM 的流程，上面说过的响应式过程就发生在图中的 init 阶段，另外 template compile to render function 的流程是可以借助 vue-loader 在 webpack 编译阶段离线完成，并非一定要在运行时完成。</p><p>所以想优化整个 Vue.js 的运行时，除了数据劫持部分的优化，我们可以在耗时相对较多的 patch 阶段想办法，Vue.js 3.0 也是这么做的，并且它通过在编译阶段优化编译的结果，来实现运行时 patch 过程的优化。</p><p>我们知道，通过数据劫持和依赖收集，Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/Ciqc1F8CuhCADiJ1AAGMYHdzHa0498.png" class=""><p>虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树，举个例子，比如我们要更新这个组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>整个 diff 过程如图所示：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/Ciqc1F-zmN-AbAP_AAEJ0vicgdA415.png" class=""><p>可以看到，因为这段代码中只有一个动态节点，所以这里有很多 diff 和遍历其实都是不需要的，这就会导致 vnode 的性能跟模版大小正相关，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。</p><p>而对于上述例子，理想状态只需要 diff 这个绑定 message 动态节点的 p 标签即可。</p><p>Vue.js 3.0 做到了，它通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode <strong>更新性能</strong>由与模版整体大小相关提升为<strong>与动态内容的数量相关</strong>，这是一个非常大的性能突破，我会在后续的章节详细分析它是如何实现的。</p><p>除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法，这些性能优化的内容我在后续特定的章节与你分享。</p><h3 id="语法优化：Composition-API"><a href="#语法优化：Composition-API" class="headerlink" title="语法优化：Composition API"></a>语法优化：Composition API</h3><h4 id="优化组织逻辑"><a href="#优化组织逻辑" class="headerlink" title="优化组织逻辑"></a>优化组织逻辑</h4><p>在 Vue.js 1.x 和 2.x 版本中，编写组件本质就是在编写一个“包含了描述组件选项的对象”，我们把它称为 Options API，它的好处是在于写法非常符合直觉思维，对于新手来说这样很容易理解，这也是很多人喜欢 Vue.js 的原因之一。</p><p>Options API 的设计是按照 methods、computed、data、props 这些不同的选项分类，当组件小的时候，这种分类方式一目了然；但是在大型组件中，一个组件可能有多个逻辑关注点，当使用 Options API 的时候，每一个关注点都有自己的 Options，如果需要修改一个逻辑点关注点，就需要在单个文件中不断上下切换和寻找。</p><p>举一个官方例子 Vue CLI UI file explorer，它是 vue-cli GUI 应用程序中的一个复杂的文件浏览器组件。这个组件需要处理许多不同的逻辑关注点：</p><ul><li>跟踪当前文件夹状态并显示其内容</li><li>处理文件夹导航（比如打开、关闭、刷新等）</li><li>处理新文件夹的创建</li><li>切换显示收藏夹</li><li>切换显示隐藏文件夹</li><li>处理当前工作目录的更改</li></ul><p>如果我们按照逻辑关注点做颜色编码，就可以看到当使用 Options API 去编写组件时，这些逻辑关注点是非常分散的：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/Ciqc1F8CoIeAToThAAG5J8trLZc593.png" class=""><p>Vue.js 3.0 提供了一种新的 API：Composition API，它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。</p><p>通过下图，我们可以很直观地感受到 Composition API 在逻辑组织方面的优势：</p><img src="/2022/06/23/vue3/vue3-optimization-summary/CgqCHl8CoI-ACOXEAAM5NZiddQs980.png" class=""><h4 id="优化逻辑复用"><a href="#优化逻辑复用" class="headerlink" title="优化逻辑复用"></a>优化逻辑复用</h4><p>当我们开发项目变得复杂的时候，免不了需要抽象出一些复用的逻辑。在 Vue.js 2.x 中，我们通常会用 <code>mixins</code> 去复用逻辑，举一个鼠标位置侦听的例子，我们会编写如下函数 mousePositionMixin：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mousePositionMixin = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">update</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">update</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">x</span> = e.<span class="property">pageX</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">y</span> = e.<span class="property">pageY</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mousePositionMixin</span><br></pre></td></tr></table></figure><p>然后在组件中使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用单个 mixin 似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候，会存在两个非常明显的问题：命名冲突和数据来源不清晰。</p><p>首先每个 mixin 都可以定义自己的 props、data，它们之间是无感的，所以很容易定义相同的变量，导致命名冲突。另外对组件而言，如果模板中使用不在当前组件中定义的变量，那么就会不太容易知道这些变量在哪里定义的，这就是数据来源不清晰。但是Vue.js 3.0 设计的 Composition API，就很好地帮助我们解决了 mixins 的这两个问题。</p><p>我们来看一下在 Vue.js 3.0 中如何书写这个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useMousePosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">update</span> = e =&gt; &#123;</span><br><span class="line">    x.<span class="property">value</span> = e.<span class="property">pageX</span></span><br><span class="line">    y.<span class="property">value</span> = e.<span class="property">pageY</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们约定 useMousePosition 这个函数为 hook 函数，然后在组件中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123; x, y &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题。</p><p>Composition API 除了在逻辑复用方面有优势，也会有更好的类型支持，因为它们都是一些函数，在调用函数时，自然所有的类型就被推导出来了，不像 Options API 所有的东西使用 this。另外，Composition API 对 tree-shaking 友好，代码也更容易压缩。</p><p>虽然 Composition API 有诸多优势，它也不是一点缺点都没有，关于它的具体用法和设计原理，我们会在后续的章节详细说明。这里还需要说明的是，Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，你还是可以使用 Options API。</p><p>引入RFC：使每个版本改动可控</p><p>作为一个流行开源框架的作者，尤大可能每天都会收到各种各样的 feature request。但并不是社区一有新功能的需求，框架就会立马支持，因为随着 Vue.js 的用户越来越多，尤大会更加重视稳定性，会仔细考虑所做的每一个可能对最终用户影响的更改，以及有意识去防止新 API 对框架本身实现带来的复杂性的提升。</p><p>因此在 Vue.js 2.x 版本开发到后期的阶段 ，尤大就启用了 RFC ，它的全称是 Request For Comments，旨在为新功能进入框架提供一个一致且受控的路径。当社区有一些新需求的想法时，它可以提交一个 RFC，然后由社区和 Vue.js 的核心团队一起讨论，如果这个 RFC 最终被通过了，那么它才会被实现。比如 2.6 版本对于 slot 新 API 的改动，就是<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">这条 RFC</a> 里。</p><p>到了 Vue.js 3.0 ，尤大在实现代码前就大规模启用 RFC，来确保他的改动和设计都是经过讨论并确认的，这样可以避免走弯路。Vue.js 3.0 版本有很多重大的改动，每一条改动都会有对应的 RFC，通过阅读这些 RFC，你可以了解每一个 feature 采用或被废弃掉的前因后果。</p><p>Vue.js 3.0 目前已被实现并合并的 RFC 都在<a href="https://github.com/vuejs/rfcs/pulls?q=is:pr+is:merged+label:3.x">这里</a>，通过阅读它们，你也可以大致了解 Vue.js 3.0 的一些变化，以及为什么会产生这些变化，帮助你了解它的前因后果。</p><h2 id="过渡期"><a href="#过渡期" class="headerlink" title="过渡期"></a>过渡期</h2><p>接下来，我想再带你来了解一下 Vue.js 各版本迭代的过渡期，希望能够对你在 Vue.js 的技术选型方面和学习方向上有所帮助。</p><p>通常框架的 major 版本从升级到大规模投入使用，都需要经历相当长的一段过渡期。不过， Vue.js 1.x 到 Vue.js 2.0 的升级过渡期不长，主要是因为那个时候 Vue.js 的用户还不多，生态也不完善，很多用户都是直接上手的 2.0 版本，没有旧项目的历史包袱。</p><p>而 Vue.js 2.x 的发展历经了 3 年多的时间，用户众多，而且周边生态也已经非常完善了。通常 major 版本的升级会有很多 breaking change，这就意味着想从 2.x 升级到 3.0 的项目需要改代码，而且不仅仅项目的代码要修改，所依赖的周边生态也需要升级。这其实是一个相当大的工作量，也需要承担一定的风险，所以如果你的项目非常庞大且已经相对稳定，没有什么特别的痛点，那么升级要慎重。</p><p>Vue.js 3.0 使用 ES2015 的语法开发，有些 API 如 Proxy 是没有 polyfill 的，这就意味着官方需要单独出一个 IE11 compat 版本来支持 IE11。如果你的项目需要兼容 IE11，你就不得不小心使用某些 API，这也就带来了一些额外的心智负担。</p><p>因此可能在 Vue.js 3.0 出来的相当长的一段时间，复杂的大项目都不会考虑去升级，而一些小的、对浏览器兼容要求不高的新项目可以考虑尝鲜了。</p><p>官方会继续维护 Vue.js 2.x 版本 18 个月，如果你的有些项目一辈子都不打算升级 Vue.js 3.0，那么你应该去认真学习 Vue.js 2.x 的源码，在官方不再维护的时候遇到问题你可以自己去修改它的源码来解决。</p><p>不过，虽然 Vue.js 3.0 距离大规模应用还有相当长一段时间，但是越早开始学习你就越能在未来掌握主动权。这段时间里，你可以关注它的发展，去学习它的设计思想，也可以去为它的生态建设贡献代码，从而提升自己的技术能力。另外也可以尝试在一些小项目中应用 Vue.js 3.0，不仅可以享受 Vue.js 3.0 带来的性能方面的优势以及 Composition API 在逻辑复用方面便利，也为了将来某一天全面升级 Vue.js 3.0 做技术储备。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue.js 从 1.x 到 2.0 版本，最大的升级就是引入了虚拟 DOM 的概念，它为后续做服务端渲染以及跨端框架 &lt;code&gt;Weex&lt;/code&gt; 提供了基础。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
  </entry>
  
  <entry>
    <title>type-challanges 记录</title>
    <link href="https://xiaozhouguo.github.io/2022/05/30/typescript/type-challanges/"/>
    <id>https://xiaozhouguo.github.io/2022/05/30/typescript/type-challanges/</id>
    <published>2022-05-30T03:43:03.000Z</published>
    <updated>2022-06-08T03:09:19.707Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript 类型体操姿势合集记录 <a href="https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md">type-challenges&#x2F;README.zh-CN.md at main · type-challenges&#x2F;type-challenges (github.com)</a></p><span id="more"></span><h4 id="298-Length-of-String"><a href="#298-Length-of-String" class="headerlink" title="298 - Length of String"></a>298 - Length of String</h4><blockquote><p>计算字符串的长度，类似于 <code>String#length</code>，<a href="https://tsch.js.org/298/zh-CN">在 Github 上查看</a>。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LengthOfString</span>&lt;</span><br><span class="line">    S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">    arr <span class="keyword">extends</span> <span class="built_in">unknown</span>[] = []</span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer first&#125;</span><span class="subst">$&#123;infer rest&#125;</span>`</span></span><br><span class="line">? <span class="title class_">LengthOfString</span>&lt;rest,[...arr,first]&gt; : arr[<span class="string">&#x27;length&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="459-Flatten"><a href="#459-Flatten" class="headerlink" title="459 - Flatten"></a>459 - Flatten</h4><blockquote><p>在这个挑战中，你需要写一个接受数组的类型，并且返回扁平化的数组类型。<a href="https://tsch.js.org/459/zh-CN">在 Github 上查看</a>，例如:</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> flatten = <span class="title class_">Flatten</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[[<span class="number">5</span>]]]]&gt; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FlattenArrayVal</span>&lt;S <span class="keyword">extends</span> <span class="built_in">any</span>,T <span class="keyword">extends</span> <span class="built_in">unknown</span>[]=[]&gt; = S <span class="keyword">extends</span> <span class="built_in">unknown</span>[]</span><br><span class="line">? S <span class="keyword">extends</span> [infer first,...infer rest]</span><br><span class="line">?  <span class="title class_">FlattenArrayVal</span>&lt;rest, first <span class="keyword">extends</span> <span class="built_in">unknown</span>[]</span><br><span class="line">        ? <span class="title class_">FlattenArrayVal</span>&lt;first,T&gt;</span><br><span class="line">            : [...T,first]&gt;</span><br><span class="line">: T</span><br><span class="line">: S</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;S <span class="keyword">extends</span> <span class="built_in">unknown</span>[],T <span class="keyword">extends</span> <span class="built_in">unknown</span>[]=[]&gt; =</span><br><span class="line">S <span class="keyword">extends</span> [infer first,...infer rest]</span><br><span class="line">? <span class="title class_">Flatten</span>&lt;<span class="title class_">FlattenArrayVal</span>&lt;rest&gt;, [...T,<span class="title class_">FlattenArrayVal</span>&lt;first&gt;]&gt;</span><br><span class="line">: T</span><br></pre></td></tr></table></figure><p>解释：类型 <code>flattenArrayVal</code>的作用是处理数组中的每一项，非数组类型直接返回原样，数组类型返回扁平化后的数组，给<code>Flatten</code>使用。</p><h4 id="527-Append-to-object"><a href="#527-Append-to-object" class="headerlink" title="527 - Append to object"></a>527 - Append to object</h4><blockquote><p>实现一个为接口添加一个新字段的类型。该类型接收三个参数，返回带有新字段的接口类型。<a href="https://tsch.js.org/527/zh-CN">在 Github 上查看</a>，例如:</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Test</span> = &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">AppendToObject</span>&lt;<span class="title class_">Test</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">4</span>&gt; <span class="comment">// expected to be &#123; id: &#x27;1&#x27;, value: 4 &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AppendToObject</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Object</span>, U <span class="keyword">extends</span> <span class="built_in">string</span>, V&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T | U]:  K <span class="keyword">extends</span> keyof T ? T[K] : V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="529-Absolute"><a href="#529-Absolute" class="headerlink" title="529 - Absolute"></a>529 - Absolute</h4><blockquote><p>实现一个接收string,number或bigInt类型参数的<code>Absolute</code>类型,返回一个正数字符串。<a href="https://tsch.js.org/529/zh-CN">在 Github 上查看</a>，例如：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Test</span> = -<span class="number">100</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Absolute</span>&lt;<span class="title class_">Test</span>&gt;; <span class="comment">// expected to be &quot;100&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Absolute</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">bigint</span>&gt; =</span><br><span class="line"><span class="string">`<span class="subst">$&#123;T&#125;</span>`</span> <span class="keyword">extends</span> <span class="string">`-<span class="subst">$&#123;infer V&#125;</span>`</span> ? V : <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br></pre></td></tr></table></figure><h4 id="501-String-to-Union"><a href="#501-String-to-Union" class="headerlink" title="501 - String to Union"></a>501 - String to Union</h4><blockquote><p>实现一个将接收到的String参数转换为一个字母Union的类型。<a href="https://tsch.js.org/531/zh-CN">在Github 上查看</a>，例如：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Test</span> = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">StringToUnion</span>&lt;<span class="title class_">Test</span>&gt;; <span class="comment">// expected to be &quot;1&quot; | &quot;2&quot; | &quot;3&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringToUnion</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">? <span class="built_in">never</span></span><br><span class="line">:  T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer first&#125;</span><span class="subst">$&#123;infer rest&#125;</span>`</span></span><br><span class="line">? first | <span class="title class_">StringToUnion</span>&lt;rest&gt;</span><br><span class="line">: T</span><br></pre></td></tr></table></figure><h4 id="599-Merge"><a href="#599-Merge" class="headerlink" title="599 - Merge"></a>599 - Merge</h4><blockquote><p>将两个类型合并成一个类型，第二个类型的键会覆盖第一个类型的键。<a href="https://tsch.js.org/599/zh-CN">在 Github 上查看</a>，例如：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coo = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Merge</span>&lt;foo,coo&gt;; <span class="comment">// expected to be &#123;name: string, age: number, sex: string&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Merge</span>&lt;F <span class="keyword">extends</span> <span class="title class_">Object</span>, S <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof F | keyof S]: K <span class="keyword">extends</span> keyof S ? S[K] : K <span class="keyword">extends</span> keyof F ? F[K] : <span class="built_in">never</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="612-KebabCase"><a href="#612-KebabCase" class="headerlink" title="612 - KebabCase"></a>612 - KebabCase</h4><blockquote><p>FooBarBaz<code>-&gt;</code>foo-bar-baz，<a href="https://tsch.js.org/612">在Github上查看</a>。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FirstLowcase</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? F <span class="keyword">extends</span> <span class="title class_">Lowercase</span>&lt;F&gt; ? T : <span class="string">`<span class="subst">$&#123;Lowercase&lt;F&gt;&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">  : T</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KebabCase</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? R <span class="keyword">extends</span> <span class="title class_">FirstLowcase</span>&lt;R&gt;</span><br><span class="line">      ? <span class="string">`<span class="subst">$&#123;FirstLowcase&lt;F&gt;&#125;</span><span class="subst">$&#123;KebabCase&lt;R&gt;&#125;</span>`</span></span><br><span class="line">      : <span class="string">`<span class="subst">$&#123;FirstLowcase&lt;F&gt;&#125;</span>-<span class="subst">$&#123;KebabCase&lt;FirstLowcase&lt;R&gt;&gt;&#125;</span>`</span></span><br><span class="line">  : S</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">KebabMap</span> = &#123;</span><br><span class="line">  <span class="attr">A</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="attr">B</span>: <span class="string">&quot;b&quot;</span></span><br><span class="line">  <span class="attr">C</span>: <span class="string">&quot;c&quot;</span></span><br><span class="line">  <span class="attr">D</span>: <span class="string">&quot;d&quot;</span></span><br><span class="line">  <span class="attr">E</span>: <span class="string">&quot;e&quot;</span></span><br><span class="line">  <span class="attr">F</span>: <span class="string">&quot;f&quot;</span></span><br><span class="line">  <span class="attr">G</span>: <span class="string">&quot;g&quot;</span></span><br><span class="line">  <span class="attr">H</span>: <span class="string">&quot;h&quot;</span></span><br><span class="line">  <span class="attr">I</span>: <span class="string">&quot;i&quot;</span></span><br><span class="line">  <span class="attr">J</span>: <span class="string">&quot;j&quot;</span></span><br><span class="line">  <span class="attr">K</span>: <span class="string">&quot;k&quot;</span></span><br><span class="line">  <span class="attr">L</span>: <span class="string">&quot;l&quot;</span></span><br><span class="line">  <span class="attr">M</span>: <span class="string">&quot;m&quot;</span></span><br><span class="line">  <span class="attr">N</span>: <span class="string">&quot;n&quot;</span></span><br><span class="line">  <span class="attr">O</span>: <span class="string">&quot;o&quot;</span></span><br><span class="line">  <span class="attr">P</span>: <span class="string">&quot;p&quot;</span></span><br><span class="line">  <span class="attr">Q</span>: <span class="string">&quot;q&quot;</span></span><br><span class="line">  <span class="attr">R</span>: <span class="string">&quot;r&quot;</span></span><br><span class="line">  <span class="attr">S</span>: <span class="string">&quot;s&quot;</span></span><br><span class="line">  <span class="attr">T</span>: <span class="string">&quot;t&quot;</span></span><br><span class="line">  <span class="attr">U</span>: <span class="string">&quot;u&quot;</span></span><br><span class="line">  <span class="attr">V</span>: <span class="string">&quot;v&quot;</span></span><br><span class="line">  <span class="attr">W</span>: <span class="string">&quot;w&quot;</span></span><br><span class="line">  <span class="attr">X</span>: <span class="string">&quot;x&quot;</span></span><br><span class="line">  <span class="attr">Y</span>: <span class="string">&quot;y&quot;</span></span><br><span class="line">  <span class="attr">Z</span>: <span class="string">&quot;z&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KebabCase</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  U <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Target&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? <span class="title class_">Target</span> <span class="keyword">extends</span> keyof <span class="title class_">KebabMap</span></span><br><span class="line">    ? U <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      ? <span class="title class_">KebabCase</span>&lt;R, <span class="string">`<span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;KebabMap[Target]&#125;</span>`</span>&gt;</span><br><span class="line">      : <span class="title class_">KebabCase</span>&lt;R, <span class="string">`<span class="subst">$&#123;U&#125;</span>-<span class="subst">$&#123;KebabMap[Target]&#125;</span>`</span>&gt;</span><br><span class="line">    : <span class="title class_">KebabCase</span>&lt;R, <span class="string">`<span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;Target&#125;</span>`</span>&gt;</span><br><span class="line">  : U</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="645-Diff"><a href="#645-Diff" class="headerlink" title="645 - Diff"></a>645 - Diff</h4><blockquote><p>获取两个接口类型中的差值属性。<a href="https://tsch.js.org/645/zh-CN">在 Github 上查看</a>，例如：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="title class_">Diff</span>&lt;<span class="title class_">Foo</span>,<span class="title class_">Bar</span>&gt; <span class="comment">// &#123; b: number, c: boolean &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="title class_">Diff</span>&lt;<span class="title class_">Bar</span>,<span class="title class_">Foo</span>&gt; <span class="comment">// &#123; b: number, c: boolean &#125;</span></span><br></pre></td></tr></table></figure><p>第一种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Diff</span>&lt;O <span class="keyword">extends</span> <span class="built_in">object</span>, <span class="variable constant_">O1</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> (keyof <span class="title class_">Omit</span>&lt;O &amp; <span class="variable constant_">O1</span>, keyof (O | <span class="variable constant_">O1</span>)&gt;)]:</span><br><span class="line">    K <span class="keyword">extends</span> keyof O ? O[K] : K <span class="keyword">extends</span> keyof <span class="variable constant_">O1</span> ? <span class="variable constant_">O1</span>[K]:neve</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Diff</span>&lt;O <span class="keyword">extends</span> <span class="built_in">object</span>, <span class="variable constant_">O1</span> <span class="keyword">extends</span> <span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof <span class="title class_">Omit</span>&lt;<span class="variable constant_">O1</span>, keyof O&gt; | keyof <span class="title class_">Omit</span>&lt;O, keyof <span class="variable constant_">O1</span>&gt;]:</span><br><span class="line">    K <span class="keyword">extends</span> keyof O ? O[K] : K <span class="keyword">extends</span> keyof <span class="variable constant_">O1</span> ? <span class="variable constant_">O1</span>[K]:<span class="built_in">never</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="949-AnyOf"><a href="#949-AnyOf" class="headerlink" title="949 AnyOf"></a>949 AnyOf</h4><blockquote><p>在类型系统中实现类似于 Python 中 <code>any</code> 函数。类型接收一个数组，如果数组中任一个元素为真，则返回 <code>true</code>，否则返回 <code>fasle</code>。如果数组为空，返回 <code>false</code>。<a href="https://tsch.js.org/949/zh-CN">在Github上查看</a>，例如：</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Sample1</span> = <span class="title class_">AnyOf</span>&lt;[<span class="number">1</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>, [], &#123;&#125;]&gt; <span class="comment">// expected to be true.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sample2</span> = <span class="title class_">AnyOf</span>&lt;[<span class="number">0</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>, [], &#123;&#125;]&gt; <span class="comment">// expected to be false.</span></span><br></pre></td></tr></table></figure><p>第一种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FalsyVal</span>&lt;V&gt; = V <span class="keyword">extends</span> [] | <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">never</span>&gt; | <span class="string">&#x27;&#x27;</span> | <span class="number">0</span> | <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnyOf</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = <span class="literal">true</span> <span class="keyword">extends</span> <span class="title class_">FalsyVal</span>&lt;T[<span class="built_in">number</span>]&gt; ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FalsyVal</span> = [] | <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">never</span>&gt; | <span class="string">&#x27;&#x27;</span> | <span class="number">0</span> | <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnyOf</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer <span class="title class_">Head</span>, ...infer <span class="title class_">Tail</span>] ? <span class="title class_">Head</span> <span class="keyword">extends</span> <span class="title class_">FalsyVal</span> ? <span class="title class_">AnyOf</span>&lt;<span class="title class_">Tail</span>&gt; : <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="1042-IsNever"><a href="#1042-IsNever" class="headerlink" title="1042 IsNever"></a>1042 IsNever</h4><blockquote><p>Implement a type IsNever, which takes input type <code>T</code>. If the type of resolves to <code>never</code>, return <code>true</code>, otherwise <code>false</code>. <a href="https://tsch.js.org/1042">在Github上查看</a>。For example:</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="title class_">IsNever</span>&lt;<span class="built_in">never</span>&gt;  <span class="comment">// expected to be true</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">IsNever</span>&lt;<span class="literal">undefined</span>&gt; <span class="comment">// expected to be false</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">IsNever</span>&lt;<span class="literal">null</span>&gt; <span class="comment">// expected to be false</span></span><br><span class="line"><span class="keyword">type</span> D = <span class="title class_">IsNever</span>&lt;[]&gt; <span class="comment">// expected to be false</span></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">IsNever</span>&lt;<span class="built_in">number</span>&gt; <span class="comment">// expected to be false</span></span><br></pre></td></tr></table></figure><p>第一种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919</span></span><br><span class="line"><span class="comment">// https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsNever</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">never</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsNever</span>&lt;T&gt; = &#123;[<span class="attr">key</span>: <span class="built_in">string</span>]: T&#125; <span class="keyword">extends</span> &#123;[<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">never</span>&#125; ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;TypeScript 类型体操姿势合集记录 &lt;a href=&quot;https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md&quot;&gt;type-challenges&amp;#x2F;README.zh-CN.md at main · type-challenges&amp;#x2F;type-challenges (github.com)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="TypeScript" scheme="https://xiaozhouguo.github.io/categories/TypeScript/"/>
    
    
    <category term="type-challanges" scheme="https://xiaozhouguo.github.io/tags/type-challanges/"/>
    
  </entry>
  
  <entry>
    <title>一窥 vue3 响应式系统</title>
    <link href="https://xiaozhouguo.github.io/2022/05/25/vue3/simple-reactive/"/>
    <id>https://xiaozhouguo.github.io/2022/05/25/vue3/simple-reactive/</id>
    <published>2022-05-25T02:07:59.000Z</published>
    <updated>2022-05-26T07:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Vue</code> 中，响应式系统采取的是<code>发布订阅</code>的模式，<code>Vue2</code> 中主要依赖  ES5 <code>Object.defineProperty</code> 的 API，在 <code>vue3</code> 中重写了响应式系统，使用的是 ES6 <code>Proxy</code> <code>Reflect</code>，在它们不受支持的情况下会降级使用 <code>Object.defineProperty</code>。今天我们来实现一个极其简易版的响应式系统。</p><span id="more"></span><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>JS 本身并没有响应式的特性，那 Vue 是如何实现这一魔法的呢，我们先来看下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = product.<span class="property">quantity</span> * product.<span class="property">price</span> <span class="comment">// 10</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total :&gt;&gt; &#x27;</span>, total); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>total</code> 并没有自动更新为 12。我们可以修改下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  total = product.<span class="property">quantity</span> * product.<span class="property">price</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">effect</span>() <span class="comment">//total: 10</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="title function_">effect</span>() <span class="comment">//total: 12</span></span><br></pre></td></tr></table></figure><p>但此时我们仍然需要手动执行下 <code>effect</code> 才能让 <code>total</code> 的值变成”响应式”，如何能够自动更新呢？我们可以先修改下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  deps.<span class="title function_">add</span>(effect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">    deps.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  total = product.<span class="property">quantity</span> * product.<span class="property">price</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">track</span>(product, <span class="string">&#x27;price&#x27;</span>)</span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="title function_">trigger</span>(product, <span class="string">&#x27;price&#x27;</span>) <span class="comment">//total: 12</span></span><br></pre></td></tr></table></figure><p>如上，我们收集了依赖，当它被改变时，触发更新，使得 <code>total</code> 更新成功，这里使用到了 ES6 中的<code>WeakMap</code> <code>Map</code> <code>Set</code>。</p><blockquote><p>WeakMap  对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。WeakMap 的 key 是不可枚举的，因为 WeakMap 中每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象时这个对象将会被垃圾回收（相应的key则变成无效的）。</p></blockquote><h3 id="简易版本响应式"><a href="#简易版本响应式" class="headerlink" title="简易版本响应式"></a>简易版本响应式</h3><p>如何能让依赖发生变更时自动更新呢，我们更新如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  deps.<span class="title function_">add</span>(effect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">    deps.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reactive</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> handler = (target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get key :&gt;&gt; &#x27;</span>, key);</span><br><span class="line">      <span class="title function_">track</span>(target, key)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set key :&gt;&gt; &#x27;</span>, key);</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">      <span class="keyword">if</span> (oldValue !== value) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, key)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> product = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  total = product.<span class="property">quantity</span> * product.<span class="property">price</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">effect</span>() <span class="comment">// 建立 quantity 和 price 的依赖和副作用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total :&gt;&gt; &#x27;</span>, total); <span class="comment">// 10</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total :&gt;&gt; &#x27;</span>, total); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>成功了🙌，但是呢，如果我们在末尾加上一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name :&gt;&gt;&#x27;</span>, product.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p>此时，由于读取了 <code>name</code> ，由于拦截会重新进入到 <code>getter</code> 中，会重新 <code>track</code>，会为 <code>name</code> 建立多余的依赖和副作用 effect，虽然副作用本身和 name 并无关系。所以，我们可以在此基础上优化之：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">eff</span>) &#123;</span><br><span class="line">  activeEffect = eff;</span><br><span class="line">  <span class="title function_">eff</span>();</span><br><span class="line">  activeEffect = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">    deps.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reactive</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> handler = (target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get key :&gt;&gt; &#x27;</span>, key);</span><br><span class="line">      <span class="title function_">track</span>(target, key)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set key :&gt;&gt; &#x27;</span>, key);</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">      <span class="keyword">if</span> (oldValue !== value) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, key)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> product = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  total = product.<span class="property">quantity</span> * product.<span class="property">price</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total :&gt;&gt; &#x27;</span>, total); <span class="comment">// 10</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total :&gt;&gt; &#x27;</span>, total); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如上，已经比较好的实现了我们想要的效果。让我们来看看下面的测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> product = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> saleTotal = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  total = product.<span class="property">quantity</span> * product.<span class="property">price</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  saleTotal = total * <span class="number">0.8</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total, saleTotal); <span class="comment">//10 8</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total, saleTotal); <span class="comment">//12 8</span></span><br></pre></td></tr></table></figure><p><code>total</code> 确实响应式更新了，但是 <code>saleTotal</code> 并没有相对应更新，这是因为这里的 <code>total</code> 并不是响应式数据，那如何让它变为响应式数据呢，</p><ol><li>我们可以借助已经实现的 <code>reactive</code> ，包装如下，不过有些繁琐🤣</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ref</span> = (<span class="params">initVal</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reactive</span>(&#123; <span class="attr">value</span>: initVal &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> product = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> total = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> saleTotal = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  total.<span class="property">value</span> = product.<span class="property">quantity</span> * product.<span class="property">price</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  saleTotal = <span class="built_in">parseFloat</span>(total.<span class="property">value</span> * <span class="number">0.8</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) / <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total.<span class="property">value</span>, saleTotal); <span class="comment">//10 8</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total.<span class="property">value</span>, saleTotal); <span class="comment">//12 9.6</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ES5 提供的对象访问器或者 JS 的计算属性 <code>Object Accessors</code>。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ref</span> = (<span class="params">raw</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> r = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="title function_">track</span>(r, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> raw</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;newVal,raw :&gt;&gt; &#x27;</span>, newVal, raw);</span><br><span class="line">      <span class="keyword">if</span> (newVal !== raw) &#123;</span><br><span class="line">        raw = newVal</span><br><span class="line">        <span class="title function_">trigger</span>(r, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> product = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> total = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> saleTotal = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  total.<span class="property">value</span> = product.<span class="property">quantity</span> * product.<span class="property">price</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  saleTotal = <span class="built_in">parseFloat</span>(total.<span class="property">value</span> * <span class="number">0.8</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) / <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total.<span class="property">value</span>, saleTotal); <span class="comment">//10 8</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total.<span class="property">value</span>, saleTotal); <span class="comment">//12 9.6</span></span><br></pre></td></tr></table></figure><p>接下来实现 <code>Vue3</code>中的 真正的计算属性<code>computed</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">computed</span> = (<span class="params">getter</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">ref</span>()</span><br><span class="line">  <span class="title function_">effect</span>(<span class="function">() =&gt;</span> result.<span class="property">value</span> = <span class="title function_">getter</span>())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> product = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;西葫芦&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">quantity</span>: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> total = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> product.<span class="property">price</span> * product.<span class="property">quantity</span>)</span><br><span class="line"><span class="keyword">const</span> saleTotal = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="built_in">parseFloat</span>(total.<span class="property">value</span> * <span class="number">0.8</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) / <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total.<span class="property">value</span>, saleTotal.<span class="property">value</span>); <span class="comment">//10 8</span></span><br><span class="line">product.<span class="property">price</span> = <span class="number">12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;total,saleTotal :&gt;&gt; &#x27;</span>, total.<span class="property">value</span>, saleTotal.<span class="property">value</span>); <span class="comment">//12 9.6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Vue&lt;/code&gt; 中，响应式系统采取的是&lt;code&gt;发布订阅&lt;/code&gt;的模式，&lt;code&gt;Vue2&lt;/code&gt; 中主要依赖  ES5 &lt;code&gt;Object.defineProperty&lt;/code&gt; 的 API，在 &lt;code&gt;vue3&lt;/code&gt; 中重写了响应式系统，使用的是 ES6 &lt;code&gt;Proxy&lt;/code&gt; &lt;code&gt;Reflect&lt;/code&gt;，在它们不受支持的情况下会降级使用 &lt;code&gt;Object.defineProperty&lt;/code&gt;。今天我们来实现一个极其简易版的响应式系统。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue3" scheme="https://xiaozhouguo.github.io/categories/Vue3/"/>
    
    
    <category term="reactive" scheme="https://xiaozhouguo.github.io/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>JS 数组改变长度 - 探究 JS V8 引擎下的“数组”底层实现</title>
    <link href="https://xiaozhouguo.github.io/2022/05/23/javascript-array/"/>
    <id>https://xiaozhouguo.github.io/2022/05/23/javascript-array/</id>
    <published>2022-05-23T09:56:41.000Z</published>
    <updated>2022-06-02T04:49:09.634Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>有很多特性：存放不同类型元素、数组长度可变等等，这与数据结构中定义的数组结构或者C++、Java等语言中的数组不太一样，那么JS数组的这些特性底层是如何实现的呢，我们打开V8引擎的源码，从中寻找到了答案。V8中对数组做了一层封装，使其有两种实现方式：快数组和慢数组，快数组底层是连续内存，通过索引直接定位，慢数组底层是哈希表，通过计算哈希值来定位。两种实现方式各有特点，有各自的使用情况，也会相互转换。</p><span id="more"></span><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>使用 JS 的数组时，发现 JS 的数组可以存放不同类型的元素、并且<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6&spm=1001.2101.3001.7020">数组长度</a>是可变的。数据结构中定义的数组是定长的、数据类型一致的存储结构。JS 中的数组竟然如此特殊，这也是为什么标题中数组二字加上了“”的原因。带着一脸的懵逼，打开V8源码，一探究竟。</p><h3 id="二、什么是数组"><a href="#二、什么是数组" class="headerlink" title="二、什么是数组"></a>二、什么是数组</h3><p>首先来看下什么是数组，下面的图是维基百科上对于数组的定义：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/614d8cf62ca6005e781615bc63c89ee5.png" alt="614d8cf62ca6005e781615bc63c89ee5.png"></p><p>图中有两个关键的点，<strong>相同类型、连续内存</strong>。</p><p>这两个关键点先不必深究，继续往下看，下面来解释。</p><p>看完<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据结构</a>中的定义，再来看下具体语言中对数组的实现：</p><p>C、C++、Java、Scala 等语言中数组的实现，是通过在内存中划分一串连续的、固定长度的空间，来实现存放一组有限个相同数据类型的数据结构。这里面也涉及到了几个重要的概念：<strong>连续、固定长度、相同数据类型</strong>，与数据结构中的定义是类似的。</p><p>下面来分别解释下这几个概念：</p><h3 id="1-连续"><a href="#1-连续" class="headerlink" title="1.连续"></a><strong>1.连续</strong></h3><p><img src="https://img-blog.csdnimg.cn/img_convert/2b01729f7d6718990c2109b94cd15757.png" alt="2b01729f7d6718990c2109b94cd15757.png"></p><p>连续空间存储是数组的特点，下图是数组在内存中的存储示意图。</p><p>可以明显的看出各元素在内存中是相邻的，是一种线性的存储结构。</p><h3 id="2-固定长度"><a href="#2-固定长度" class="headerlink" title="2.固定长度"></a><strong>2.固定长度</strong></h3><p>因为数组的空间是连续的，这就意味着在内存中会有一整块空间来存放数组，如果不是固定长度，那么内存中位于数组之后的区域会没办法分配，内存不知道数组还要不要继续存放，要使用多长的空间。长度固定，就界定了数组使用内存的界限，数组之外的空间可以分配给别人使用。</p><h3 id="3-相同数据类型"><a href="#3-相同数据类型" class="headerlink" title="3.相同数据类型"></a><strong>3.相同数据类型</strong></h3><p>因为数组的长度是固定的，如果不是相同数据类型，一会存 int ，一会存String ，两种不同长度的数据类型，不能保证各自存放几个，这样有悖固定长度的规定，所以也要是相同的数据类型。</p><p>看到这，想必大部分人应该感觉：嗯，这跟我认识的数组几乎吻合吧。</p><p>那我们再来点刺激的，进入正菜，JavaScript 中的数组。</p><h3 id="三、JavaScript-中的数组"><a href="#三、JavaScript-中的数组" class="headerlink" title="三、JavaScript 中的数组"></a>三、JavaScript 中的数组</h3><p>先来看段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">100</span>, <span class="number">12.3</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">arr[arr.<span class="property">length</span>] = <span class="string">&quot;black&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>);    <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[arr.<span class="property">length</span>-<span class="number">1</span>]);  <span class="comment">//black</span></span><br></pre></td></tr></table></figure><p>这短短几行代码可以看出 JS 数组非同寻常的地方。</p><ul><li>第一行代码，数组中竟然存放了三种数据类型？</li><li>第二行代码，竟然向数组中添加了一个值？</li><li>第三行和第四行代码验证了，数组的长度改变了，添加的值也生效了。</li></ul><p>除了这些，JS的数组还有很多特殊的地方：</p><ol><li>JS 数组中不止可以存放上面的三种数据类型，它可以存放数组、对象、函数、Number、Undefined、Null、String、Boolean 等等。</li><li>JS 数组可以动态的改变容量，根据元素的数量来扩容、收缩。</li><li>JS 数组可以表现的像栈一样，为数组提供了push()和pop()方法。也可以表现的像队列一样，使用shift()和 push()方法，可以像使用队列一样使用数组。</li><li>JS 数组可以使用for-each遍历，可以排序，可以倒置。</li><li>JS 提供了很多操作数组的方法，比如Array.concat()、Array.join()、Array.slice()。</li></ol><p>看到这里，应该可以看出一点端倪，大胆猜想，JS的数组不是基础的数据结构实现的，应该是在基础上面做了一些封装。</p><p>下面发车，一步一步地验证我们的猜想。</p><h3 id="四、刨根问底：从V8源码上看数组的实现"><a href="#四、刨根问底：从V8源码上看数组的实现" class="headerlink" title="四、刨根问底：从V8源码上看数组的实现"></a>四、刨根问底：从V8源码上看数组的实现</h3><p>Talk is cheap，show me the code.</p><p>下面一图是 V8 中数组的源码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/80c753092161b0d33f245d2781e40692.png" alt="80c753092161b0d33f245d2781e40692.png"></p><p>首先，我们看到JSArray 是继承自JSObject，也就是说，数组是一个特殊的对象。</p><p>那这就好解释为什么JS的数组可以存放不同的数据类型，它是个对象嘛，内部也是key-value的存储形式。</p><p>我们使用这段代码来验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>通过 jsvu 来看一下底层是如何实现的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a07341549355753a228c730904af109f.png" alt="a07341549355753a228c730904af109f.png"></p><p>可以看到，底层就是个 Map ，key 为0，1，2，3这种索引，value 就是数组的元素。</p><p>其中，数组的index其实是字符串。</p><p>验证完这个问题，我们再继续看上面的V8源码，摩拳擦掌，准备见大招了！<br>从注释上可以看出，JS 数组有两种表现形式，fast 和 slow ，啥？英文看不懂？那我让谷歌帮我们翻译好了！</p><p><strong>fast ：</strong></p><p>快速的后备存储结构是 FixedArray ，并且数组长度 &lt;&#x3D; elements.length();</p><p><strong>slow ：</strong></p><p>缓慢的后备存储结构是一个以数字为键的 HashTable 。</p><p>HashTable，维基百科中解释的很好：</p><blockquote><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p></blockquote><p>源码注释中的fast和slow，只是简单的解释了一下，其对应的是快数组和慢数组，下面来具体的看一下两种形式是如何实现的。</p><h3 id="1、快数组（FAST-ELEMENTS）"><a href="#1、快数组（FAST-ELEMENTS）" class="headerlink" title="1、快数组（FAST ELEMENTS）"></a><strong>1、快数组（FAST ELEMENTS）</strong></h3><p>快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，那来看下源码中是怎么扩容和收缩的。</p><p>源码中<strong>扩容</strong>的实现方法（C++）：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/209f52ff6a46bcd62986b9cd2328fba6.png" alt="209f52ff6a46bcd62986b9cd2328fba6.png"></p><p>新容量的的计算方式：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1bd08f31e4b814add679140b9f9e1be5.png" alt="1bd08f31e4b814add679140b9f9e1be5.png"></p><p>即new_capacity &#x3D; old_capacity &#x2F;2 + old_capacity + 16</p><p>也就是，扩容后的新容量 &#x3D; 旧容量的1.5倍 + 16</p><p>扩容后会将数组拷贝到新的内存空间中，源码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7751af0eaa4f9021cd532c10193b087b.png" alt="7751af0eaa4f9021cd532c10193b087b.png"></p><p>看完了扩容，再来看看当空间多余时如何收缩数组空间。</p><p>源码中<strong>收缩</strong>的实现方法（C++）:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3e2ad0fb6658af1915fa658c329b5604.png" alt="3e2ad0fb6658af1915fa658c329b5604.png"></p><p>可以看出收缩数组的判断是：<br>如果容量 &gt;&#x3D; length的2倍 + 16，则进行收缩容量调整，否则用holes对象（什么是holes对象？下面来解释）填充未被初始化的位置。</p><p>如果收缩，那收缩到多大呢？</p><p>看上面图中的这段代码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f0945e1ea6eb3e6f11b1565dfea2f08.png" alt="6f0945e1ea6eb3e6f11b1565dfea2f08.png"></p><p>这个elements_to_trim就是需要收缩的大小，需要根据 length + 1 和 old_length 进行判断，是将空出的空间全部收缩掉还是只收缩二分之一。</p><p>解释完了扩容和减容，来看下刚刚提到的holes对象。</p><p>holes （空洞）对象指的是数组中分配了空间，但是没有存放元素的位置。对于holes，快数组中有个专门的模式，在 Fast Elements 模式中有一个扩展，是<strong>Fast Holey Elements</strong>模式。</p><p>Fast Holey Elements 模式适合于数组中的 holes （空洞）情况，即只有某些索引存有数据，而其他的索引都没有赋值的情况。</p><p>那什么时候会是Fast Holey Elements 模式呢？</p><p>当数组中有空洞，没有赋值的数组索引将会存储一个特殊的值，这样在访问这些位置时就可以得到 undefined。这种情况下就会是 Fast Holey Elements 模式。</p><p>Fast Holey Elements 模式与Fast Elements 模式一样，会动态分配连续的存储空间，分配空间的大小由最大的索引值决定。</p><p>新建数组时，如果没有设置容量，V8会默认使用 Fast Elements 模式实现。</p><p>如果要对数组设置容量，但并没有进行内部元素的初始化，例如let a &#x3D; new Array(10);，这样的话数组内部就存在了空洞，就会以Fast Holey Elements 模式实现。</p><p>使用jsvu调用v8-debug版本的底层实现来验证一下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/71a0c3cf12f6cf528553b436a8d298e7.png" alt="71a0c3cf12f6cf528553b436a8d298e7.png"></p><p>一目了然，<strong>HOLEY_SMI_ELEMENTS</strong> 就是Fast Holey Elements 模式 。</p><p>如果对数组进行了初始化，比如let a &#x3D; new Array(1,2,3);，这种就不存在空洞，就是以Fast Elements 模式实现。</p><p>验证：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/725c1705f8bf004ab5ae3dee697580e9.png" alt="725c1705f8bf004ab5ae3dee697580e9.png"></p><p>这个<strong>PACKED_SMI_ELEMENTS</strong>就是Fast Elements 模式。</p><p>快数组先到这，再来看下慢数组：</p><h3 id="2、慢数组（DICTIONARY-ELEMENTS）"><a href="#2、慢数组（DICTIONARY-ELEMENTS）" class="headerlink" title="2、慢数组（DICTIONARY ELEMENTS）"></a><strong>2、慢数组（DICTIONARY ELEMENTS）</strong></h3><p>慢数组是一种字典的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，其效率会比快数组低。</p><p>源码中 Dictionary 的结构</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1a9b879a0d9447fa40bd0c0d3c2ef5a3.png" alt="1a9b879a0d9447fa40bd0c0d3c2ef5a3.png"></p><p>可以看到，内部是一个HashTable，然后定义了一些操作方法，和 Java 的 HashMap类似，没有什么特别之处。</p><p>了解了数组的两种实现方式，我们来总结下两者的区别。</p><h3 id="3、快数组、慢数组的区别"><a href="#3、快数组、慢数组的区别" class="headerlink" title="3、快数组、慢数组的区别"></a><strong>3、快数组、慢数组的区别</strong></h3><ol><li><strong>存储方式方面：</strong>快数组内存中是连续的，慢数组在内存中是零散分配的。</li><li><strong>内存使用方面：</strong>由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还可能有很多空洞，是比较费内存的。慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。</li><li><strong>遍历效率方面：</strong>快数组由于是空间连续的，遍历速度很快，而慢数组每次都要寻找 key 的位置，遍历效率会差一些。</li></ol><p>既然有快数组和慢数组，两者的也有各自的特点，每个数组的存储结构不会是一成不变的，会有具体情况下的快慢数组转换，下面来看一下什么情况下会发生转换。</p><h3 id="五、快数组慢数组之间的转换"><a href="#五、快数组慢数组之间的转换" class="headerlink" title="五、快数组慢数组之间的转换"></a>五、快数组慢数组之间的转换</h3><h3 id="1、快-gt-慢"><a href="#1、快-gt-慢" class="headerlink" title="1、快 -&gt; 慢"></a><strong>1、快 -&gt; 慢</strong></h3><p>首先来看 V8 中判断快数组是否应该转为慢数组的源码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/794460d9dad2173a94982c3638b84d70.png" alt="794460d9dad2173a94982c3638b84d70.png"></p><p>关键代码：</p><ol><li>新容量 &gt;&#x3D; 3 * 扩容后的容量 * 2 ，会转变为慢数组。</li><li>当加入的 index- 当前capacity &gt;&#x3D; kMaxGap（1024） 时（也就是至少有了 1024 个空洞），会转变为慢数组。</li></ol><p>我们主要来看下第二种关键代码的情况。</p><p>kMaxGap 是源码中的一个常量，值为1024。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/eb59dd3a72eb5318618fc0c5de5bd795.png" alt="eb59dd3a72eb5318618fc0c5de5bd795.png"></p><p>也就是说，当对数组赋值时使用远超当前数组的容量+ 1024时（这样出现了大于等于 1024 个空洞，这时候要对数组分配大量空间则将可能造成存储空间的浪费，为了空间的优化，会转化为慢数组。</p><p>代码实锤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a[<span class="number">1030</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>数组中只有三个元素，但是却在 1030 的位置存放了一个值，那么中间会有多于1024个空洞，这时就会变为慢数组。</p><p>来验证一下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2fb59920cb43242f541c7a6309c89a04.png" alt="2fb59920cb43242f541c7a6309c89a04.png"></p><p>可以看到，此时的数组确实是字典类型了，成功！</p><p>好了，看完了快数组转慢数组，再反过来看下慢数组转换为快数组。</p><h3 id="2、慢-gt-快"><a href="#2、慢-gt-快" class="headerlink" title="2、慢 -&gt; 快"></a><strong>2、慢 -&gt; 快</strong></h3><p>处于哈希表实现的数组，在每次空间增长时， V8 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。</p><p>V8中是否应该转为快数组的判断源码：</p><p>关键代码：</p><p>当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间,则会转变为快数组</p><p><img src="https://img-blog.csdnimg.cn/img_convert/81d01f4d7eece56a4b9effeb4980ec5a.png" alt="81d01f4d7eece56a4b9effeb4980ec5a.png"></p><p>来写代码验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">a[<span class="number">1030</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">200</span>; i &lt; <span class="number">1030</span>; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们说过的，在 1030 的位置上面添加一个值，会造成多于 1024 个空洞，数组会使用为 Dictionary 模式来实现。</p><p>那么我们现在往这个数组中再添加几个值来填补空洞，往 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，会发生什么神奇的事情呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/aa4be8b8b462372dd2a112fd5350f6cb.png" alt="aa4be8b8b462372dd2a112fd5350f6cb.png"></p><p>可以看到，数组变成了快数组的 Fast Holey Elements 模式，验证成功。</p><p>那是不是快数组存储空间连续，效率高，就一定更好呢？其实不然。</p><h3 id="3、各有优势"><a href="#3、各有优势" class="headerlink" title="3、各有优势"></a><strong>3、各有优势</strong></h3><p>快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。<br>慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。</p><h3 id="六、扩展：ArrayBuffer"><a href="#六、扩展：ArrayBuffer" class="headerlink" title="六、扩展：ArrayBuffer"></a>六、扩展：ArrayBuffer</h3><p>JS在ES6也推出了可以按照需要分配连续内存的数组，这就是ArrayBuffer。</p><p>ArrayBuffer会从内存中申请设定的二进制大小的空间，但是并不能直接操作它，需要通过ArrayBuffer构建一个视图，通过视图来操作这个内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这行代码就申请了 1kb 的内存区域。但是并不能对 arrayBuffer 直接操作，需要将它赋给一个视图来操作内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intArray = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(bf);</span><br></pre></td></tr></table></figure><p>这行代码创建了有符号的32位的整数数组，每个数占 4 字节，长度也就是 1024 &#x2F; 4 &#x3D; 256 个。</p><p>代码验证：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bc32aa65458b5267ed77873edfe5d91d.png" alt="bc32aa65458b5267ed77873edfe5d91d.png"></p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>看到这，脑瓜子是不是嗡嗡的？喘口气，我们来回顾一下，这篇文章我们主要讨论了这几件事：</p><ol><li>传统意义上的数组是怎么样的</li><li>JavaScript 中的数组有哪些特别之处</li><li>从V8源码下研究 JS 数组的底层实现</li><li>JS 数组的两种模式是如何转换的</li><li>ArrayBuffer</li></ol><p>总的来说，JS 的数组看似与传统数组不一样，其实只是 V8 在底层实现上做了一层封装，使用两种数据结构实现数组，通过时间和空间纬度的取舍，优化数组的性能。</p><p>了解数组的底层实现，可以帮助我们写出执行效率更高的代码</p><blockquote><p>链接： <a href="https://blog.csdn.net/weixin_39992312/article/details/109976690">js 数组 改变长度_探究JS V8引擎下的“数组”底层实现_weixin_39992312的博客-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaScript 中的&lt;a href=&quot;https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020&quot;&gt;数组&lt;/a&gt;有很多特性：存放不同类型元素、数组长度可变等等，这与数据结构中定义的数组结构或者C++、Java等语言中的数组不太一样，那么JS数组的这些特性底层是如何实现的呢，我们打开V8引擎的源码，从中寻找到了答案。V8中对数组做了一层封装，使其有两种实现方式：快数组和慢数组，快数组底层是连续内存，通过索引直接定位，慢数组底层是哈希表，通过计算哈希值来定位。两种实现方式各有特点，有各自的使用情况，也会相互转换。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://xiaozhouguo.github.io/categories/JavaScript/"/>
    
    
    <category term="Array" scheme="https://xiaozhouguo.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>一窥 nextTick</title>
    <link href="https://xiaozhouguo.github.io/2022/05/21/vue/nextTick/"/>
    <id>https://xiaozhouguo.github.io/2022/05/21/vue/nextTick/</id>
    <published>2022-05-21T12:13:31.000Z</published>
    <updated>2022-06-02T04:59:47.426Z</updated>
    
    <content type="html"><![CDATA[<p>简而言之，<code>vue</code> 通过异步队列的方式控制<code>DOM</code>更新，而 <code>nextTick</code> 则是在下一次 <code>DOM</code> 更新之后执行其回调函数。</p><span id="more"></span><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，事件循环 <code>Event Loop</code>应运而生。</p><p>事件循环是通过任务队列的机制来进行协调。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。setTimeout&#x2F;Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。</p><p>在事件循环中，每进行一次循环操作称为 <code>tick</code>，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：</p><ul><li>在此次 tick 中选择最先进入队列的任务(oldest task)，如果有则执行(一次)</li><li>检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue</li><li>更新 render</li><li>主线程重复执行上述步骤</li></ul><p>在上诉tick的基础上需要了解几点：</p><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p><img src="https://pic4.zhimg.com/v2-d437562d6ea5874b3205701819bc1f27_r.jpg" alt="图示"></p><p><code>宏任务</code> (macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</p><p>浏览器为了能够使得 JS 内部 (macro)task 与 DOM 任务能够有序的执行，会在一个 (macro)task 执行结束后，在下一个 (macro)task 执行开始前，对页面进行重新渲染，流程如下：</p><blockquote><p>(macro)task -&gt; 渲染 -&gt; (macro)task -&gt; …</p></blockquote><blockquote><p>常见的宏任务有：script(整体代码)、setTimeout、setInterval、I&#x2F;O、UI交互、 postMessage、MessageChannel、setImmediate(node环境)。</p></blockquote><p>微任务 microtask，可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p><p>所以它的响应速度相比 setTimeout  等宏任务会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。</p><blockquote><p>常见的微任务有：Promise.then、Object.observe、MutationObserver、process.nextTick(node环境)</p></blockquote><p>在事件循环中，每进行一次循环操作称为 tick，无论是执行宏任务还是微任务，完成后都会进入到下一<code>tick</code>，<strong>并在两个<code>tick</code>之间进行UI渲染</strong>。每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><p><img src="https://pic2.zhimg.com/80/v2-e6dd78c74cb671dd9408c2273308a265_720w.jpg" alt="图示"></p><h3 id="vue-中的-nextTick"><a href="#vue-中的-nextTick" class="headerlink" title="vue 中的 nextTick"></a>vue 中的 nextTick</h3><p>vue2 中，<code>nextTick</code> 的实现单独有一个JS文件来维护它，在<code>src/core/util/next-tick.js</code>中。<code>nextTick</code> 源码主要分为两块：能力检测和根据能力检测以不同方式执行回调队列。</p><blockquote><p>优先级：Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</p><p>2.6 版本优先使用 microtask 作为异步延迟包装器，且写法相对简单。而2.5 版本中，nextTick 的实现是 microTimerFunc、macroTimerFunc 组合实现的，延迟调用优先级是：Promise &gt; setImmediate &gt; MessageChannel &gt; setTimeout。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="comment">/* globals MutationObserver */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">&#x27;./error&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">&#x27;./env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">  callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here we have async deferring wrappers using microtasks.</span></span><br><span class="line"><span class="comment">// In 2.5 we used (macro) tasks (in combination with microtasks).</span></span><br><span class="line"><span class="comment">// However, it has subtle problems when state is changed right before repaint</span></span><br><span class="line"><span class="comment">// (e.g. #6813, out-in transitions).</span></span><br><span class="line"><span class="comment">// Also, using (macro) tasks in event handler would cause some weird behaviors</span></span><br><span class="line"><span class="comment">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span></span><br><span class="line"><span class="comment">// So we now use microtasks everywhere, again.</span></span><br><span class="line"><span class="comment">// A major drawback of this tradeoff is that there are some scenarios</span></span><br><span class="line"><span class="comment">// where microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line"><span class="comment">// sequential events (e.g. #4521, #6690, which have workarounds)</span></span><br><span class="line"><span class="comment">// or even between bubbling of the same event (#6566).</span></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line"><span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line"><span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line"><span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line"><span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line"><span class="comment">// Promise is available, we will use it:</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  <span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分翻译如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空函数，可用作函数占位符</span></span><br><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/util&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 错误处理函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">&#x27;./error&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 是否是IE、IOS、内置函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">&#x27;./env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 MicroTask 的标识符，这里是因为火狐在&lt;=53时 无法触发微任务，在modules/events.js文件中引用进行安全排除</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 用来存储所有需要执行的回调函数</span></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来标志是否正在执行回调函数</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对callbacks进行遍历，然后执行相应的回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushCallbacks</span> () &#123;</span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 这里拷贝的原因是：</span></span><br><span class="line">    <span class="comment">// 有的cb 执行过程中又会往callbacks中加入内容</span></span><br><span class="line">    <span class="comment">// 比如 $nextTick的回调函数里还有$nextTick</span></span><br><span class="line">    <span class="comment">// 后者的应该放到下一轮的nextTick 中执行</span></span><br><span class="line">    <span class="comment">// 所以拷贝一份当前的，遍历执行完当前的即可，避免无休止的执行下去</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbcks.<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    callbacks.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerFunc <span class="comment">// 异步执行函数 用于异步延迟调用 flushCallbacks 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在2.5中，我们使用(宏)任务(与微任务结合使用)。</span></span><br><span class="line"><span class="comment">// 然而，当状态在重新绘制之前发生变化时，就会出现一些微妙的问题</span></span><br><span class="line"><span class="comment">// (例如#6813,out-in转换)。</span></span><br><span class="line"><span class="comment">// 同样，在事件处理程序中使用(宏)任务会导致一些奇怪的行为</span></span><br><span class="line"><span class="comment">// 因此，我们现在再次在任何地方使用微任务。</span></span><br><span class="line"><span class="comment">// 优先使用 Promise</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IOS 的UIWebView, Promise.then 回调被推入 microTask 队列，但是队列可能不会如期执行</span></span><br><span class="line">        <span class="comment">// 因此，添加一个空计时器强制执行 microTask</span></span><br><span class="line">        <span class="keyword">if</span>(isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">    &#125;</span><br><span class="line">    isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(!isIE &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (<span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) || <span class="title class_">MutationObserver</span>.<span class="property">toString</span> === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 当 原生Promise 不可用时，使用 原生MutationObserver</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 创建MO实例，监听到DOM变动后会执行回调flushCallbacks</span></span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">        <span class="attr">characterData</span>: <span class="literal">true</span> <span class="comment">// 设置true 表示观察目标的改变</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次执行timerFunc 都会让文本节点的内容在 0/1之间切换</span></span><br><span class="line">    <span class="comment">// 切换之后将新值复制到 MO 观测的文本节点上</span></span><br><span class="line">    <span class="comment">// 节点内容变化会触发回调</span></span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter) <span class="comment">// 触发回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// next-tick.js 对外暴露了nextTick这一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb? <span class="built_in">Function</span>, ctx: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    <span class="comment">// cb 回调函数会统一处理压入callbacks数组</span></span><br><span class="line">    callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cb) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">            <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pending 为false 说明本轮事件循环中没有执行过timerFunc()</span></span><br><span class="line">    <span class="keyword">if</span>(!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span></span><br><span class="line">        <span class="title function_">timerFunc</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当不传入 cb 参数时，提供一个promise化的调用</span></span><br><span class="line">    <span class="comment">// 如nextTick().then(() =&gt; &#123;&#125;)</span></span><br><span class="line">    <span class="comment">// 当_resolve执行时，就会跳转到then逻辑中</span></span><br><span class="line">    <span class="keyword">if</span>(!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            _resolve = resolve</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简而言之，&lt;code&gt;vue&lt;/code&gt; 通过异步队列的方式控制&lt;code&gt;DOM&lt;/code&gt;更新，而 &lt;code&gt;nextTick&lt;/code&gt; 则是在下一次 &lt;code&gt;DOM&lt;/code&gt; 更新之后执行其回调函数。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue2" scheme="https://xiaozhouguo.github.io/categories/Vue2/"/>
    
    
    <category term="nextTick" scheme="https://xiaozhouguo.github.io/tags/nextTick/"/>
    
    <category term="Promise" scheme="https://xiaozhouguo.github.io/tags/Promise/"/>
    
  </entry>
  
</feed>
