{"meta":{"title":"We Are ALL Made Of Star Stuff","subtitle":"steps-by-steps","description":"start from zero","author":"guoxiaozhou","url":"https://xiaozhouguo.github.io"},"pages":[{"title":"category","date":"2017-08-14T12:23:29.000Z","updated":"2017-08-14T12:23:30.000Z","comments":true,"path":"category/index.html","permalink":"https://xiaozhouguo.github.io/category/index.html","excerpt":"","text":""},{"title":"about","date":"2022-06-02T04:55:08.000Z","updated":"2022-06-02T04:55:08.916Z","comments":true,"path":"about/index.html","permalink":"https://xiaozhouguo.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-08-14T12:21:06.000Z","updated":"2017-08-14T12:21:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://xiaozhouguo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"构造AST的完整流程是怎样的？ -下篇","slug":"vue3/ast-two","date":"2022-08-31T06:52:33.000Z","updated":"2022-08-31T07:28:20.584Z","comments":true,"path":"2022/08/31/vue3/ast-two/","link":"","permalink":"https://xiaozhouguo.github.io/2022/08/31/vue3/ast-two/","excerpt":"这一节课我们依然要解析 template 生成 AST 背后的实现原理，之前，我们知道了baseParse 主要就做三件事情：创建解析上下文，解析子节点，创建 AST 根节点","text":"这一节课我们依然要解析 template 生成 AST 背后的实现原理，之前，我们知道了baseParse 主要就做三件事情：创建解析上下文，解析子节点，创建 AST 根节点 我们讲到了解析子节点，主要有四种情况，分别是注释节点的解析、插值的解析、普通文本的解析，以及元素节点的解析，这节课我们就到了最后的元素节点。 解析子节点元素节点的解析我们来看元素节点的解析过程，它会解析模板中的标签节点，举个例子： 123&lt;div class=&quot;app&quot;&gt; &lt;hello :msg=&quot;msg&quot;&gt;&lt;/hello&gt;&lt;/div&gt; 相对于前面三种类型的解析过程，元素节点的解析过程应该是最复杂的了，即当前代码 s 是以 &lt; 开头，并且后面跟着字母，说明它是一个标签的开头，则走到元素节点的解析处理逻辑，我们来看 parseElement 的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function parseElement(context, ancestors) &#123; // 是否在 pre 标签内 const wasInPre = context.inPre // 是否在 v-pre 指令内 const wasInVPre = context.inVPre // 获取当前元素的父标签节点 const parent = last(ancestors) // 解析开始标签，生成一个标签节点，并前进代码到开始标签后 const element = parseTag(context, 0 /* Start */, parent) // 是否在 pre 标签的边界 const isPreBoundary = context.inPre &amp;&amp; !wasInPre // 是否在 v-pre 指令的边界 const isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre if (element.isSelfClosing || context.options.isVoidTag(element.tag)) &#123; // 如果是自闭和标签，直接返回标签节点 return element &#125; // 下面是处理子节点的逻辑 // 先把标签节点添加到 ancestors，入栈 ancestors.push(element) const mode = context.options.getTextMode(element, parent) // 递归解析子节点，传入 ancestors const children = parseChildren(context, mode, ancestors) // ancestors 出栈 ancestors.pop() // 添加到 children 属性中 element.children = children // 结束标签 if (startsWithEndTagOpen(context.source, element.tag)) &#123; // 解析结束标签，并前进代码到结束标签后 parseTag(context, 1 /* End */, parent) &#125; else &#123; emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start); if (context.source.length === 0 &amp;&amp; element.tag.toLowerCase() === &#x27;script&#x27;) &#123; const first = children[0]; if (first &amp;&amp; startsWith(first.loc.source, &#x27;&lt;!--&#x27;)) &#123; emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */) &#125; &#125; &#125; // 更新标签节点的代码位置，结束位置到结束标签后 element.loc = getSelection(context, element.loc.start) if (isPreBoundary) &#123; context.inPre = false &#125; if (isVPreBoundary) &#123; context.inVPre = false &#125; return element&#125; 可以看到，这个过程中 parseElement 主要做了三件事情：解析开始标签，解析子节点，解析闭合标签。 首先，我们来看解析开始标签的过程。主要通过 parseTag 方法来解析并创建一个标签节点，来看它的实现原理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function parseTag(context, type, parent) &#123; // 标签打开 const start = getCursor(context) // 匹配标签文本结束的位置 const match = /^&lt;\\/?([a-z][^\\t\\r\\n\\f /&gt;]*)/i.exec(context.source); const tag = match[1]; const ns = context.options.getNamespace(tag, parent); // 前进代码到标签文本结束位置 advanceBy(context, match[0].length); // 前进代码到标签文本后面的空白字符后 advanceSpaces(context); // 保存当前状态以防我们需要用 v-pre 重新解析属性 const cursor = getCursor(context); const currentSource = context.source; // 解析标签中的属性，并前进代码到属性后 let props = parseAttributes(context, type); // 检查是不是一个 pre 标签 if (context.options.isPreTag(tag)) &#123; context.inPre = true; &#125; // 检查属性中有没有 v-pre 指令 if (!context.inVPre &amp;&amp; props.some(p =&gt; p.type === 7 /* DIRECTIVE */ &amp;&amp; p.name === &#x27;pre&#x27;)) &#123; context.inVPre = true; // 重置 context extend(context, cursor); context.source = currentSource; // 重新解析属性，并把 v-pre 过滤了 props = parseAttributes(context, type).filter(p =&gt; p.name !== &#x27;v-pre&#x27;); &#125; // 标签闭合 let isSelfClosing = false; if (context.source.length === 0) &#123; emitError(context, 9 /* EOF_IN_TAG */); &#125; else &#123; // 判断是否自闭合标签 isSelfClosing = startsWith(context.source, &#x27;/&gt;&#x27;); if (type === 1 /* End */ &amp;&amp; isSelfClosing) &#123; // 结束标签不应该是自闭和标签 emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */); &#125; // 前进代码到闭合标签后 advanceBy(context, isSelfClosing ? 2 : 1); &#125; let tagType = 0 /* ELEMENT */; const options = context.options; // 接下来判断标签类型，是组件、插槽还是模板 if (!context.inVPre &amp;&amp; !options.isCustomElement(tag)) &#123; // 判断是否有 is 属性 const hasVIs = props.some(p =&gt; p.type === 7 /* DIRECTIVE */ &amp;&amp; p.name === &#x27;is&#x27;); if (options.isNativeTag &amp;&amp; !hasVIs) &#123; if (!options.isNativeTag(tag)) tagType = 1 /* COMPONENT */; &#125; else if (hasVIs || isCoreComponent(tag) || (options.isBuiltInComponent &amp;&amp; options.isBuiltInComponent(tag)) || /^[A-Z]/.test(tag) || tag === &#x27;component&#x27;) &#123; tagType = 1 /* COMPONENT */; &#125; if (tag === &#x27;slot&#x27;) &#123; tagType = 2 /* SLOT */; &#125; else if (tag === &#x27;template&#x27; &amp;&amp; props.some(p =&gt; &#123; return (p.type === 7 /* DIRECTIVE */ &amp;&amp; isSpecialTemplateDirective(p.name)); &#125;)) &#123; tagType = 3 /* TEMPLATE */; &#125; &#125; return &#123; type: 1 /* ELEMENT */, ns, tag, tagType, props, isSelfClosing, children: [], loc: getSelection(context, start), codegenNode: undefined &#125;;&#125; parseTag 首先匹配标签文本结束的位置，并前进代码到标签文本后面的空白字符后，然后解析标签中的属性，比如 class、style 和指令等，parseAttributes 函数的实现我就不多说了，感兴趣的同学可以自己去看，它最终会解析生成一个 props 的数组，并前进代码到属性后。 接着去检查是不是一个 pre 标签，如果是则设置 context.inPre 为 true；再去检查属性中有没有 v-pre 指令，如果有则设置 context.inVPre 为 true，并重置上下文 context 和重新解析属性；接下来再去判断是不是一个自闭和标签，并前进代码到闭合标签后；最后判断标签类型，是组件、插槽还是模板。 parseTag 最终返回的值就是一个描述标签节点的对象，其中 type 表示它是一个标签节点，tag 表示标签名称，tagType 表示标签的类型，content 表示文本的内容，isSelfClosing 表示是否是一个闭合标签，loc 表示文本的代码开头和结束的位置信息，children 是标签的子节点数组，会先初始化为空。 解析完开始标签后，再回到 parseElement，接下来第二步就是解析子节点，它把解析好的 element 节点添加到 ancestors 数组中，然后执行 parseChildren 去解析子节点，并传入 ancestors。 如果有嵌套的标签，那么就会递归执行 parseElement，可以看到，在 parseElement 的一开始，我们能获取 ancestors 数组的最后一个值拿到父元素的标签节点，这个就是我们在执行 parseChildren 前添加到数组尾部的。 解析完子节点后，我们再把 element 从 ancestors 中弹出，然后把 children 数组添加到 element.children 中，同时也把代码前进到子节点的末尾。 最后，就是解析结束标签，并前进代码到结束标签后，然后更新标签节点的代码位置。parseElement 最终返回的值就是这样一个标签节点 element。 其实 HTML 的嵌套结构的解析过程，就是一个递归解析元素节点的过程，为了维护父子关系，当需要解析子节点时，我们就把当前节点入栈，子节点解析完毕后，我们就把当前节点出栈，因此 ancestors 的设计就是一个栈的数据结构，整个过程是一个不断入栈和出栈的过程。 通过不断地递归解析，我们就可以完整地解析整个模板，并且标签类型的 AST 节点会保持对子节点数组的引用，这样就构成了一个树形的数据结构，所以整个解析过程构造出的 AST 节点数组就能很好地映射整个模板的 DOM 结构。 空白字符管理在前面的解析过程中，有些时候我们会遇到空白字符的情况，比如前面的例子： 123&lt;div class=&quot;app&quot;&gt; &lt;hello :msg=&quot;msg&quot;&gt;&lt;/hello&gt;&lt;/div&gt; div 标签到下一行会有一个换行符，hello 标签前面也有空白字符，这些空白字符在解析的过程中会被当作文本节点解析处理。但这些空白节点显然是没有什么意义的，所以我们需要移除这些节点，减少后续对这些没用意义的节点的处理，以提高编译效率。 我们先来看一下空白字符管理相关逻辑代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function parseChildren(context, mode, ancestors) &#123; const parent = last(ancestors) const ns = parent ? parent.ns : 0 /* HTML */ const nodes = [] // 自顶向下分析代码，生成 nodes let removedWhitespace = false if (mode !== 2 /* RAWTEXT */) &#123; if (!context.inPre) &#123; for (let i = 0; i &lt; nodes.length; i++) &#123; const node = nodes[i] if (node.type === 2 /* TEXT */) &#123; if (!/[^\\t\\r\\n\\f ]/.test(node.content)) &#123; // 匹配空白字符 const prev = nodes[i - 1] const next = nodes[i + 1] // 如果空白字符是开头或者结尾节点 // 或者空白字符与注释节点相连 // 或者空白字符在两个元素之间并包含换行符 // 那么这些空白字符节点都应该被移除 if (!prev || !next || prev.type === 3 /* COMMENT */ || next.type === 3 /* COMMENT */ || (prev.type === 1 /* ELEMENT */ &amp;&amp; next.type === 1 /* ELEMENT */ &amp;&amp; /[\\r\\n]/.test(node.content))) &#123; removedWhitespace = true nodes[i] = null &#125; else &#123; // 否则压缩这些空白字符到一个空格 node.content = &#x27; &#x27; &#125; &#125; else &#123; // 替换内容中的空白空间到一个空格 node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, &#x27; &#x27;) &#125; &#125; else if (!(process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; node.type === 3 /* COMMENT */) &#123; // 生产环境移除注释节点 removedWhitespace = true nodes[i] = null &#125; &#125; &#125; else if (parent &amp;&amp; context.options.isPreTag(parent.tag)) &#123; // 根据 HTML 规范删除前导换行符 const first = nodes[0] if (first &amp;&amp; first.type === 2 /* TEXT */) &#123; first.content = first.content.replace(/^\\r?\\n/, &#x27;&#x27;) &#125; &#125; &#125; // 过滤空白字符节点 return removedWhitespace ? nodes.filter(Boolean) : nodes&#125; 创建 AST 根节点子节点解析完毕，baseParse 过程就剩最后一步创建 AST 根节点了，我们来看一下 createRoot 的实现： 123456789101112131415function createRoot(children, loc = locStub) &#123; return &#123; type: 0 /* ROOT */, children, helpers: [], components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: undefined, loc &#125;&#125; createRoot 的实现非常简单，它就是返回一个 JavaScript 对象，作为 AST 根节点。其中 type 表示它是一个根节点类型，children 是我们前面解析的子节点数组。除此之外，这个根节点还添加了其它的属性，当前我们并不需要搞清楚每一个属性代表的含义，这些属性我们在分析后续的处理流程中会介绍。 总结好的，到这里我们这一节的学习也要结束啦，通过这节课的学习，你应该掌握 Vue.js 编译过程的第一步，即把 template 解析生成 AST 对象，整个解析过程是一个自顶向下的分析过程，也就是从代码开始，通过语法分析，找到对应的解析处理逻辑，创建 AST 节点，处理的过程中也在不断前进代码，更新解析上下文，最终根据生成的 AST 节点数组创建 AST 根节点。 本节课的相关代码在源代码中的位置如下：packages&#x2F;compiler-core&#x2F;src&#x2F;parse.tspackages&#x2F;compiler-core&#x2F;src&#x2F;ast.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"AST","slug":"AST","permalink":"https://xiaozhouguo.github.io/tags/AST/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"AST 节点内部做了哪些转换？- 上篇","slug":"vue3/ast-transform-one","date":"2022-08-03T02:05:13.000Z","updated":"2022-08-03T09:25:26.425Z","comments":true,"path":"2022/08/03/vue3/ast-transform-one/","link":"","permalink":"https://xiaozhouguo.github.io/2022/08/03/vue3/ast-transform-one/","excerpt":"上一篇文章中，我们学习了 template 的解析过程，最终拿到了一个 AST 节点对象。这个对象是对模板的完整描述，但是它还不能直接拿来生成代码，因为它的语义化还不够，没有包含和编译优化的相关属性，所以还需要进一步转换。","text":"上一篇文章中，我们学习了 template 的解析过程，最终拿到了一个 AST 节点对象。这个对象是对模板的完整描述，但是它还不能直接拿来生成代码，因为它的语义化还不够，没有包含和编译优化的相关属性，所以还需要进一步转换。 前言AST 转换过程非常复杂，有非常多的分支逻辑，为了方便你理解它的核心流程，我精心准备了一个示例，我们只分析示例场景在 AST 转换过程中的相关代码逻辑，不过我希望你在学习完之后，可以举一反三，对示例做一些修改，学习更多场景的代码逻辑。 12345678&lt;div class=&quot;app&quot;&gt; &lt;hello v-if=&quot;flag&quot;&gt;&lt;/hello&gt; &lt;div v-else&gt; &lt;p&gt;&gt;hello &#123;&#123; msg + test &#125;&#125;&lt;/p&gt; &lt;p&gt;static&lt;/p&gt; &lt;p&gt;static&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 示例中，我们有普通的 DOM 节点，有组件节点，有 v-bind 指令，有 v-if 指令，有文本节点，也有表达式节点。 对于这个模板，我们通过 parse 生成一个 AST 对象，接下来我们就来分析这个 AST 对象的转换都做了哪些事情。 我们会先通过 getBaseTransformPreset 方法获取节点和指令转换的方法，然后调用 transform 方法做 AST 转换，并且把这些节点和指令的转换方法作为配置的属性参数传入。 12345678910111213// 获取节点和指令转换的方法const [nodeTransforms, directiveTransforms] = getBaseTransformPreset()// AST 转换transform(ast, extend(&#123;&#125;, options, &#123; prefixIdentifiers, nodeTransforms: [ ...nodeTransforms, ...(options.nodeTransforms || []) // 用户自定义 transforms ], directiveTransforms: extend(&#123;&#125;, directiveTransforms, options.directiveTransforms || &#123;&#125; // 用户自定义 transforms )&#125;)) 我们先来看一下 getBaseTransformPreset 返回哪些节点和指令的转换方法： 12345678910111213141516171819function getBaseTransformPreset(prefixIdentifiers) &#123; return [ [ transformOnce, transformIf, transformFor, transformExpression, transformSlotOutlet, transformElement, trackSlotScopes, transformText ], &#123; on: transformOn, bind: transformBind, model: transformModel &#125; ]&#125; 这里并不需要你进一步去看每个转换函数的实现，只要大致了解有哪些转换函数即可，这些转换函数会在后续执行 transform 的时候调用。 注意这里我们只分析在 Node.js 环境下的编译过程。Web 环境的编译结果可能会有一些差别，我们会在后续章节说明。 我们主要来看 transform 函数的实现： 1234567891011121314151617function transform(root, options) &#123; const context = createTransformContext(root, options) traverseNode(root, context) if (options.hoistStatic) &#123; hoistStatic(root, context) &#125; if (!options.ssr) &#123; createRootCodegen(root, context) &#125; root.helpers = [...context.helpers] root.components = [...context.components] root.directives = [...context.directives] root.imports = [...context.imports] root.hoists = context.hoists root.temps = context.temps root.cached = context.cached&#125; transform 的核心流程主要有四步：创建 transform 上下文、遍历 AST 节点、静态提升以及创建根代码生成节点。接下来，我们就好好分析一下每一步主要做了什么。 创建 transform 上下文首先，我们来看创建 transform 上下文的过程，其实和 parse 过程一样，在 transform 阶段会创建一个上下文对象，它的实现过程是这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function createTransformContext(root, &#123; prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = &#123;&#125;, transformHoist = null, isBuiltInComponent = NOOP, expressionPlugins = [], scopeId = null, ssr = false, onError = defaultOnError &#125;) &#123; const context = &#123; // 配置 prefixIdentifiers, hoistStatic, cacheHandlers, nodeTransforms, directiveTransforms, transformHoist, isBuiltInComponent, expressionPlugins, scopeId, ssr, onError, // 状态数据 root, helpers: new Set(), components: new Set(), directives: new Set(), hoists: [], imports: new Set(), temps: 0, cached: 0, identifiers: &#123;&#125;, scopes: &#123; vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 &#125;, parent: null, currentNode: root, childIndex: 0, // methods helper(name) &#123; context.helpers.add(name) return name &#125;, helperString(name) &#123; return `_$&#123;helperNameMap[context.helper(name)]&#125;` &#125;, replaceNode(node) &#123; context.parent.children[context.childIndex] = context.currentNode = node &#125;, removeNode(node) &#123; const list = context.parent.children const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1 if (!node || node === context.currentNode) &#123; // 移除当前节点 context.currentNode = null context.onNodeRemoved() &#125; else &#123; // 移除兄弟节点 if (context.childIndex &gt; removalIndex) &#123; context.childIndex-- context.onNodeRemoved() &#125; &#125; // 移除节点 context.parent.children.splice(removalIndex, 1) &#125;, onNodeRemoved: () =&gt; &#123; &#125;, addIdentifiers(exp) &#123; &#125;, removeIdentifiers(exp) &#123; &#125;, hoist(exp) &#123; context.hoists.push(exp) const identifier = createSimpleExpression(`_hoisted_$&#123;context.hoists.length&#125;`, false, exp.loc, true) identifier.hoisted = exp return identifier &#125;, cache(exp, isVNode = false) &#123; return createCacheExpression(++context.cached, exp, isVNode) &#125; &#125; return context&#125; 其实，这个上下文对象 context 维护了 transform 过程的一些配置，比如前面提到的节点和指令的转换函数等；还维护了 transform 过程的一些状态数据，比如当前处理的 AST 节点，当前 AST 节点在子节点中的索引，以及当前 AST 节点的父节点等。此外，context 还包含了在转换过程中可能会调用的一些辅助函数，和一些修改 context 对象的方法。 你现在也没必要去了解它的每一个属性和方法的含义，只需要你大致有一个印象即可，未来分析某个具体场景，再回过头了解它们的实现即可。 创建完上下文对象后，接下来就需要遍历 AST 节点。 遍历 AST 节点遍历 AST 节点的过程很关键，因为核心的转换过程就是在遍历中实现的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function traverseNode(node, context) &#123; context.currentNode = node // 节点转换函数 const &#123; nodeTransforms &#125; = context const exitFns = [] for (let i = 0; i &lt; nodeTransforms.length; i++) &#123; // 有些转换函数会设计一个退出函数，在处理完子节点后执行 const onExit = nodeTransforms[i](node, context) if (onExit) &#123; if (isArray(onExit)) &#123; exitFns.push(...onExit) &#125; else &#123; exitFns.push(onExit) &#125; &#125; if (!context.currentNode) &#123; // 节点被移除 return &#125; else &#123; // 因为在转换的过程中节点可能被替换，恢复到之前的节点 node = context.currentNode &#125; &#125; switch (node.type) &#123; case 3 /* COMMENT */: if (!context.ssr) &#123; // 需要导入 createComment 辅助函数 context.helper(CREATE_COMMENT) &#125; break case 5 /* INTERPOLATION */: // 需要导入 toString 辅助函数 if (!context.ssr) &#123; context.helper(TO_DISPLAY_STRING) &#125; break case 9 /* IF */: // 递归遍历每个分支节点 for (let i = 0; i &lt; node.branches.length; i++) &#123; traverseNode(node.branches[i], context) &#125; break case 10 /* IF_BRANCH */: case 11 /* FOR */: case 1 /* ELEMENT */: case 0 /* ROOT */: // 遍历子节点 traverseChildren(node, context) break &#125; // 执行转换函数返回的退出函数 let i = exitFns.length while (i--) &#123; exitFns[i]() &#125;&#125; 这里，traverseNode 函数的基本思路就是递归遍历 AST 节点，针对每个节点执行一系列的转换函数，有些转换函数还会设计一个退出函数，当你执行转换函数后，它会返回一个新函数，然后在你处理完子节点后再执行这些退出函数，这是因为有些逻辑的处理需要依赖子节点的处理结果才能继续执行。 Vue.js 内部大概内置了八种转换函数，分别处理指令、表达式、元素节点、文本节点等不同的特性。限于篇幅，我不会介绍所有转换函数，感兴趣的同学可以后续自行分析。 下面我会介绍四种类型的转换函数，并结合前面的示例来分析。 Element 节点转换函数首先，我们来看一下 Element 节点转换函数的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125const transformElement = (node, context) =&gt; &#123; if (!(node.type === 1 /* ELEMENT */ &amp;&amp; (node.tagType === 0 /* ELEMENT */ || node.tagType === 1 /* COMPONENT */))) &#123; return &#125; // 返回退出函数，在所有子表达式处理并合并后执行 return function postTransformElement() &#123; // 转换的目标是创建一个实现 VNodeCall 接口的代码生成节点 const &#123; tag, props &#125; = node const isComponent = node.tagType === 1 /* COMPONENT */ const vnodeTag = isComponent ? resolveComponentType(node, context) : `&quot;$&#123;tag&#125;&quot;` const isDynamicComponent = isObject(vnodeTag) &amp;&amp; vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT // 属性 let vnodeProps // 子节点 let vnodeChildren // 标记更新的类型标识，用于运行时优化 let vnodePatchFlag let patchFlag = 0 // 动态绑定的属性 let vnodeDynamicProps let dynamicPropNames let vnodeDirectives // 动态组件、svg、foreignObject 标签以及动态绑定 key prop 的节点都被视作一个 Block let shouldUseBlock = isDynamicComponent || (!isComponent &amp;&amp; (tag === &#x27;svg&#x27; || tag === &#x27;foreignObject&#x27; || findProp(node, &#x27;key&#x27;, true))) // 处理 props if (props.length &gt; 0) &#123; const propsBuildResult = buildProps(node, context) vnodeProps = propsBuildResult.props patchFlag = propsBuildResult.patchFlag dynamicPropNames = propsBuildResult.dynamicPropNames const directives = propsBuildResult.directives vnodeDirectives = directives &amp;&amp; directives.length ? createArrayExpression(directives.map( dir =&gt; buildDirectiveArgs(dir, context)) ) : undefined &#125; // 处理 children if (node.children.length &gt; 0) &#123; if (vnodeTag === KEEP_ALIVE) &#123; // 把 KeepAlive 看做是一个 Block，这样可以避免它的子节点的动态节点被父 Block 收集 shouldUseBlock = true // 2. 确保它始终更新 patchFlag |= 1024 /* DYNAMIC_SLOTS */ if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; node.children.length &gt; 1) &#123; context.onError(createCompilerError(42 /* X_KEEP_ALIVE_INVALID_CHILDREN */, &#123; start: node.children[0].loc.start, end: node.children[node.children.length - 1].loc.end, source: &#x27;&#x27; &#125;)) &#125; &#125; const shouldBuildAsSlots = isComponent &amp;&amp; // Teleport不是一个真正的组件，它有专门的运行时处理 vnodeTag !== TELEPORT &amp;&amp; vnodeTag !== KEEP_ALIVE if (shouldBuildAsSlots) &#123; // 组件有 children，则处理插槽 const &#123; slots, hasDynamicSlots &#125; = buildSlots(node, context) vnodeChildren = slots if (hasDynamicSlots) &#123; patchFlag |= 1024 /* DYNAMIC_SLOTS */ &#125; &#125; else if (node.children.length === 1 &amp;&amp; vnodeTag !== TELEPORT) &#123; const child = node.children[0] const type = child.type const hasDynamicTextChild = type === 5 /* INTERPOLATION */ || type === 8 /* COMPOUND_EXPRESSION */ if (hasDynamicTextChild &amp;&amp; !getStaticType(child)) &#123; patchFlag |= 1 /* TEXT */ &#125; // 如果只是一个普通文本节点、插值或者表达式，直接把节点赋值给 vnodeChildren if (hasDynamicTextChild || type === 2 /* TEXT */) &#123; vnodeChildren = child &#125; else &#123; vnodeChildren = node.children &#125; &#125; else &#123; vnodeChildren = node.children &#125; &#125; // 处理 patchFlag 和 dynamicPropNames if (patchFlag !== 0) &#123; if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; if (patchFlag &lt; 0) &#123; vnodePatchFlag = patchFlag + ` /* $&#123;PatchFlagNames[patchFlag]&#125; */` &#125; else &#123; // 获取 flag 对应的名字，生成注释，方便理解生成代码对应节点的 pathFlag const flagNames = Object.keys(PatchFlagNames) .map(Number) .filter(n =&gt; n &gt; 0 &amp;&amp; patchFlag &amp; n) .map(n =&gt; PatchFlagNames[n]) .join(`, `) vnodePatchFlag = patchFlag + ` /* $&#123;flagNames&#125; */` &#125; &#125; else &#123; vnodePatchFlag = String(patchFlag) &#125; if (dynamicPropNames &amp;&amp; dynamicPropNames.length) &#123; vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames) &#125; &#125; node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc ) &#125;&#125; 可以看到，只有当 AST 节点是组件或者普通元素节点时，才会返回一个退出函数，而且它会在该节点的子节点逻辑处理完毕后执行。 分析这个退出函数前，我们需要知道节点函数的转换目标，即创建一个实现 VNodeCall 接口的代码生成节点，也就是说，生成这个代码生成节点后，后续的代码生成阶段可以根据这个节点对象生成目标代码。 知道了这个目标，我们再去理解 transformElement 函数的实现就不难了。 首先，判断这个节点是不是一个 Block 节点。 为了运行时的更新优化，Vue.js 3.0 设计了一个 Block tree 的概念。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，极大优化了 diff 的效率，模板的动静比越大，这个优化就会越明显。 因此在编译阶段，我们需要找出哪些节点可以构成一个 Block，其中动态组件、svg、foreignObject 标签以及动态绑定的 prop 的节点都被视作一个 Block。 其次，是处理节点的 props。 这个过程主要是从 AST 节点的 props 对象中进一步解析出指令 vnodeDirectives、动态属性 dynamicPropNames，以及更新标识 patchFlag。patchFlag 主要用于标识节点更新的类型，在组件更新的优化中会用到，我们在后续章节会详细讲。 接着，是处理节点的 children。 对于一个组件节点而言，如果它有子节点，则说明是组件的插槽，另外还会有对一些内置组件比如 KeepAlive、Teleport 的处理逻辑。 对于一个普通元素节点，我们通常直接拿节点的 children 属性给 vnodeChildren 即可，但有一种特殊情况，如果节点只有一个子节点，并且是一个普通文本节点、插值或者表达式，那么直接把节点赋值给 vnodeChildren。 然后，会对前面解析 props 求得的 patchFlag 和 dynamicPropNames 做进一步处理。 在这个过程中，我们会根据 patchFlag 的值从 PatchFlagNames 中获取 flag 对应的名字，从而生成注释，因为 patchFlag 本身就是一个个数字，通过名字注释的方式，我们就可以一眼从最终生成的代码中了解到 patchFlag 代表的含义。 另外，我们还会把数组 dynamicPropNames 转化生成 vnodeDynamicProps 字符串，便于后续对节点生成代码逻辑的处理。 最后，通过 createVNodeCall 创建了实现 VNodeCall 接口的代码生成节点，我们来看它的实现： 1234567891011121314151617181920212223242526function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) &#123; if (context) &#123; if (isBlock) &#123; context.helper(OPEN_BLOCK) context.helper(CREATE_BLOCK) &#125; else &#123; context.helper(CREATE_VNODE) &#125; if (directives) &#123; context.helper(WITH_DIRECTIVES) &#125; &#125; return &#123; type: 13 /* VNODE_CALL */, tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, loc &#125;&#125; createVNodeCall 的实现很简单，它最后返回了一个对象，包含了传入的参数数据。这里要注意 context.helper 函数的调用，它会把一些 Symbol 对象添加到 context.helpers 数组中，目的是为了后续代码生成阶段，生成一些辅助代码。 对于我们示例中的根节点： 123&lt;div class=&quot;app&quot;&gt; // ...&lt;/div&gt; 它转换后生成的 node.codegenNode ： 123456789101112131415&#123; &quot;children&quot;: [ // 子节点 ], &quot;directives&quot;: undefined, &quot;dynamicProps&quot;: undefined, &quot;isBlock&quot;: false, &quot;isForBlock&quot;: false, &quot;patchFlag&quot;: undefined, &quot;props&quot;: &#123; // 属性相关 &#125;, &quot;tag&quot;: &quot;div&quot;, &quot;type&quot;: 13&#125; 这个 codegenNode 相比之前的 AST 节点对象，多了很多和编译优化相关的属性，它们会在代码生成阶段会起到非常重要作用，在后续的章节你就可以深入了解到。 这个 codegenNode 相比之前的 AST 节点对象，多了很多和编译优化相关的属性，它们会在代码生成阶段会起到非常重要作用，在后续的章节你就可以深入了解到。 表达式节点转换函数接下来，我们来看一下表达式节点转换函数的实现： 12345678910111213141516171819202122232425const transformExpression = (node, context) =&gt; &#123; if (node.type === 5 /* INTERPOLATION */) &#123; // 处理插值中的动态表达式 node.content = processExpression(node.content, context) &#125; else if (node.type === 1 /* ELEMENT */) &#123; // 处理元素指令中的动态表达式 for (let i = 0; i &lt; node.props.length; i++) &#123; const dir = node.props[i] // v-on 和 v-for 不处理，因为它们都有各自的处理逻辑 if (dir.type === 7 /* DIRECTIVE */ &amp;&amp; dir.name !== &#x27;for&#x27;) &#123; const exp = dir.exp const arg = dir.arg if (exp &amp;&amp; exp.type === 4 /* SIMPLE_EXPRESSION */ &amp;&amp; !(dir.name === &#x27;on&#x27; &amp;&amp; arg)) &#123; dir.exp = processExpression(exp, context, dir.name === &#x27;slot&#x27;) &#125; if (arg &amp;&amp; arg.type === 4 /* SIMPLE_EXPRESSION */ &amp;&amp; !arg.isStatic) &#123; dir.arg = processExpression(arg, context) &#125; &#125; &#125; &#125;&#125; 由于表达式本身不会再有子节点，所以它也不需要退出函数，直接在进入函数时做转换处理即可。 需要注意的是，只有在 Node.js 环境下的编译或者是 Web 端的非生产环境下才会执行 transformExpression，原因我稍后会告诉你。 transformExpression 主要做的事情就是转换插值和元素指令中的动态表达式，把简单的表达式对象转换成复合表达式对象，内部主要是通过 processExpression 函数完成。举个例子，比如这个模板：&#123;&#123; msg + test &#125;&#125;，它执行 parse 后生成的表达式节点 node.content 值为一个简单的表达式对象： 123456&#123; &quot;type&quot;: 4, &quot;isStatic&quot;: false, &quot;isConstant&quot;: false, &quot;content&quot;: &quot;msg + test&quot;&#125; 经过 processExpression 处理后，node.content 的值变成了一个复合表达式对象： 12345678910111213141516171819&#123; &quot;type&quot;: 8, &quot;children&quot;: [ &#123; &quot;type&quot;: 4, &quot;isConstant&quot;: false, &quot;content&quot;: &quot;_ctx.msg&quot;, &quot;isStatic&quot;: false &#125;, &quot; + &quot;, &#123; &quot;type&quot;: 4, &quot;isConstant&quot;: false, &quot;content&quot;: &quot;_ctx.test&quot;, &quot;isStatic&quot;: false &#125; ], &quot;identifiers&quot;: []&#125; 这里，我们重点关注对象中的 children 属性，它是一个长度为 3 的数组，其实就是把表达式msg + test拆成了三部分，其中变量 msg 和 test 对应都加上了前缀 _ctx。 那么为什么需要加这个前缀呢？ 我们就要想到模板中引用的的 msg 和 test 对象最终都是在组件实例中访问的，但为了书写模板方便，Vue.js 并没有让我们在模板中手动加组件实例的前缀，例如：&#123;&#123; this.msg + this.test &#125;&#125;，这样写起来就会不够方便，但如果用 JSX 写的话，通常要手动写 this。 你可能会有疑问，为什么 Vue.js 2.x 编译的结果没有 _ctx 前缀呢？这是因为 Vue.js 2.x 的编译结果使用了”黑魔法“ with，比如上述模板，在 Vue.js 2.x 最终编译的结果：with(this)&#123;return _s(msg + test)&#125;。 它利用 with 的特性动态去 this 中查找 msg 和 test 属性，所以不需要手动加前缀。 但是，Vue.js 3.0 在 Node.js 端的编译结果舍弃了 with，它会在 processExpression 过程中对表达式动态分析，给该加前缀的地方加上前缀。 processExpression 的详细实现我们不会分析，但你需要知道，这个过程肯定有一定的成本，因为它内部依赖了 @babel/parser 库去解析表达式生成 AST 节点，并依赖了 estree-walker 库去遍历这个 AST 节点，然后对节点分析去判断是否需要加前缀，接着对 AST 节点修改，最终转换生成新的表达式对象。 @babel&#x2F;parser 这个库通常是在 Node.js 端用的，而且这库本身体积非常大，如果打包进 Vue.js 的话会让包体积膨胀 4 倍，所以我们并不会在生产环境的 Web 端引入这个库，Web 端生产环境下的运行时编译最终仍然会用 with 的方式。 因为用 with 的话就完全不需要对表达式做转换了，这也就回答我前面的问题：只有在 Node.js 环境下的编译或者是 Web 端的非生产环境下才会执行 transformExpression。 这部分内容比较多，所以本课时的内容就先到这。下篇文章，我们接着分析遍历 AST 节点中的 Text 节点的转换函数。 本节课的相关代码在源代码中的位置如下：packages&#x2F;compiler-core&#x2F;src&#x2F;compile.tspackages&#x2F;compiler-core&#x2F;src&#x2F;transform.tspackages&#x2F;compiler-core&#x2F;src&#x2F;ast.tspackages&#x2F;compiler-core&#x2F;src&#x2F;transforms&#x2F;transformElement.tspackages&#x2F;compiler-core&#x2F;src&#x2F;transforms&#x2F;transformExpression.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"AST","slug":"AST","permalink":"https://xiaozhouguo.github.io/tags/AST/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"构造AST的完整流程是怎么样的？ - 上篇","slug":"vue3/ast-one","date":"2022-08-02T06:58:58.000Z","updated":"2022-08-02T08:43:32.890Z","comments":true,"path":"2022/08/02/vue3/ast-one/","link":"","permalink":"https://xiaozhouguo.github.io/2022/08/02/vue3/ast-one/","excerpt":"Vue.js 3.0 的编译场景分服务端 SSR 编译和 web 编译，本文我们只分析 web 的编译。","text":"Vue.js 3.0 的编译场景分服务端 SSR 编译和 web 编译，本文我们只分析 web 的编译。 前言我们先来看 web 编译的入口 compile 函数，分析它的实现原理： 1234567function compile(template, options = &#123;&#125;) &#123; return baseCompile(template, extend(&#123;&#125;, parserOptions, options, &#123; nodeTransforms: [...DOMNodeTransforms, ...(options.nodeTransforms || [])], directiveTransforms: extend(&#123;&#125;, DOMDirectiveTransforms, options.directiveTransforms || &#123;&#125;), transformHoist: null &#125;)) &#125; compile 函数支持两个参数，第一个参数 template 是待编译的模板字符串，第二个参数 options 是编译的一些配置信息。 compile 内部通过执行 baseCompile 方法完成编译工作，可以看到 baseCompile 在参数 options 的基础上又扩展了一些配置。对于这些编译相关的配置，我们后面会在具体的场景具体分析。 接下来，我们来看一下 baseCompile 的实现： 123456789101112131415161718192021function baseCompile(template, options = &#123;&#125;) &#123; const prefixIdentifiers = false // 解析 template 生成 AST const ast = isString(template) ? baseParse(template, options) : template const [nodeTransforms, directiveTransforms] = getBaseTransformPreset() // AST 转换 transform(ast, extend(&#123;&#125;, options, &#123; prefixIdentifiers, nodeTransforms: [ ...nodeTransforms, ...(options.nodeTransforms || []) ], directiveTransforms: extend(&#123;&#125;, directiveTransforms, options.directiveTransforms || &#123;&#125;) &#125;) ) // 生成代码 return generate(ast, extend(&#123;&#125;, options, &#123; prefixIdentifiers &#125;)) &#125; 可以看到，baseCompile 函数主要做三件事情：解析 template 生成 AST，AST 转换和生成代码。 本文的目标就是解析 template 生成 AST 背后的实现原理。 生成 AST 抽象语法树你可以在百度百科中看到 AST 的定义，这里我就不赘述啦，对应到我们的 template，也可以用 AST 去描述它，比如我们有如下 template： 1234567&lt;div class=&quot;app&quot;&gt; &lt;!-- 这是一段注释 --&gt; &lt;hello&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/hello&gt; &lt;p&gt;This is an app&lt;/p&gt; &lt;/div&gt; 经过第一步解析后，生成相应的AST对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221&#123; &quot;type&quot;: 0, &quot;children&quot;: [ &#123; &quot;type&quot;: 1, &quot;ns&quot;: 0, &quot;tag&quot;: &quot;div&quot;, &quot;tagType&quot;: 0, &quot;props&quot;: [ &#123; &quot;type&quot;: 6, &quot;name&quot;: &quot;class&quot;, &quot;value&quot;: &#123; &quot;type&quot;: 2, &quot;content&quot;: &quot;app&quot;, &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 12, &quot;line&quot;: 1, &quot;offset&quot;: 11 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 17, &quot;line&quot;: 1, &quot;offset&quot;: 16 &#125;, &quot;source&quot;: &quot;\\&quot;app\\&quot;&quot; &#125; &#125;, &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 6, &quot;line&quot;: 1, &quot;offset&quot;: 5 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 17, &quot;line&quot;: 1, &quot;offset&quot;: 16 &#125;, &quot;source&quot;: &quot;class=\\&quot;app\\&quot;&quot; &#125; &#125; ], &quot;isSelfClosing&quot;: false, &quot;children&quot;: [ &#123; &quot;type&quot;: 3, &quot;content&quot;: &quot; 这是一段注释 &quot;, &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 3, &quot;line&quot;: 2, &quot;offset&quot;: 20 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 18, &quot;line&quot;: 2, &quot;offset&quot;: 35 &#125;, &quot;source&quot;: &quot;&lt;!-- 这是一段注释 --&gt;&quot; &#125; &#125;, &#123; &quot;type&quot;: 1, &quot;ns&quot;: 0, &quot;tag&quot;: &quot;hello&quot;, &quot;tagType&quot;: 1, &quot;props&quot;: [], &quot;isSelfClosing&quot;: false, &quot;children&quot;: [ &#123; &quot;type&quot;: 1, &quot;ns&quot;: 0, &quot;tag&quot;: &quot;p&quot;, &quot;tagType&quot;: 0, &quot;props&quot;: [], &quot;isSelfClosing&quot;: false, &quot;children&quot;: [ &#123; &quot;type&quot;: 5, &quot;content&quot;: &#123; &quot;type&quot;: 4, &quot;isStatic&quot;: false, &quot;isConstant&quot;: false, &quot;content&quot;: &quot;msg&quot;, &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 11, &quot;line&quot;: 4, &quot;offset&quot;: 56 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 14, &quot;line&quot;: 4, &quot;offset&quot;: 59 &#125;, &quot;source&quot;: &quot;msg&quot; &#125; &#125;, &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 8, &quot;line&quot;: 4, &quot;offset&quot;: 53 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 17, &quot;line&quot;: 4, &quot;offset&quot;: 62 &#125;, &quot;source&quot;: &quot;&#123;&#123; msg &#125;&#125;&quot; &#125; &#125; ], &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 5, &quot;line&quot;: 4, &quot;offset&quot;: 50 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 21, &quot;line&quot;: 4, &quot;offset&quot;: 66 &#125;, &quot;source&quot;: &quot;&lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&quot; &#125; &#125; ], &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 3, &quot;line&quot;: 3, &quot;offset&quot;: 38 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 11, &quot;line&quot;: 5, &quot;offset&quot;: 77 &#125;, &quot;source&quot;: &quot;&lt;hello&gt;\\n &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;\\n &lt;/hello&gt;&quot; &#125; &#125;, &#123; &quot;type&quot;: 1, &quot;ns&quot;: 0, &quot;tag&quot;: &quot;p&quot;, &quot;tagType&quot;: 0, &quot;props&quot;: [], &quot;isSelfClosing&quot;: false, &quot;children&quot;: [ &#123; &quot;type&quot;: 2, &quot;content&quot;: &quot;This is an app&quot;, &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 6, &quot;line&quot;: 6, &quot;offset&quot;: 83 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 20, &quot;line&quot;: 6, &quot;offset&quot;: 97 &#125;, &quot;source&quot;: &quot;This is an app&quot; &#125; &#125; ], &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 3, &quot;line&quot;: 6, &quot;offset&quot;: 80 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 24, &quot;line&quot;: 6, &quot;offset&quot;: 101 &#125;, &quot;source&quot;: &quot;&lt;p&gt;This is an app&lt;/p&gt;&quot; &#125; &#125; ], &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 1, &quot;line&quot;: 1, &quot;offset&quot;: 0 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 7, &quot;line&quot;: 7, &quot;offset&quot;: 108 &#125;, &quot;source&quot;: &quot;&lt;div class=\\&quot;app\\&quot;&gt;\\n &lt;!-- 这是一段注释 --&gt;\\n &lt;hello&gt;\\n &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;\\n &lt;/hello&gt;\\n &lt;p&gt;This is an app&lt;/p&gt;\\n&lt;/div&gt;&quot; &#125; &#125; ], &quot;helpers&quot;: [], &quot;components&quot;: [], &quot;directives&quot;: [], &quot;hoists&quot;: [], &quot;imports&quot;: [], &quot;cached&quot;: 0, &quot;temps&quot;: 0, &quot;loc&quot;: &#123; &quot;start&quot;: &#123; &quot;column&quot;: 1, &quot;line&quot;: 1, &quot;offset&quot;: 0 &#125;, &quot;end&quot;: &#123; &quot;column&quot;: 7, &quot;line&quot;: 7, &quot;offset&quot;: 108 &#125;, &quot;source&quot;: &quot;&lt;div class=\\&quot;app\\&quot;&gt;\\n &lt;!-- 这是一段注释 --&gt;\\n &lt;hello&gt;\\n &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;\\n &lt;/hello&gt;\\n &lt;p&gt;This is an app&lt;/p&gt;\\n&lt;/div&gt;&quot; &#125; &#125; 可以看到，AST 是树状结构，对于树中的每个节点，会有 type 字段描述节点的类型，tag 字段描述节点的标签，props 描述节点的属性，loc 描述节点对应代码相关信息，children 指向它的子节点对象数组。 当然 AST 中的节点还包含其他的一些属性，我在这里就不一一介绍了，你现在要理解的是 AST 中的节点是可以完整地描述它在模板中映射的节点信息。 注意，AST 对象根节点其实是一个虚拟节点，它并不会映射到一个具体节点，另外它还包含了其他的一些属性，这些属性在后续的 AST 转换的过程中会赋值，并在生成代码阶段用到。 那么，为什么要设计一个虚拟节点呢？ 因为 Vue.js 3.0 和 Vue.js 2.x 有一个很大的不同——Vue.js 3.0 支持了 Fragment 的语法，即组件可以有多个根节点，比如： 12&lt;img src=&quot;./logo.jpg&quot;&gt; &lt;hello :msg=&quot;msg&quot;&gt;&lt;/hello&gt; 这种写法在 Vue.js 2.x 中会报错，提示模板只能有一个根节点，而 Vue.js 3.0 允许了这种写法。但是对于一棵树而言，必须有一个根节点，所以虚拟节点在这种场景下就非常有用了，它可以作为 AST 的根节点，然后其 children 包含了 img 和 hello 的节点。 好了，到这里你已经大致了解了 AST，那么接下来我们看一下如何根据模板字符串来构建这个 AST 对象吧。 先来看一下 baseParse 的实现： 12345678910function baseParse(content, options = &#123;&#125;) &#123; // 创建解析上下文 const context = createParserContext(content, options) const start = getCursor(context) // 解析子节点，并创建 AST return createRoot( parseChildren(context, 0 /* DATA */, []), getSelection(context, start) ) &#125; baseParse 主要就做三件事情：创建解析上下文，解析子节点，创建 AST 根节点。 创建解析上下文首先，我们来分析创建解析上下文的过程，先来看 createParserContext 的实现： 1234567891011121314151617181920212223// 默认解析配置 const defaultParserOptions = &#123; delimiters: [`&#123;&#123;`, `&#125;&#125;`], getNamespace: () =&gt; 0 /* HTML */, getTextMode: () =&gt; 0 /* DATA */, isVoidTag: NO, isPreTag: NO, isCustomElement: NO, decodeEntities: (rawText) =&gt; rawText.replace(decodeRE, (_, p1) =&gt; decodeMap[p1]), onError: defaultOnError &#125; function createParserContext(content, options) &#123; return &#123; options: extend(&#123;&#125;, defaultParserOptions, options), column: 1, line: 1, offset: 0, originalSource: content, source: content, inPre: false, inVPre: false &#125; &#125; 解析上下文实际上就是一个 JavaScript 对象，它维护着解析过程中的上下文，其中 options 表示解析相关配置 ，column 表示当前代码的列号，line 表示当前代码的行号，originalSource 表示最初的原始代码，source 表示当前代码，offset 表示当前代码相对于原始代码的偏移量，inPre 表示当前代码是否在 pre 标签内，inVPre 表示当前代码是否在 v-pre 指令的环境下。 在后续解析的过程中，会始终维护和更新这个解析上下文，它能够表示当前解析的状态。 创建完解析上下文，接下来就开始解析子节点了。 解析子节点我们先来看一下 parseChildren 函数的实现： 123456789function parseChildren(context, mode, ancestors) &#123; const parent = last(ancestors) const ns = parent ? parent.ns : 0 /* HTML */ const nodes = [] // 自顶向下分析代码，生成 nodes let removedWhitespace = false // 空白字符管理 return removedWhitespace ? nodes.filter(Boolean) : nodes&#125; parseChildren 的目的就是解析并创建 AST 节点数组。它有两个主要流程，第一个是自顶向下分析代码，生成 AST 节点数组 nodes；第二个是空白字符管理，用于提高编译的效率。 首先，我们来看生成 AST 节点数组的流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697function parseChildren(context, mode, ancestors) &#123; // 父节点 const parent = last(ancestors) const ns = parent ? parent.ns : 0 /* HTML */ const nodes = [] // 判断是否遍历结束 while (!isEnd(context, mode, ancestors)) &#123; const s = context.source let node = undefined if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) &#123; if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) &#123; // 处理 &#123;&#123; 插值代码 node = parseInterpolation(context, mode) &#125; else if (mode === 0 /* DATA */ &amp;&amp; s[0] === &#x27;&lt;&#x27;) &#123; // 处理 &lt; 开头的代码 if (s.length === 1) &#123; // s 长度为 1，说明代码结尾是 &lt;，报错 emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1) &#125; else if (s[1] === &#x27;!&#x27;) &#123; // 处理 &lt;! 开头的代码 if (startsWith(s, &#x27;&lt;!--&#x27;)) &#123; // 处理注释节点 node = parseComment(context) &#125; else if (startsWith(s, &#x27;&lt;!DOCTYPE&#x27;)) &#123; // 处理 &lt;!DOCTYPE 节点 node = parseBogusComment(context) &#125; else if (startsWith(s, &#x27;&lt;![CDATA[&#x27;)) &#123; // 处理 &lt;![CDATA[ 节点 if (ns !== 0 /* HTML */) &#123; node = parseCDATA(context, ancestors) &#125; else &#123; emitError(context, 1 /* CDATA_IN_HTML_CONTENT */) node = parseBogusComment(context) &#125; &#125; else &#123; emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */) node = parseBogusComment(context) &#125; &#125; else if (s[1] === &#x27;/&#x27;) &#123; // 处理 &lt;/ 结束标签 if (s.length === 2) &#123; // s 长度为 2，说明代码结尾是 &lt;/，报错 emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2) &#125; else if (s[2] === &#x27;&gt;&#x27;) &#123; // &lt;/&gt; 缺少结束标签，报错 emitError(context, 14 /* MISSING_END_TAG_NAME */, 2) advanceBy(context, 3) continue &#125; else if (/[a-z]/i.test(s[2])) &#123; // 多余的结束标签 emitError(context, 23 /* X_INVALID_END_TAG */) parseTag(context, 1 /* End */, parent) continue &#125; else &#123; emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2) node = parseBogusComment(context) &#125; &#125; else if (/[a-z]/i.test(s[1])) &#123; // 解析标签元素节点 node = parseElement(context, ancestors) &#125; else if (s[1] === &#x27;?&#x27;) &#123; emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1) node = parseBogusComment(context) &#125; else &#123; emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1) &#125; &#125; &#125; if (!node) &#123; // 解析普通文本节点 node = parseText(context, mode) &#125; if (isArray(node)) &#123; // 如果 node 是数组，则遍历添加 for (let i = 0; i &lt; node.length; i++) &#123; pushNode(nodes, node[i]) &#125; &#125; else &#123; // 添加单个 node pushNode(nodes, node) &#125; &#125; &#125; 这些代码看起来很复杂，但它的思路就是自顶向下地去遍历代码，然后根据不同的情况尝试去解析代码，然后把生成的 node 添加到 AST nodes 数组中。在解析的过程中，解析上下文 context 的状态也是在不断发生变化的，我们可以通过 context.source 拿到当前解析剩余的代码 s，然后根据 s 不同的情况走不同的分支处理逻辑。在解析的过程中，可能会遇到各种错误，都会通过 emitError 方法报错。 我们没有必要去了解所有代码的分支细节，只需要知道大致的解析思路即可，因此我们这里只分析四种情况：注释节点的解析、插值的解析、普通文本的解析，以及元素节点的解析。 注释节点的解析 首先，我们来看注释节点的解析过程，它会解析模板中的注释节点，比如 &lt;!-- 这是一段注释 --&gt;， 即当前代码 s 是以 &lt;!-- 开头的字符串，则走到注释节点的解析处理逻辑。 我们来看 parseComment 的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142function parseComment(context) &#123; const start = getCursor(context) let content // 常规注释的结束符 const match = /--(\\!)?&gt;/.exec(context.source) if (!match) &#123; // 没有匹配的注释结束符 content = context.source.slice(4) advanceBy(context, context.source.length) emitError(context, 7 /* EOF_IN_COMMENT */) &#125; else &#123; if (match.index &lt;= 3) &#123; // 非法的注释符号 emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */) &#125; if (match[1]) &#123; // 注释结束符不正确 emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */) &#125; // 获取注释的内容 content = context.source.slice(4, match.index) // 截取到注释结尾之间的代码，用于后续判断嵌套注释 const s = context.source.slice(0, match.index) let prevIndex = 1, nestedIndex = 0 // 判断嵌套注释符的情况，存在即报错 while ((nestedIndex = s.indexOf(&#x27;&lt;!--&#x27;, prevIndex)) !== -1) &#123; advanceBy(context, nestedIndex - prevIndex + 1) if (nestedIndex + 4 &lt; s.length) &#123; emitError(context, 16 /* NESTED_COMMENT */) &#125; prevIndex = nestedIndex + 1 &#125; // 前进代码到注释结束符后 advanceBy(context, match.index + match[0].length - prevIndex + 1) &#125; return &#123; type: 3 /* COMMENT */, content, loc: getSelection(context, start) &#125; &#125; 其实，parseComment 的实现很简单，首先它会利用注释结束符的正则表达式去匹配代码，找出注释结束符。如果没有匹配到或者注释结束符不合法，都会报错。如果找到合法的注释结束符，则获取它中间的注释内容 content，然后截取注释开头到结尾之间的代码，并判断是否有嵌套注释，如果有嵌套注释也会报错。 接着就是通过调用 advanceBy 前进代码到注释结束符后，这个函数在整个模板解析过程中经常被调用，它的目的是用来前进代码，更新 context 解析上下文，我们来看一下它的实现： 123456789101112131415161718192021222324function advanceBy(context, numberOfCharacters) &#123; const &#123; source &#125; = context // 更新 context 的 offset、line、column advancePositionWithMutation(context, source, numberOfCharacters) // 更新 context 的 source context.source = source.slice(numberOfCharacters) &#125; function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) &#123; let linesCount = 0 let lastNewLinePos = -1 for (let i = 0; i &lt; numberOfCharacters; i++) &#123; if (source.charCodeAt(i) === 10 /* newline char code */) &#123; linesCount++ lastNewLinePos = i &#125; &#125; pos.offset += numberOfCharacters pos.line += linesCount pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos return pos &#125; advanceBy 的实现很简单，主要就是更新解析上下文 context 中的 source 来前进代码，同时更新 offset、line、column 等和代码位置相关的属性。 为了更直观地说明 advanceBy 的作用，前面的示例可以通过下图表示： 经过 advanceBy 前进代码到注释结束符后，表示注释部分代码处理完毕，可以继续解析后续代码了。 parseComment 最终返回的值就是一个描述注释节点的对象，其中 type 表示它是一个注释节点，content 表示注释的内容，loc 表示注释的代码开头和结束的位置信息。 插值的解析 接下来，我们来看插值的解析过程，它会解析模板中的插值，比如 &#123;&#123; msg &#125;&#125; ，即当前代码 s 是以 { { 开头的字符串，且不在 v-pre 指令的环境下（v-pre 会跳过插值的解析），则会走到插值的解析处理逻辑 parseInterpolation 函数，我们来看它的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function parseInterpolation(context, mode) &#123; // 从配置中获取插值开始和结束分隔符，默认是 &#123;&#123; 和 &#125;&#125; const [open, close] = context.options.delimiters const closeIndex = context.source.indexOf(close, open.length) if (closeIndex === -1) &#123; emitError(context, 25 /* X_MISSING_INTERPOLATION_END */) return undefined &#125; const start = getCursor(context) // 代码前进到插值开始分隔符后 advanceBy(context, open.length) // 内部插值开始位置 const innerStart = getCursor(context) // 内部插值结束位置 const innerEnd = getCursor(context) // 插值原始内容的长度 const rawContentLength = closeIndex - open.length // 插值原始内容 const rawContent = context.source.slice(0, rawContentLength) // 获取插值的内容，并前进代码到插值的内容后 const preTrimContent = parseTextData(context, rawContentLength, mode) const content = preTrimContent.trim() // 内容相对于插值开始分隔符的头偏移 const startOffset = preTrimContent.indexOf(content) if (startOffset &gt; 0) &#123; // 更新内部插值开始位置 advancePositionWithMutation(innerStart, rawContent, startOffset) &#125; // 内容相对于插值结束分隔符的尾偏移 const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset) // 更新内部插值结束位置 advancePositionWithMutation(innerEnd, rawContent, endOffset); // 前进代码到插值结束分隔符后 advanceBy(context, close.length) return &#123; type: 5 /* INTERPOLATION */, content: &#123; type: 4 /* SIMPLE_EXPRESSION */, isStatic: false, isConstant: false, content, loc: getSelection(context, innerStart, innerEnd) &#125;, loc: getSelection(context, start) &#125; &#125; parseInterpolation 的实现也很简单，首先它会尝试找插值的结束分隔符，如果找不到则报错。 如果找到，先前进代码到插值开始分隔符后，然后通过 parseTextData 获取插值中间的内容并前进代码到插值内容后，除了普通字符串，parseTextData 内部会处理一些 HTML 实体符号比如 &amp;nbsp 。由于插值的内容可能是前后有空白字符的，所以最终返回的 content 需要执行一下 trim 函数。 为了准确地反馈插值内容的代码位置信息，我们使用了 innerStart 和 innerEnd 去记录插值内容（不包含空白字符）的代码开头和结束位置。 接着就是前进代码到插值结束分隔符后，表示插值部分代码处理完毕，可以继续解析后续代码了。 parseInterpolation 最终返回的值就是一个描述插值节点的对象，其中 type 表示它是一个插值节点，loc 表示插值的代码开头和结束的位置信息，而 content 又是一个描述表达式节点的对象，其中 type 表示它是一个表达式节点，loc 表示内容的代码开头和结束的位置信息，content 表示插值的内容。 普通文本的解析 接下来，我们来看普通文本的解析过程，它会解析模板中的普通文本，比如 This is an app ，即当前代码 s 既不是以 { { 插值分隔符开头的字符串，也不是以 &lt; 开头的字符串，则走到普通文本的解析处理逻辑，我们来看 parseText 的实现： 123456789101112131415161718192021222324function parseText(context, mode) &#123; // 文本结束符 const endTokens = [&#x27;&lt;&#x27;, context.options.delimiters[0]] if (mode === 3 /* CDATA */) &#123; // CDATA 标记 XML 中的纯文本 endTokens.push(&#x27;]]&gt;&#x27;) &#125; let endIndex = context.source.length // 遍历文本结束符，匹配找到结束的位置 for (let i = 0; i &lt; endTokens.length; i++) &#123; const index = context.source.indexOf(endTokens[i], 1) if (index !== -1 &amp;&amp; endIndex &gt; index) &#123; endIndex = index &#125; &#125; const start = getCursor(context) // 获取文本的内容，并前进代码到文本的内容后 const content = parseTextData(context, endIndex, mode) return &#123; type: 2 /* TEXT */, content, loc: getSelection(context, start) &#125; &#125; 同样，parseText 的实现很简单。对于一段文本来说，都是在遇到 &lt; 或者插值分隔符 { { 结束，所以会遍历这些结束符，匹配并找到文本结束的位置，然后执行 parseTextData 获取文本的内容，并前进代码到文本的内容后。 parseText 最终返回的值就是一个描述文本节点的对象，其中 type 表示它是一个文本节点，content 表示文本的内容，loc 表示文本的代码开头和结束的位置信息。 这部分内容比较多，所以本课时的内容就先到这。下节课中，我们接着分析元素节点，继续解析 template 生成 AST 的背后实现原理。 本节课的相关代码在源代码中的位置如下：packages&#x2F;compiler-core&#x2F;src&#x2F;compile.tspackages&#x2F;compiler-core&#x2F;src&#x2F;parse.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"AST","slug":"AST","permalink":"https://xiaozhouguo.github.io/tags/AST/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"侦听器的实现原理和使用场景 - 下篇","slug":"vue3/watcher-two","date":"2022-08-01T08:55:54.000Z","updated":"2022-08-01T09:35:21.890Z","comments":true,"path":"2022/08/01/vue3/watcher-two/","link":"","permalink":"https://xiaozhouguo.github.io/2022/08/01/vue3/watcher-two/","excerpt":"在前面中，我们多次提到回调函数是以一种调度的方式执行的，特别是当 flush 不是 sync 时，它会把回调函数执行的任务推到一个异步队列中执行。接下来，我们就来分析异步执行队列的设计。分析之前，我们先来思考一下，为什么会需要异步队列？","text":"在前面中，我们多次提到回调函数是以一种调度的方式执行的，特别是当 flush 不是 sync 时，它会把回调函数执行的任务推到一个异步队列中执行。接下来，我们就来分析异步执行队列的设计。分析之前，我们先来思考一下，为什么会需要异步队列？ 异步任务队列的设计我们把之前的例子简单修改一下： 12345678import &#123; reactive, watch &#125; from &#x27;vue&#x27; const state = reactive(&#123; count: 0 &#125;) watch(() =&gt; state.count, (count, prevCount) =&gt; &#123; console.log(count) &#125;) state.count++ state.count++ state.count++ 这里，我们修改了三次 state.count，那么 watcher 的回调函数会执行三次吗？ 答案是不会，实际上只输出了一次 count 的值，也就是最终计算的值 3。这在大多数场景下都是符合预期的，因为在一个 Tick（宏任务执行的生命周期）内，即使多次修改侦听的值，它的回调函数也只执行一次。 知识延伸组件的更新过程是异步的，我们知道修改模板中引用的响应式对象的值时，会触发组件的重新渲染，但是在一个 Tick 内，即使你多次修改多个响应式对象的值，组件的重新渲染也只执行一次。这是因为如果每次更新数据都触发组件重新渲染，那么重新渲染的次数和代价都太高了。 那么，这是怎么做到的呢？我们先从异步任务队列的创建说起。 异步任务队列的创建通过前面的分析我们知道，在创建一个 watcher 时，如果配置 flush 为 pre 或不配置 flush ，那么 watcher 的回调函数就会异步执行。此时分别是通过 queueJob 和 queuePostRenderEffect 把回调函数推入异步队列中的。 在不涉及 suspense 的情况下，queuePostRenderEffect 相当于 queuePostFlushCb，我们来看它们的实现： 1234567891011121314151617181920// 异步任务队列 const queue = [] // 队列任务执行完后执行的回调函数队列 const postFlushCbs = [] function queueJob(job) &#123; if (!queue.includes(job)) &#123; queue.push(job) queueFlush() &#125; &#125; function queuePostFlushCb(cb) &#123; if (!isArray(cb)) &#123; postFlushCbs.push(cb) &#125; else &#123; // 如果是数组，把它拍平成一维 postFlushCbs.push(...cb) &#125; queueFlush() &#125; Vue.js 内部维护了一个 queue 数组和一个 postFlushCbs 数组，其中 queue 数组用作异步任务队列， postFlushCbs 数组用作异步任务队列执行完毕后的回调函数队列。 执行 queueJob 时会把这个任务 job 添加到 queue 的队尾，而执行 queuePostFlushCb 时，会把这个 cb 回调函数添加到 postFlushCbs 的队尾。它们在添加完毕后都执行了 queueFlush 函数，我们接着看它的实现： 1234567891011121314const p = Promise.resolve() // 异步任务队列是否正在执行 let isFlushing = false // 异步任务队列是否等待执行 let isFlushPending = false function nextTick(fn) &#123; return fn ? p.then(fn) : p &#125; function queueFlush() &#123; if (!isFlushing &amp;&amp; !isFlushPending) &#123; isFlushPending = true nextTick(flushJobs) &#125; &#125; 可以看到，Vue.js 内部还维护了 isFlushing 和 isFlushPending 变量，用来控制异步任务的刷新逻辑。 在 queueFlush 首次执行时，isFlushing 和 isFlushPending 都是 false，此时会把 isFlushPending 设置为 true，并且调用 nextTick(flushJobs) 去执行队列里的任务。 因为 isFlushPending 的控制，这使得即使多次执行 queueFlush，也不会多次去执行 flushJobs。另外 nextTick 在 Vue.js 3.0 中的实现也是非常简单，通过 Promise.resolve().then 去异步执行 flushJobs。 因为 JavaScript 是单线程执行的，这样的异步设计使你在一个 Tick 内，可以多次执行 queueJob 或者 queuePostFlushCb 去添加任务，也可以保证在宏任务执行完毕后的微任务阶段执行一次 flushJobs。 异步任务队列的执行创建完任务队列后，接下来要异步执行这个队列，我们来看一下 flushJobs 的实现： 123456789101112131415161718192021222324252627const getId = (job) =&gt; (job.id == null ? Infinity : job.id) function flushJobs(seen) &#123; isFlushPending = false isFlushing = true let job if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; seen = seen || new Map() &#125; // 组件的更新是先父后子 // 如果一个组件在父组件更新过程中卸载，它自身的更新应该被跳过 queue.sort((a, b) =&gt; getId(a) - getId(b)) while ((job = queue.shift()) !== undefined) &#123; if (job === null) &#123; continue &#125; if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; checkRecursiveUpdates(seen, job) &#125; callWithErrorHandling(job, null, 14 /* SCHEDULER */) &#125; flushPostFlushCbs(seen) isFlushing = false // 一些 postFlushCb 执行过程中会再次添加异步任务，递归 flushJobs 会把它们都执行完毕 if (queue.length || postFlushCbs.length) &#123; flushJobs(seen) &#125; &#125; 可以看到，flushJobs 函数开始执行的时候，会把 isFlushPending 重置为 false，把 isFlushing 设置为 true 来表示正在执行异步任务队列。 对于异步任务队列 queue，在遍历执行它们前会先对它们做一次从小到大的排序，这是因为两个主要原因： 我们创建组件的过程是由父到子，所以创建组件副作用渲染函数也是先父后子，父组件的副作用渲染函数的 effect id 是小于子组件的，每次更新组件也是通过 queueJob 把 effect 推入异步任务队列 queue 中的。所以为了保证先更新父组再更新子组件，要对 queue 做从小到大的排序。 如果一个组件在父组件更新过程中被卸载，它自身的更新应该被跳过。所以也应该要保证先更新父组件再更新子组件，要对 queue 做从小到大的排序。 接下来，就是遍历这个 queue，依次执行队列中的任务了，在遍历过程中，注意有一个 checkRecursiveUpdates 的逻辑，它是用来在非生产环境下检测是否有循环更新的，它的作用我们稍后会提。 遍历完 queue 后，又会进一步执行 flushPostFlushCbs 方法去遍历执行所有推入到 postFlushCbs 的回调函数： 12345678910111213141516 function flushPostFlushCbs(seen) &#123; if (postFlushCbs.length) &#123; // 拷贝副本 const cbs = [...new Set(postFlushCbs)] postFlushCbs.length = 0 if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; seen = seen || new Map() &#125; for (let i = 0; i &lt; cbs.length; i++) &#123; if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; checkRecursiveUpdates(seen, cbs[i]) &#125; cbs[i]() &#125; &#125; &#125; 注意这里遍历前会通过 const cbs = [...new Set(postFlushCbs)] 拷贝一个 postFlushCbs 的副本，这是因为在遍历的过程中，可能某些回调函数的执行会再次修改 postFlushCbs，所以拷贝一个副本循环遍历则不会受到 postFlushCbs 修改的影响。 遍历完 postFlushCbs 后，会重置 isFlushing 为 false，因为一些 postFlushCb 执行过程中可能会再次添加异步任务，所以需要继续判断如果 queue 或者 postFlushCbs 队列中还存在任务，则递归执行 flushJobs 把它们都执行完毕。 检测循环更新前面我们提到了，在遍历执行异步任务和回调函数的过程中，都会在非生产环境下执行 checkRecursiveUpdates 检测是否有循环更新，它是用来解决什么问题的呢？ 我们把之前的例子改写一下： 1234567import &#123; reactive, watch &#125; from &#x27;vue&#x27; const state = reactive(&#123; count: 0 &#125;) watch(() =&gt; state.count, (count, prevCount) =&gt; &#123; state.count++ console.log(count) &#125;) state.count++ 如果你去跑这个示例，你会在控制台看到输出了 101 次值，然后报了错误： Maximum recursive updates exceeded 。这是因为我们在 watcher 的回调函数里更新了数据，这样会再一次进入回调函数，如果我们不加任何控制，那么回调函数会一直执行，直到把内存耗尽造成浏览器假死。为了避免这种情况，Vue.js 实现了 checkRecursiveUpdates 方法： 1234567891011121314151617const RECURSION_LIMIT = 100 function checkRecursiveUpdates(seen, fn) &#123; if (!seen.has(fn)) &#123; seen.set(fn, 1) &#125; else &#123; const count = seen.get(fn) if (count &gt; RECURSION_LIMIT) &#123; throw new Error(&#x27;Maximum recursive updates exceeded. &#x27; + &quot;You may have code that is mutating state in your component&#x27;s &quot; + &#x27;render function or updated hook or watcher source function.&#x27;) &#125; else &#123; seen.set(fn, count + 1) &#125; &#125; &#125; 通过前面的代码，我们知道 flushJobs 一开始便创建了 seen，它是一个 Map 对象，然后在 checkRecursiveUpdates 的时候会把任务添加到 seen 中，记录引用计数 count，初始值为 1，如果 postFlushCbs 再次添加了相同的任务，则引用计数 count 加 1，如果 count 大于我们定义的限制 100 ，则说明一直在添加这个相同的任务并超过了 100 次。那么，Vue.js 会抛出这个错误，因为在正常的使用中，不应该出现这种情况，而我们上述的错误示例就会触发这种报错逻辑。 优化：只用一个变量到这里，异步队列的设计就介绍完毕了，你可能会对 isFlushPending 和 isFlushing 有些疑问，为什么需要两个变量来控制呢？ 从语义上来看，isFlushPending 用于判断是否在等待 nextTick 执行 flushJobs，而 isFlushing 是判断是否正在执行任务队列。 从功能上来看，它们的作用是为了确保以下两点： 在一个 Tick 内可以多次添加任务到队列中，但是任务队列会在 nextTick 后执行； 在执行任务队列的过程中，也可以添加新的任务到队列中，并且在当前 Tick 去执行剩余的任务队列。 但实际上，这里我们可以进行优化。在我看来，这里用一个变量就足够了，我们来稍微修改一下源码： 123456789101112131415161718192021222324252627function queueFlush() &#123; if (!isFlushing) &#123; isFlushing = true nextTick(flushJobs) &#125; &#125; function flushJobs(seen) &#123; let job if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; seen = seen || new Map() &#125; queue.sort((a, b) =&gt; getId(a) - getId(b)) while ((job = queue.shift()) !== undefined) &#123; if (job === null) &#123; continue &#125; if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; checkRecursiveUpdates(seen, job) &#125; callWithErrorHandling(job, null, 14 /* SCHEDULER */) &#125; flushPostFlushCbs(seen) if (queue.length || postFlushCbs.length) &#123; flushJobs(seen) &#125; isFlushing = false &#125; 可以看到，我们只需要一个 isFlushing 来控制就可以实现相同的功能了。在执行 queueFlush 的时候，判断 isFlushing 为 false，则把它设置为 true，然后 nextTick 会执行 flushJobs。在 flushJobs 函数执行完成的最后，也就是所有的任务（包括后添加的）都执行完毕，再设置 isFlushing 为 false。 我这么修改源码后也跑通了 Vue.js 3.0 的单元测试，如果你觉得这么实现有问题的话，欢迎在留言区评论与我讨论。 了解完 watch API 和异步任务队列的设计后，我们再来学习侦听器提供的另一个 API—— watchEffect API。 watchEffect APIwatchEffect API 的作用是注册一个副作用函数，副作用函数内部可以访问到响应式对象，当内部响应式对象变化后再立即执行这个函数。 可以先来看一个示例： 1234import &#123; ref, watchEffect &#125; from &#x27;vue&#x27; const count = ref(0) watchEffect(() =&gt; console.log(count.value)) count.value++ 它的结果是依次输出 0 和 1。watchEffect 和前面的 watch API 有哪些不同呢？主要有三点： 侦听的源不同 。watch API 可以侦听一个或多个响应式对象，也可以侦听一个 getter 函数，而 watchEffect API 侦听的是一个普通函数，只要内部访问了响应式对象即可，这个函数并不需要返回响应式对象。 没有回调函数 。watchEffect API 没有回调函数，副作用函数的内部响应式对象发生变化后，会再次执行这个副作用函数。 立即执行 。watchEffect API 在创建好 watcher 后，会立刻执行它的副作用函数，而 watch API 需要配置 immediate 为 true，才会立即执行回调函数。 对 watchEffect API 有大体了解后，我们来看一下在我整理的 watchEffect 场景下， doWatch 函数的简化版实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function watchEffect(effect, options) &#123; return doWatch(effect, null, options); &#125; function doWatch(source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; instance = currentInstance; let getter; if (isFunction(source)) &#123; getter = () =&gt; &#123; if (instance &amp;&amp; instance.isUnmounted) &#123; return; &#125; // 执行清理函数 if (cleanup) &#123; cleanup(); &#125; // 执行 source 函数，传入 onInvalidate 作为参数 return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]); &#125;; &#125; let cleanup; const onInvalidate = (fn) =&gt; &#123; cleanup = runner.options.onStop = () =&gt; &#123; callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */); &#125;; &#125;; let scheduler; // 创建 scheduler if (flush === &#x27;sync&#x27;) &#123; scheduler = invoke; &#125; else if (flush === &#x27;pre&#x27;) &#123; scheduler = job =&gt; &#123; if (!instance || instance.isMounted) &#123; queueJob(job); &#125; else &#123; job(); &#125; &#125;; &#125; else &#123; scheduler = job =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense); &#125; // 创建 runner const runner = effect(getter, &#123; lazy: true, computed: true, onTrack, onTrigger, scheduler &#125;); recordInstanceBoundEffect(runner); // 立即执行 runner runner(); // 返回销毁函数 return () =&gt; &#123; stop(runner); if (instance) &#123; remove(instance.effects, runner); &#125; &#125;;&#125; 可以看到，getter 函数就是对 source 函数的简单封装，它会先判断组件实例是否已经销毁，然后每次执行 source 函数前执行 cleanup 清理函数。 watchEffect 内部创建的 runner 对应的 scheduler 对象就是 scheduler 函数本身，这样它再次执行时，就会执行这个 scheduler 函数，并且传入 runner 函数作为参数，其实就是按照一定的调度方式去执行基于 source 封装的 getter 函数。 创建完 runner 后就立刻执行了 runner，其实就是内部同步执行了基于 source 封装的 getter 函数。 在执行 source 函数的时候，会传入一个 onInvalidate 函数作为参数，接下来我们就来分析它的作用。 注册无效回调函数有些时候，watchEffect 会注册一个副作用函数，在函数内部可以做一些异步操作，但是当这个 watcher 停止后，如果我们想去对这个异步操作做一些额外事情（比如取消这个异步操作），我们可以通过 onInvalidate 参数注册一个无效函数。 12345678910import &#123;ref, watchEffect &#125; from &#x27;vue&#x27; const id = ref(0) watchEffect(onInvalidate =&gt; &#123; // 执行异步操作 const token = performAsyncOperation(id.value) onInvalidate(() =&gt; &#123; // 如果 id 发生变化或者 watcher 停止了，则执行逻辑取消前面的异步操作 token.cancel() &#125;) &#125;) 我们利用 watchEffect 注册了一个副作用函数，它有一个 onInvalidate 参数。在这个函数内部通过 performAsyncOperation 执行某些异步操作，并且访问了 id 这个响应式对象，然后通过 onInvalidate 注册了一个回调函数。 如果 id 发生变化或者 watcher 停止了，这个回调函数将会执行，然后执行 token.cancel 取消之前的异步操作。 我们来回顾 onInvalidate 在 doWatch 中的实现： 12345const onInvalidate = (fn) =&gt; &#123; cleanup = runner.options.onStop = () =&gt; &#123; callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */); &#125;; &#125;; 实际上，当你执行 onInvalidate 的时候，就是注册了一个 cleanup 和 runner 的 onStop 方法，这个方法内部会执行 fn，也就是你注册的无效回调函数。 也就是说当响应式数据发生变化，会执行 cleanup 方法，当 watcher 被停止，会执行 onStop 方法，这两者都会执行注册的无效回调函数 fn。 通过这种方式，Vue.js 就很好地实现了 watcher 注册无效回调函数的需求。 总结好的，到这里我们这一节的学习也要结束啦，通过这节课的学习，你应该掌握了侦听器内部实现原理，了解侦听器支持的几种配置参数的作用，以及异步任务队列的设计原理。 你也应该掌握侦听器的常见应用场景：如何用 watch API 观测数据的变化去执行一些逻辑，如何利用 watchEffect API 去注册一些副作用函数，如何去注册无效回调函数，以及如何停止一个正在运行的 watcher。 相比于计算属性，侦听器更适合用于在数据变化后执行某段逻辑的场景，而计算属性则用于一个数据依赖另外一些数据计算而来的场景。 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-core&#x2F;src&#x2F;apiWatch.tspackages&#x2F;runtime-core&#x2F;src&#x2F;scheduler.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://xiaozhouguo.github.io/tags/watch/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"响应式内部的实现原理是怎么样的？- 下篇","slug":"vue3/reactive-inner-two","date":"2022-08-01T01:42:31.000Z","updated":"2022-08-01T03:13:14.051Z","comments":true,"path":"2022/08/01/vue3/reactive-inner-two/","link":"","permalink":"https://xiaozhouguo.github.io/2022/08/01/vue3/reactive-inner-two/","excerpt":"我们之前了解在 Vue.js 3.0 中引入 reactive API，它可以把对象数据变成响应式，所以我们着重分析 reactive API 的实现原理，并学习了收集依赖的 get 函数， 这节课我们继续来分析 reactive API 中需要关注的另一个内容——派发通知的过程。","text":"我们之前了解在 Vue.js 3.0 中引入 reactive API，它可以把对象数据变成响应式，所以我们着重分析 reactive API 的实现原理，并学习了收集依赖的 get 函数， 这节课我们继续来分析 reactive API 中需要关注的另一个内容——派发通知的过程。 reactive API派发通知 set 函数派发通知发生在数据更新的阶段 ，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性更新的时候就会执行 set 函数。我们来看一下 set 函数的实现，它是执行 createSetter 函数的返回值： 123456789101112131415161718function createSetter() &#123; return function set(target, key, value, receiver) &#123; const oldValue = target[key] value = toRaw(value) const hadKey = hasOwn(target, key) const result = Reflect.set(target, key, value, receiver) // 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了 if (target === toRaw(receiver)) &#123; if (!hadKey) &#123; trigger(target, &quot;add&quot; /* ADD */, key, value) &#125; else if (hasChanged(value, oldValue)) &#123; trigger(target, &quot;set&quot; /* SET */, key, value, oldValue) &#125; &#125; return result &#125;&#125; 结合上述代码来看，set 函数的实现逻辑很简单，主要就做两件事情， 首先通过 Reflect.set 求值 ， 然后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型，即新增还是修改。 整个 set 函数最核心的部分就是 执行 trigger 函数派发通知 ，下面我们将重点分析这个过程。 我们先来看一下 trigger 函数的实现，为了分析主要流程，这里省略了 trigger 函数中的一些分支逻辑： 123456789101112131415161718192021222324252627282930313233343536// 原始数据对象 mapconst targetMap = new WeakMap()function trigger(target, type, key, newValue) &#123; // 通过 targetMap 拿到 target 对应的依赖集合 const depsMap = targetMap.get(target) if (!depsMap) &#123; // 没有依赖，直接返回 return &#125; // 创建运行的 effects 集合 const effects = new Set() // 添加 effects 的函数 const add = (effectsToAdd) =&gt; &#123; if (effectsToAdd) &#123; effectsToAdd.forEach(effect =&gt; &#123; effects.add(effect) &#125;) &#125; &#125; // SET | ADD | DELETE 操作之一，添加对应的 effects if (key !== void 0) &#123; add(depsMap.get(key)) &#125; const run = (effect) =&gt; &#123; // 调度执行 if (effect.options.scheduler) &#123; effect.options.scheduler(effect) &#125; else &#123; // 直接运行 effect() &#125; &#125; // 遍历执行 effects effects.forEach(run)&#125; trigger 函数的实现也很简单，主要做了四件事情： 通过 targetMap 拿到 target 对应的依赖集合 depsMap； 创建运行的 effects 集合； 根据 key 从 depsMap 中找到对应的 effects 添加到 effects 集合； 遍历 effects 执行相关的副作用函数。 所以每次 trigger 函数就是根据 target 和 key ，从 targetMap 中找到相关的所有副作用函数遍历执行一遍。 在描述依赖收集和派发通知的过程中，我们都提到了一个词：副作用函数，依赖收集过程中我们把 activeEffect（当前激活副作用函数）作为依赖收集，它又是什么？接下来我们来看一下副作用函数的庐山真面目。 副作用函数介绍副作用函数前，我们先回顾一下响应式的原始需求，即我们修改了数据就能自动执行某个函数，举个简单的例子： 123456789101112import &#123; reactive &#125; from &#x27;vue&#x27;const counter = reactive(&#123; num: 0&#125;)function logCount() &#123; console.log(counter.num)&#125;function count() &#123; counter.num++&#125;logCount()count() 可以看到，这里我们定义了响应式对象 counter，然后我们在 logCount 中访问了 counter.num，我们希望通过执行 count 函数修改 counter.num 值的时候，能自动执行 logCount 函数。 按我们之前对依赖收集过程的分析，如果这个 logCount 就是 activeEffect 的话，那么就可以实现需求，但显然是做不到的，因为代码在执行到 console.log(counter.num)这一行 的时候，它对自己在 logCount 函数中的运行是一无所知的。 那么该怎么办呢？其实只要我们运行 logCount 函数前，把 logCount 赋值给 activeEffect 就好了，如下： 12activeEffect = logCount logCount() 顺着这个思路，我们可以利用高阶函数的思想，对 logCount 做一层封装，如下： 123456789function wrapper(fn) &#123; const wrapped = function(...args) &#123; activeEffect = fn fn(...args) &#125; return wrapped&#125;const wrappedLog = wrapper(logCount)wrappedLog() 这里，wrapper 本身也是一个函数，它接受 fn 作为参数，返回一个新的函数 wrapped，然后维护一个全局的 activeEffect，当 wrapped 执行的时候，把 activeEffect 设置为 fn，然后执行 fn 即可。 这样当我们执行 wrappedLog 后，再去修改 counter.num，就会自动执行 logCount 函数了。 实际上 Vue.js 3.0 就是采用类似的做法，在它内部就有一个 effect 副作用函数，我们来看一下它的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 全局 effect 栈const effectStack = []// 当前激活的 effectlet activeEffectfunction effect(fn, options = EMPTY_OBJ) &#123; if (isEffect(fn)) &#123; // 如果 fn 已经是一个 effect 函数了，则指向原始函数 fn = fn.raw &#125; // 创建一个 wrapper，它是一个响应式的副作用的函数 const effect = createReactiveEffect(fn, options) if (!options.lazy) &#123; // lazy 配置，计算属性会用到，非 lazy 则直接执行一次 effect() &#125; return effect&#125;function createReactiveEffect(fn, options) &#123; const effect = function reactiveEffect(...args) &#123; if (!effect.active) &#123; // 非激活状态，则判断如果非调度执行，则直接执行原始函数。 return options.scheduler ? undefined : fn(...args) &#125; if (!effectStack.includes(effect)) &#123; // 清空 effect 引用的依赖 cleanup(effect) try &#123; // 开启全局 shouldTrack，允许依赖收集 enableTracking() // 压栈 effectStack.push(effect) activeEffect = effect // 执行原始函数 return fn(...args) &#125; finally &#123; // 出栈 effectStack.pop() // 恢复 shouldTrack 开启之前的状态 resetTracking() // 指向栈最后一个 effect activeEffect = effectStack[effectStack.length - 1] &#125; &#125; &#125; effect.id = uid++ // 标识是一个 effect 函数 effect._isEffect = true // effect 自身的状态 effect.active = true // 包装的原始函数 effect.raw = fn // effect 对应的依赖，双向指针，依赖包含对 effect 的引用，effect 也包含对依赖的引用 effect.deps = [] // effect 的相关配置 effect.options = options return effect&#125; 结合上述代码来看，effect 内部通过执行 createReactiveEffect 函数去创建一个新的 effect 函数，为了和外部的 effect 函数区分，我们把它称作 reactiveEffect 函数，并且还给它添加了一些额外属性（我在注释中都有标明）。另外，effect 函数还支持传入一个配置参数以支持更多的 feature，我们这里就不展开了，在后续的章节会详细分析。 接着说，这个 reactiveEffect 函数就是响应式的副作用函数，当执行 trigger 过程派发通知的时候，执行的 effect 就是它。 按我们之前的分析，这个 reactiveEffect 函数只需要做两件事情： 把全局的 activeEffect 指向它 ， 然后执行被包装的原始函数 fn 即可 。 但实际上它的实现要更复杂一些，首先它会判断 effect 的状态是否是 active，这其实是一种控制手段，允许在非 active 状态且非调度执行情况，则直接执行原始函数 fn 并返回，在后续学习完侦听器后你会对它的理解更加深刻。 接着判断 effectStack 中是否包含 effect，如果没有就把 effect 压入栈内。之前我们提到，只要设置 activeEffect &#x3D; effect 即可，那么这里为什么要设计一个栈的结构呢？ 其实是考虑到以下这样一个嵌套 effect 的场景： 123456789101112131415161718import &#123; reactive&#125; from &#x27;vue&#x27; import &#123; effect &#125; from &#x27;@vue/reactivity&#x27; const counter = reactive(&#123; num: 0, num2: 0 &#125;) function logCount() &#123; effect(logCount2) console.log(&#x27;num:&#x27;, counter.num) &#125; function count() &#123; counter.num++ &#125; function logCount2() &#123; console.log(&#x27;num2:&#x27;, counter.num2) &#125; effect(logCount) count() 我们每次执行 effect 函数时，如果仅仅把 reactiveEffect 函数赋值给 activeEffect，那么针对这种嵌套场景，执行完 effect(logCount2) 后，activeEffect 还是 effect(logCount2) 返回的 reactiveEffect 函数，这样后续访问 counter.num 的时候，依赖收集对应的 activeEffect 就不对了，此时我们外部执行 count 函数修改 counter.num 后执行的便不是 logCount 函数，而是 logCount2 函数，最终输出的结果如下： 123num2: 0 num: 0 num2: 0 而我们期望的结果应该如下： 1234num2: 0 num: 0 num2: 0 num: 1 因此针对嵌套 effect 的场景，我们不能简单地赋值 activeEffect，应该考虑到函数的执行本身就是一种入栈出栈操作，因此我们也可以设计一个 effectStack，这样每次进入 reactiveEffect 函数就先把它入栈，然后 activeEffect 指向这个 reactiveEffect 函数，接着在 fn 执行完毕后出栈，再把 activeEffect 指向 effectStack 最后一个元素，也就是外层 effect 函数对应的 reactiveEffect。 这里我们还注意到一个细节，在入栈前会执行 cleanup 函数清空 reactiveEffect 函数对应的依赖 。在执行 track 函数的时候，除了收集当前激活的 effect 作为依赖，还通过 activeEffect.deps.push(dep) 把 dep 作为 activeEffect 的依赖，这样在 cleanup 的时候我们就可以找到 effect 对应的 dep 了，然后把 effect 从这些 dep 中删除。cleanup 函数的代码如下所示： 123456789function cleanup(effect) &#123; const &#123; deps &#125; = effect if (deps.length) &#123; for (let i = 0; i &lt; deps.length; i++) &#123; deps[i].delete(effect) &#125; deps.length = 0 &#125;&#125; 为什么需要 cleanup 呢？如果遇到这种场景： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div v-if=&quot;state.showMsg&quot;&gt; &#123;&#123; state.msg &#125;&#125; &lt;/div&gt; &lt;div v-else&gt; &#123;&#123; Math.random()&#125;&#125; &lt;/div&gt; &lt;button @click=&quot;toggle&quot;&gt;Toggle Msg&lt;/button&gt; &lt;button @click=&quot;switchView&quot;&gt;Switch View&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import &#123; reactive &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const state = reactive(&#123; msg: &#x27;Hello World&#x27;, showMsg: true &#125;) function toggle()&#123; state.msg = state.msg === &#x27;Hello World&#x27; ? &#x27;Hello Vue&#x27; : &#x27;Hello World&#x27; &#125; function switchView()&#123; state.showMsg = !state.showMsg &#125; return &#123; toggle, switchView, state &#125; &#125; &#125;&lt;/script&gt; 结合代码可以知道，这个组件的视图会根据 showMsg 变量的控制显示 msg 或者一个随机数，当我们点击 Switch View 的按钮时，就会修改这个变量值。 假设没有 cleanup，在第一次渲染模板的时候，activeEffect 是组件的副作用渲染函数，因为模板 render 的时候访问了 state.msg，所以会执行依赖收集，把副作用渲染函数作为 state.msg 的依赖，我们把它称作 render effect。然后我们点击 Switch View 按钮，视图切换为显示随机数，此时我们再点击 Toggle Msg 按钮，由于修改了 state.msg 就会派发通知，找到了 render effect 并执行，就又触发了组件的重新渲染。 但这个行为实际上并不符合预期，因为当我们点击 Switch View 按钮，视图切换为显示随机数的时候，也会触发组件的重新渲染，但这个时候视图并没有渲染 state.msg，所以对它的改动并不应该影响组件的重新渲染。 因此在组件的 render effect 执行之前，如果通过 cleanup 清理依赖，我们就可以删除之前 state.msg 收集的 render effect 依赖。这样当我们修改 state.msg 时，由于已经没有依赖了就不会触发组件的重新渲染，符合预期。 至此，我们从 reactive API 入手了解了整个响应式对象的实现原理。除了 reactive API，Vue.js 3.0 还提供了其他好用的响应式 API，接下来我们一起分析一些常用的。 readonly API如果用 const 声明一个对象变量，虽然不能直接对这个变量赋值，但我们可以修改它的属性。如果我们希望创建只读对象，不能修改它的属性，也不能给这个对象添加和删除属性，让它变成一个真正意义上的只读对象。 123456const original = &#123; foo: 1&#125;const wrapped = readonly(original)wrapped.foo = 2// warn: Set operation on key &quot;foo&quot; failed: target is readonly. 显然，想实现上述需求就需要劫持对象，于是 Vue.js 3.0 在 reactive API 的基础上，设计并实现了 readonly API。 我们先来看一下 readonly 的实现： 1234567891011121314151617181920212223242526272829303132333435363738function readonly(target) &#123; return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers)&#125;function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) &#123; if (!isObject(target)) &#123; // 目标必须是对象或数组类型 if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; console.warn(value cannot be made reactive: $&#123;String(target)&#125;) &#125; return target &#125; if (target.__v_raw &amp;&amp; !(isReadonly &amp;&amp; target.__v_isReactive)) &#123; // target 已经是 Proxy 对象，直接返回 // 有个例外，如果是 readonly 作用于一个响应式对象，则继续 return target &#125; if (hasOwn( target, isReadonly ? &quot;__v_readonly&quot; /* readonly */ : &quot;__v_reactive&quot; / /* reactive */ ) ) &#123; // target 已经有对应的 Proxy 了 return isReadonly ? target.__v_readonly : target.__v_reactive &#125; // 只有在白名单里的数据类型才能变成响应式 if (!canObserve(target)) &#123; return target &#125; // 利用 Proxy 创建响应式 const observed = new Proxy(target, collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers) // 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了 def(target, isReadonly ? &quot;__v_readonly&quot; /* readonly */ : &quot;__v_reactive&quot; /*reactive */, observed ) return observed&#125; 其实 readonly 和 reactive 函数的主要区别，就是执行 createReactiveObject 函数时的参数 isReadonly 不同。 我们来看这里的代码，首先 isReadonly 变量为 true，所以在创建过程中会给原始对象 target 打上一个 __v_readonly 的标识。另外还有一个特殊情况，如果 target 已经是一个 reactive 对象，就会把它继续变成一个 readonly 响应式对象。 其次就是 baseHandlers 的 collectionHandlers 的区别，我们这里仍然只关心基本数据类型的 Proxy 处理器对象，readonly 函数传入的 baseHandlers 值是 readonlyHandlers。 接下来，我们来看一下其中 readonlyHandlers 的实现： 1234567891011121314151617const readonlyHandlers = &#123; get: readonlyGet, has, ownKeys, set(target, key) &#123; if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; console.warn(`Set operation on key &quot;$&#123;String(key)&#125;&quot; failed: target is readonly.`, target) &#125; return true &#125;, deleteProperty(target, key) &#123; if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; console.warn(`Delete operation on key &quot;$&#123;String(key)&#125;&quot; failed: target is readonly.`, target) &#125; return true &#125;&#125; readonlyHandlers 和 mutableHandlers 的区别主要在 get、set 和 deleteProperty 三个函数上。很显然，作为一个只读的响应式对象，是不允许修改属性以及删除属性的，所以在非生产环境下 set 和 deleteProperty 函数的实现都会报警告，提示用户 target 是 readonly 的。 接下来我们来看一下其中 readonlyGet 的实现，它其实就是 createGetter(true) 的返回值： 1234567891011121314function createGetter(isReadonly = false) &#123; return function get(target, key, receiver) &#123; // ... // isReadonly 为 true 则不需要依赖收集 !isReadonly &amp;&amp; track(target, &quot;get&quot; /* GET */, key) return isObject(res) ? isReadonly ? // 如果 res 是个对象或者数组类型，则递归执行 readonly 函数把 res readonly readonly(res) : reactive(res) : res &#125;&#125; 可以看到，它和 reactive API 最大的区别就是不做依赖收集了，这一点也非常好理解，因为它的属性不会被修改，所以就不用跟踪它的变化了。 到这里，readonly API 就介绍完了，接下来我们分析一下另一个常用的响应式 API：ref。 ref API通过前面的分析，我们知道 reactive API 对传入的 target 类型有限制，必须是对象或者数组类型，而对于一些基础类型（比如 String、Number、Boolean）是不支持的。 但是有时候从需求上来说，可能我只希望把一个字符串变成响应式，却不得不封装成一个对象，这样使用上多少有一些不方便，于是 Vue.js 3.0 设计并实现了 ref API。 12const msg = ref(&#x27;Hello World&#x27;) msg.value = &#x27;Hello Vue&#x27; 我们先来看一下 ref 的实现： 1234567891011121314151617181920212223242526272829303132function ref(value) &#123; return createRef(value)&#125;const convert = (val) =&gt; isObject(val) ? reactive(val) : valfunction createRef(rawValue) &#123; if (isRef(rawValue)) &#123; // 如果传入的就是一个 ref，那么返回自身即可，处理嵌套 ref 的情况。 return rawValue &#125; // 如果是对象或者数组类型，则转换一个 reactive 对象。 let value = convert(rawValue) const r = &#123; __v_isRef: true, get value() &#123; // getter // 依赖收集，key 为固定的 value track(r, &quot;get&quot; /* GET */, &#x27;value&#x27;) return value &#125;, set value(newVal) &#123; // setter，只处理 value 属性的修改 if (hasChanged(toRaw(newVal), rawValue)) &#123; // 判断有变化后更新值 rawValue = newVal value = convert(newVal) // 派发通知 trigger(r, &quot;set&quot; /* SET */, &#x27;value&#x27;, void 0) &#125; &#125; &#125; return r&#125; 可以看到，函数首先处理了嵌套 ref 的情况，如果传入的 rawValue 也是 ref，那么直接返回。 接着对 rawValue 做了一层转换，如果 rawValue 是对象或者数组类型，那么把它转换成一个 reactive 对象。 最后定义一个对 value 属性做 getter 和 setter 劫持的对象并返回，get 部分就是执行 track 函数做依赖收集然后返回它的值；set 部分就是设置新值并且执行 trigger 函数派发通知。 总结最后我们通过一张图来看一下整个响应式 API 实现和组件更新的关系： 这幅图是不是很眼熟？没错，它和前面 Vue.js 2.x 的响应式原理图很接近，其实 Vue.js 3.0 在响应式的实现思路和 Vue.js 2.x 差别并不大，主要就是 劫持数据的方式改成用 Proxy 实现 ， 以及收集的依赖由 watcher 实例变成了组件副作用渲染函数 。 本节课的相关代码在源代码中的位置如下：packages&#x2F;reactivity&#x2F;src&#x2F;baseHandlers.tspackages&#x2F;reactivity&#x2F;src&#x2F;effect.tspackages&#x2F;reactivity&#x2F;src&#x2F;reactive.tspackages&#x2F;reactivity&#x2F;src&#x2F;ref.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"reactive","slug":"reactive","permalink":"https://xiaozhouguo.github.io/tags/reactive/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"依赖注入：子孙组件如何共享数据？","slug":"vue3/provide-inject","date":"2022-07-26T06:46:22.000Z","updated":"2022-08-01T02:37:19.087Z","comments":true,"path":"2022/07/26/vue3/provide-inject/","link":"","permalink":"https://xiaozhouguo.github.io/2022/07/26/vue3/provide-inject/","excerpt":"Vue.js 为我们提供了很多组件通讯的方式，常见的是父子组件通过 props 传递数据。但是有时，我们希望能跨父子组件通讯，比如，无论组件之间嵌套多少层级，我都希望在后代组件中能访问它们祖先组件的数据。","text":"Vue.js 为我们提供了很多组件通讯的方式，常见的是父子组件通过 props 传递数据。但是有时，我们希望能跨父子组件通讯，比如，无论组件之间嵌套多少层级，我都希望在后代组件中能访问它们祖先组件的数据。 前言Vue.js 2.x 给我们提供了一种依赖注入的解决方案，即在祖先组件提供一个 provide 选项，举个例子： 12345678// Provider export default &#123; provide: function () &#123; return &#123; foo: this.foo &#125; &#125; &#125; 这就相当于在祖先组件提供 foo 这个变量数据，我们就可以在任意子孙组件中注入这个变量数据： 1234// Consumer export default &#123; inject: [&#x27;foo&#x27;] &#125; 这样，我们就可以在子孙组件中通过 this.foo 访问祖先组件提供的数据，以达到组件通讯的目的。 到了 Vue.js 3.0，除了可以继续沿用这种 Options 的依赖注入，还可以使用依赖注入的 API 函数 provide 和 inject，你可以在 setup 函数中调用它们。 举个例子，我们在祖先组件调用 provide API： 12345678// Provider import &#123; provide, ref &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const theme = ref(&#x27;dark&#x27;) provide(&#x27;theme&#x27;, theme) &#125; &#125; 然后在子孙组件调用 inject API： 12345678910// Consumer import &#123; inject &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const theme = inject(&#x27;theme&#x27;, &#x27;light&#x27;) return &#123; theme &#125; &#125; &#125; 这里要说明的是，inject 函数接受第二个参数作为默认值，如果祖先组件上下文没有提供 theme，则使用这个默认值。 实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，而且它的规则更加宽松：祖先组件不需要知道哪些后代组件在使用它提供的数据，后代组件也不需要知道注入的数据来自哪里。 那么，依赖注入的背后实现原理是怎样的呢？接下来我们就一起分析吧。 provide API我们先来分析 provide API 的实现原理： 12345678function provide(key, value) &#123; let provides = currentInstance.provides const parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides if (parentProvides === provides) &#123; provides = currentInstance.provides = Object.create(parentProvides) &#125; provides[key] = value &#125; 在创建组件实例的时候，组件实例的 provides 对象指向父组件实例的 provides 对象： 123456const instance = &#123; // 依赖注入相关 provides: parent ? parent.provides : Object.create(appContext.provides), // 其它属性 // ... &#125; 这里，我们可以通过一张图直观感受一下它们之间的关系： 所以在默认情况下，组件实例的 provides 继承它的父组件，但是当组件实例需要提供自己的值的时候，它使用父级提供的对象创建自己的 provides 的对象原型。通过这种方式，在 inject 阶段，我们可以非常容易通过原型链查找来自直接父级提供的数据。 另外，如果组件实例提供和父级 provides 中有相同 key 的数据，是可以覆盖父级提供的数据。举个例子： 123456789101112131415161718192021222324import &#123; createApp, h, provide, inject &#125; from &#x27;vue&#x27; const ProviderOne = &#123; setup () &#123; provide(&#x27;foo&#x27;, &#x27;foo&#x27;) provide(&#x27;bar&#x27;, &#x27;bar&#x27;) return () =&gt; h(ProviderTwo) &#125; &#125; const ProviderTwo = &#123; setup () &#123; provide(&#x27;foo&#x27;, &#x27;fooOverride&#x27;) provide(&#x27;baz&#x27;, &#x27;baz&#x27;) return () =&gt; h(Consumer) &#125; &#125; const Consumer = &#123; setup () &#123; const foo = inject(&#x27;foo&#x27;) const bar = inject(&#x27;bar&#x27;) const baz = inject(&#x27;baz&#x27;) return () =&gt; h(&#x27;div&#x27;, [foo, bar, baz].join(&#x27;&amp;&#x27;)) &#125; &#125; createApp(ProviderOne).mount(&#x27;#app&#x27;) 可以看到，这是一个嵌套 provider 的情况。根据 provide 函数的实现，ProviderTwo 提供的 key 为 foo 的 provider 会覆盖 ProviderOne 提供的 key 为 foo 的 provider，所以最后渲染在 Consumer 组件上的就是 fooOverride&amp;bar&amp;baz 。 接下来，我们来分析另一个依赖注入的 API —— inject。 inject API我们先来看 inject API 的实现原理： 123456789101112131415function inject(key, defaultValue) &#123; const instance = currentInstance || currentRenderingInstance if (instance) &#123; const provides = instance.provides if (key in provides) &#123; return provides[key] &#125; else if (arguments.length &gt; 1) &#123; return defaultValue &#125; else if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; warn(`injection &quot;$&#123;String(key)&#125;&quot; not found.`) &#125; &#125; &#125; 前文我们已经分析了 provide 的实现后，在此基础上，理解 inject 的实现就非常简单了。inject 支持两个参数，第一个参数是 key，我们可以访问组件实例中的 provides 对象对应的 key，层层查找父级提供的数据。第二个参数是默认值，如果查找不到数据，则直接返回默认值。 如果既查找不到数据且也没有传入默认值，则在非生产环境下报警告，提示用户找不到这个注入的数据。 到这里我们就掌握了 provide 和 inject 的实现原理。但是，我曾经看到过一个问题：“ Vue.js 3 跨组件共享数据，为何要用 provide&#x2F;inject ？直接 export&#x2F;import 数据行吗？“ 接下来我们就来探讨依赖注入和模块化共享数据的差异。 对比模块化共享数据的方式我们先来看提问者给出的一个模块化共享数据的示例，即首先在根组件创建一个共享的数据 sharedData： 123456789// Root.js export const sharedData = ref(&#x27;&#x27;) export default &#123; name: &#x27;Root&#x27;, setup() &#123; // ... &#125;, // ... &#125; 然后在子组件中使用 sharedData： 1234567import &#123; sharedData &#125; from &#x27;./Root.js&#x27; export default &#123; name: &#x27;Root&#x27;, setup() &#123; // 这里直接使用 sharedData 即可 &#125; &#125; 当然，从这个示例上来看，模块化的方式是可以共享数据，但是 provide 和 inject 与模块化方式有如下几点不同。 作用域不同 对于依赖注入，它的作用域是局部范围，所以你只能把数据注入以这个节点为根的后代组件中，不是这棵子树上的组件是不能访问到该数据的；而对于模块化的方式，它的作用域是全局范围的，你可以在任何地方引用它导出的数据。 数据来源不同 对于依赖注入，后代组件是不需要知道注入的数据来自哪里，只管注入并使用即可；而对于模块化的方式提供的数据，用户必须明确知道这个数据是在哪个模块定义的，从而引入它。 上下文不同 对于依赖注入，提供数据的组件的上下文就是组件实例，而且同一个组件定义是可以有多个组件实例的，我们可以根据不同的组件上下文提供不同的数据给后代组件；而对于模块化提供的数据，它是没有任何上下文的，仅仅是这个模块定义的数据，如果想要根据不同的情况提供不同数据，那么从 API 层面设计就需要做更改。 比如允许用户传递一个参数： 123export function getShareData(context) &#123; // 根据不同的 context 参数返回不同的数据 &#125; 掌握了这些不同，在不同场景下你就应该知道选择哪种方式提供数据了。 依赖注入的缺陷和应用场景我们再回到依赖注入，它确实提供了一种组件共享的方式，但并非完美的。正因为依赖注入是上下文相关的，所以它会将你应用程序中的组件与它们当前的组织方式耦合起来，这使得重构变得困难。 来回顾一下依赖注入的特点 ：祖先组件不需要知道哪些后代组件使用它提供的数据，后代组件也不需要知道注入的数据来自哪里。 如果在一次重构中我们不小心挪动了有依赖注入的后代组件的位置，或者是挪动了提供数据的祖先组件的位置，都有可能导致后代组件丢失注入的数据，进而导致应用程序异常。所以，我并不推荐在普通应用程序代码中使用依赖注入。 但是我推荐你在组件库的开发中使用，因为对于一个特定组件，它和其嵌套的子组件上下文联系很紧密。 这里来举一个 Element-UI 组件库 Select 组件的例子： 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; options: [&#123; value: &#x27;选项1&#x27;, label: &#x27;黄金糕&#x27; &#125;, &#123; value: &#x27;选项2&#x27;, label: &#x27;双皮奶&#x27; &#125;, &#123; value: &#x27;选项3&#x27;, label: &#x27;蚵仔煎&#x27; &#125;, &#123; value: &#x27;选项4&#x27;, label: &#x27;龙须面&#x27; &#125;, &#123; value: &#x27;选项5&#x27;, label: &#x27;北京烤鸭&#x27; &#125;], value: &#x27;&#x27; &#125; &#125; &#125; &lt;/script&gt; 这是 Select 组件的基础示例，它最终会在页面上渲染成这样： 子组件 ElOption 负责渲染每一个选项，它的内部想要访问最外层的 ElSelect 组件时，就可以通过依赖注入的方式，在 ElSelect 组件中提供组件的实例： 1234567export default &#123; provide() &#123; return &#123; &#x27;select&#x27;: this &#125;; &#125; &#125; 就这样，我们可以在 ElOption 组件注入这个数据： 123export default &#123; inject: [&#x27;select&#x27;] &#125; 虽然这些代码还是用的 Vue.js 2.x 的 Options API 方式，但是依赖注入的思想是不变的。 你可能会问，为什么不在 ElOption 子组件内通过 this.$parent 访问外层的 ElSelect 组件实例呢？ 虽然 this.$parent 指向的是它的父组件实例，在我们这个例子是可以的，但如果组件结构发生了变化呢？ 我们再来看另一个 Select 组件的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;el-select v-model=&quot;value&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option-group v-for=&quot;group in options&quot; :key=&quot;group.label&quot; :label=&quot;group.label&quot;&gt; &lt;el-option v-for=&quot;item in group.options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot;&gt; &lt;/el-option&gt; &lt;/el-option-group&gt; &lt;/el-select&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; options: [&#123; label: &#x27;热门城市&#x27;, options: [&#123; value: &#x27;Shanghai&#x27;, label: &#x27;上海&#x27; &#125;, &#123; value: &#x27;Beijing&#x27;, label: &#x27;北京&#x27; &#125;] &#125;, &#123; label: &#x27;城市名&#x27;, options: [&#123; value: &#x27;Chengdu&#x27;, label: &#x27;成都&#x27; &#125;, &#123; value: &#x27;Shenzhen&#x27;, label: &#x27;深圳&#x27; &#125;, &#123; value: &#x27;Guangzhou&#x27;, label: &#x27;广州&#x27; &#125;, &#123; value: &#x27;Dalian&#x27;, label: &#x27;大连&#x27; &#125;] &#125;], value: &#x27;&#x27; &#125; &#125; &#125; &lt;/script&gt; 这是 Select 组件的分组示例，最终会在页面上渲染成这样： 显然，这里 ElOption 中的 this.$parent 指向的就不是 ElSelect 组件实例，而是 ElOptionGroup 组件实例。但如果我们用依赖注入的方式，即使结构变了，还是可以在 ElOption 组件中正确访问到 ElSelect 的实例。 所以，this.$parent 是一种强耦合的获取父组件实例方式，非常不利于代码的重构，因为一旦组件层级发生变化，就会产生非预期的后果，所以在平时的开发工作中你应该慎用这个属性。 相反，在组件库的场景中，依赖注入还是很方便的，除了示例中提供组件实例数据，还可以提供任意类型的数据。因为入口组件和它的相关子组件关联性是很强的，无论后代组件的结构如何变化，最终都会渲染在入口组件的子树上。 总结好的，到这里我们这一节的学习就结束啦，通过这节课的学习，你应该掌握 Vue.js 依赖注入的实现原理，了解依赖注入的使用场景和它的缺陷。 到目前为止，我们已经学习了 Vue.js 3.0 提供的所有常用的 Composition API。可以看到和 Vue.js 2.x Options API 相比，我们不再是通过编写一些组件配置去描述一个组件，更像是主动调用一些 API 去编写组件的实现逻辑。 Vue.js 2.x 中，框架背后帮我们做了很多事情，比如我们在 data 中定义的变量，在组件实例化阶段会把它们变成响应式的，这个行为是黑盒的，用户是无感知的。反观 Vue.js 3.0 Composition API，用户会利用 reactive 或者 ref API 主动去申明一个响应式对象。 所以通过 Composition API 去编写组件，用户更清楚自己在做什么事情。 另外，为什么说 Composition API 比 mixin 更适合逻辑复用呢？ 其实，二者都是把复用的逻辑放在单独的文件中维护。但从使用的方式而言，用户只是在需要混入 mixin 的组件中去申明这个 mixin，使用方式如下： 1234567891011&lt;template&gt; &lt;div&gt; Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import mousePositionMixin from &#x27;./mouse&#x27; export default &#123; mixins: [mousePositionMixin] &#125; &lt;/script&gt; 我们在组件中申明了 mousePositionMixin，组件模板中使用的 x、y 就来源于这个 mixin，这一切都是 Vue.js 内部帮我们做的。如果该组件只引入这单个 mixin，问题倒不大，但如果这个组件引入的 mixin 越来越多，很容易出现命名冲突的情况，以及造成数据来源不清晰等问题。 而我们通过 Composition API 去编写功能类似的 hook 函数，使用方式如下： 1234567891011121314&lt;template&gt; &lt;div&gt; Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import useMousePosition from &#x27;./mouse&#x27; export default &#123; setup() &#123; const &#123; x, y &#125; = useMousePosition() return &#123; x, y &#125; &#125; &#125; &lt;/script&gt; 我们可以清楚地分辨出模板中使用的 x、y 是来源于 useMousePosition 函数，即便我们引入更多的 hook 函数，也不会出现命名冲突的情况。 Composition API 在逻辑复用上确实有不错的优势，但是它并非完美的，使用起来会增加代码量。Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，还是可以使用 Options API 的。 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-core&#x2F;src&#x2F;apiInject.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"provide","slug":"provide","permalink":"https://xiaozhouguo.github.io/tags/provide/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"生命周期：各个生命周期的执行时机和应用场景是怎么样的？","slug":"vue3/life-cycle","date":"2022-07-07T08:44:51.000Z","updated":"2022-07-14T03:37:18.722Z","comments":true,"path":"2022/07/07/vue3/life-cycle/","link":"","permalink":"https://xiaozhouguo.github.io/2022/07/07/vue3/life-cycle/","excerpt":"Vue.js 组件的生命周期包括创建、更新、销毁等过程。在这些过程中也会运行叫生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。","text":"Vue.js 组件的生命周期包括创建、更新、销毁等过程。在这些过程中也会运行叫生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 前言在 Vue.js 2.x 中，我们通常会在组件对象中定义一些生命周期钩子函数，到了 Vue.js 3.0，依然兼容 Vue.js 2.x 生命周期的语法，但是 Composition API 提供了一些生命周期函数的 API，让我们可以主动注册不同的生命周期。 123456789101112// Vue.js 2.x 定义生命周期钩子函数 export default &#123; created() &#123; // 做一些初始化工作 &#125;, mounted() &#123; // 可以拿到 DOM 节点 &#125;, beforeDestroy() &#123; // 做一些清理操作 &#125; &#125; 1234567891011121314// Vue.js 3.x 生命周期 API 改写上例 import &#123; onMounted, onBeforeUnmount &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; // 做一些初始化工作 onMounted(() =&gt; &#123; // 可以拿到 DOM 节点 &#125;) onBeforeUnmount(()=&gt;&#123; // 做一些清理操作 &#125;) &#125; &#125; 可以看到，在 Vue.js 3.0 中，setup 函数已经替代了 Vue.js 2.x 的 beforeCreate 和 created 钩子函数，我们可以在 setup 函数做一些初始化工作，比如发送一个异步 Ajax 请求获取数据。 我们用 onMounted API 替代了 Vue.js 2.x 的 mounted 钩子函数，用 onBeforeUnmount API 替代了 Vue.js 2.x 的 beforeDestroy 钩子函数。 其实，Vue.js 3.0 针对 Vue.js 2.x 的生命周期钩子函数做了全面替换，映射关系如下： 1234567891011beforeCreate -&gt; 使用 setup() created -&gt; 使用 use setup() beforeMount -&gt; onBeforeMount mounted -&gt; onMounted beforeUpdate -&gt; onBeforeUpdate updated -&gt; onUpdated beforeDestroy-&gt; onBeforeUnmount destroyed -&gt; onUnmounted activated -&gt; onActivated deactivated -&gt; onDeactivated errorCaptured -&gt; onErrorCaptured 除此之外，Vue.js 3.0 还新增了两个用于调试的生命周期 API：onRenderTracked 和 onRenderTriggered。 那么，这些生命周期钩子函数内部是如何实现的？它们又分别在组件生命周期的哪些阶段执行的？分别适用于哪些开发场景？ 带着这些疑问，我们来深入学习生命周期钩子函数背后的实现原理。 注册钩子函数首先，我们来看这些钩子函数是如何注册的，先来看一下它们的实现： 1234567891011const onBeforeMount = createHook(&#x27;bm&#x27; /* BEFORE_MOUNT */) const onMounted = createHook(&#x27;m&#x27; /* MOUNTED */) const onBeforeUpdate = createHook(&#x27;bu&#x27; /* BEFORE_UPDATE */) const onUpdated = createHook(&#x27;u&#x27; /* UPDATED */) const onBeforeUnmount = createHook(&#x27;bum&#x27; /* BEFORE_UNMOUNT */) const onUnmounted = createHook(&#x27;um&#x27; /* UNMOUNTED */) const onRenderTriggered = createHook(&#x27;rtg&#x27; /* RENDER_TRIGGERED */) const onRenderTracked = createHook(&#x27;rtc&#x27; /* RENDER_TRACKED */) const onErrorCaptured = (hook, target = currentInstance) =&gt; &#123; injectHook(&#x27;ec&#x27; /* ERROR_CAPTURED */, hook, target) &#125; 我们发现除了 onErrorCaptured，其他钩子函数都是通过 createHook 函数创建的，通过传入不同的字符串来表示不同的钩子函数。 那么，我们就来分析一下 createHook 钩子函数的实现原理： 12345const createHook = function(lifecycle) &#123; return function (hook, target = currentInstance) &#123; injectHook(lifecycle, hook, target) &#125; &#125; createHook 会返回一个函数，它的内部通过 injectHook 注册钩子函数。你可能会问，这里为什么要用 createHook 做一层封装而不直接使用 injectHook API 呢？比如： 123456const onBeforeMount = function(hook,target = currentInstance) &#123; injectHook(&#x27;bm&#x27;, hook, target) &#125; const onMounted = function(hook,target = currentInstance) &#123; injectHook(&#x27;m&#x27;, hook, target) &#125; 这样实现当然也是可以的，不过，我们可以发现，这些钩子函数内部执行逻辑很类似，都是执行 injectHook，唯一的区别是第一个参数字符串不同，所以这样的代码是可以进一步封装的，即用 createHook 封装，这就是一个典型的函数柯里化技巧。 在调用 createHook 返回的函数时，也就不需要传入 lifecycle 字符串，因为它在执行 createHook 函数时就已经实现了该参数的保留。 所以，当我们通过 onMounted(hook) 注册一个钩子函数时，内部就是通过 injectHook(&#39;m&#39;, hook) 去注册的，接下来我们来进一步看 injectHook 函数的实现原理： 1234567891011121314151617181920212223242526function injectHook(type, hook, target = currentInstance, prepend = false) &#123; const hooks = target[type] || (target[type] = []) // 封装 hook 钩子函数并缓存 const wrappedHook = hook.__weh || (hook.__weh = (...args) =&gt; &#123; if (target.isUnmounted) &#123; return &#125; // 停止依赖收集 pauseTracking() // 设置 target 为当前运行的组件实例 setCurrentInstance(target) // 执行钩子函数 const res = callWithAsyncErrorHandling(hook, target, type, args) setCurrentInstance(null) // 恢复依赖收集 resetTracking() return res &#125;) if (prepend) &#123; hooks.unshift(wrappedHook) &#125; else &#123; hooks.push(wrappedHook) &#125; &#125; 结合代码来看，该函数主要是对用户注册的钩子函数 hook 做了一层封装，然后添加到一个数组中，把数组保存在当前组件实例的 target 上，这里，key 是用来区分钩子函数的字符串。比如， onMounted 注册的钩子函数在组件实例上就是通过 instance.m 来保存。 这样的设计其实非常好理解，因为生命周期的钩子函数，是在组件生命周期的各个阶段执行，所以钩子函数必须要保存在当前的组件实例上，这样后面就可以在组件实例上通过不同的字符串 key 找到对应的钩子函数数组并执行。 对于相同的钩子函数，会把封装的 wrappedHook 钩子函数缓存到 hook.__weh 中，这样后续通过 scheduler 方式执行的钩子函数就会被去重。 在后续执行 wrappedHook 函数时，会先停止依赖收集，因为钩子函数内部访问的响应式对象，通常都已经执行过依赖收集，所以钩子函数执行的时候没有必要再次收集依赖，毕竟这个过程也有一定的性能消耗。 接着是设置 target 为当前组件实例。在 Vue.js 的内部，会一直维护当前运行的组件实例 currentInstance，在注册钩子函数的过程中，我们可以拿到当前运行组件实例 currentInstance，并用 target 保存，然后在钩子函数执行时，为了确保此时的 currentInstance 和注册钩子函数时一致，会通过 setCurrentInstance(target) 设置 target 为当前组件实例。 接下来就是通过 callWithAsyncErrorHandling 方法去执行我们注册的 hook 钩子函数，函数执行完毕则设置当前运行组件实例为 null，并恢复依赖收集。 到这里，我们就了解了生命周期钩子函数是如何注册以及如何执行的，接下来，我们来依次分析各个钩子函数的执行时机和应用场景。 首先，我们来看通过 onBeforeMount 和 onMounted 注册的钩子函数。 onBeforeMount 和 onMountedonBeforeMount 注册的 beforeMount 钩子函数会在组件挂载之前执行，onMounted 注册的 mounted 钩子函数会在组件挂载之后执行。我们来回顾一下组件副作用渲染函数关于组件挂载部分的实现： 123456789101112131415161718192021222324252627const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; &#123; // 创建响应式的副作用渲染函数 instance.update = effect(function componentEffect() &#123; if (!instance.isMounted) &#123; // 获取组件实例上通过 onBeforeMount 钩子函数和 onMounted 注册的钩子函数 const &#123; bm, m &#125; = instance; // 渲染组件生成子树 vnode const subTree = (instance.subTree = renderComponentRoot(instance)) // 执行 beforemount 钩子函数 if (bm) &#123; invokeArrayFns(bm) &#125; // 把子树 vnode 挂载到 container 中 patch(null, subTree, container, anchor, instance, parentSuspense, isSVG) // 保留渲染生成的子树根 DOM 节点 initialVNode.el = subTree.el // 执行 mounted 钩子函数 if (m) &#123; queuePostRenderEffect(m, parentSuspense) &#125; instance.isMounted = true &#125; else &#123; // 更新组件 &#125; &#125;, prodEffectOptions) &#125; 执行 patch 挂载组件之前，会检测组件实例上是有否有注册的 beforeMount 钩子函数 bm，如果有则通过 invokeArrayFns 执行它，因为用户可以通过多次执行 onBeforeMount 函数注册多个 beforeMount 钩子函数，所以这里 instance.bm 是一个数组，通过遍历这个数组来依次执行 beforeMount 钩子函数。 在执行 patch 挂载组件之后，会检查组件实例上是否有注册的 mounted 钩子函数 m，如果有的话则执行 queuePostRenderEffect，把 mounted 钩子函数推入 postFlushCbs 中，然后在整个应用 render 完毕后，同步执行 flushPostFlushCbs 函数调用 mounted 钩子函数。 我经常在社区里听到一种争论：在组件初始化阶段，对于发送一些 Ajax 异步请求的逻辑，是应该放在 created 钩子函数中，还是应该放在 mounted 钩子函数中？ 其实都可以，因为 created 和 mounted 钩子函数执行的时候都能拿到组件数据，它们执行的顺序虽然有先后，但都会在一个 Tick 内执行完毕，而异步请求是有网络耗时的，其耗时远远大于一个 Tick 的时间。所以，你无论在 created 还是在 mounted 里发请求，都要等请求的响应回来，然后更新数据，再触发组件的重新渲染。 前面说过，Vue.js 2.x 中的 beforeCreate 和 created 钩子函数可以用 setup 函数替代。所以，对于组件初始化阶段发送异步请求的逻辑，放在 setup 函数中、beforeMount 钩子函数中或者 mounted 钩子函数中都可以，它们都可以拿到组件相关的数据。当然，我更推荐在 setup 函数中执行，因为从语义化的角度来看这样更合适。 不过，如果你想依赖 DOM 去做一些初始化操作，那就只能把相关逻辑放在 mounted 钩子函数中了，这样你才能拿到组件渲染后的 DOM。 对于嵌套组件，组件在挂载相关的生命周期钩子函数时，先执行父组件的 beforeMount，然后是子组件的 beforeMount，接着是子组件的 mounted ，最后执行父组件的 mounted。 接下来，我们来看通过 onBeforeUpdate 和 onUpdated 注册的钩子函数。 onBeforeUpdate 和 onUpdatedonBeforeUpdate 注册的 beforeUpdate 钩子函数会在组件更新之前执行，onUpdated 注册的 updated 钩子函数会在组件更新之后执行。我们来回顾一下组件副作用渲染函数关于组件更新的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; &#123; // 创建响应式的副作用渲染函数 instance.update = effect(function componentEffect() &#123; if (!instance.isMounted) &#123; // 渲染组件 &#125; else &#123; // 更新组件 // 获取组件实例上通过 onBeforeUpdate 钩子函数和 onUpdated 注册的钩子函数 let &#123; next, vnode, bu, u &#125; = instance // next 表示新的组件 vnode if (next) &#123; // 更新组件 vnode 节点信息 updateComponentPreRender(instance, next, optimized) &#125; else &#123; next = vnode &#125; // 渲染新的子树 vnode const nextTree = renderComponentRoot(instance) // 缓存旧的子树 vnode const prevTree = instance.subTree // 更新子树 vnode instance.subTree = nextTree // 执行 beforeUpdate 钩子函数 if (bu) &#123; invokeArrayFns(bu) &#125; // 组件更新核心逻辑，根据新旧子树 vnode 做 patch patch( prevTree, nextTree, // 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点 hostParentNode(prevTree.el), // 缓存更新后的 DOM 节点 getNextHostNode(prevTree), instance, parentSuspense, isSVG) // 缓存更新后的 DOM 节点 next.el = nextTree.el // 执行 updated 钩子函数 if (u) &#123; queuePostRenderEffect(u, parentSuspense) &#125; &#125; &#125;, prodEffectOptions) &#125; 在执行 patch 更新组件之前，会检测组件实例上是有否有注册的 beforeUpdate 钩子函数 bu，如果有则通过 invokeArrayFns 执行它。 在执行 patch 更新组件之后，会检查组件实例上是否有注册的 updated 钩子函数 u，如果有，则通过 queuePostRenderEffect 把 updated 钩子函数推入 postFlushCbs 中，因为组件的更新本身就是在 nextTick 后进行 flushJobs，因此此时再次执行 queuePostRenderEffect 推入到队列的任务，会在同一个 Tick 内执行这些 postFlushCbs，也就是执行所有 updated 的钩子函数。 在 beforeUpdate 钩子函数执行时，组件的 DOM 还未更新，如果你想在组件更新前访问 DOM，比如手动移除已添加的事件监听器，你可以注册这个钩子函数。 在 updated 钩子函数执行时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。如果要监听数据的改变并执行某些逻辑，最好不要使用 updated 钩子函数而用计算属性或 watcher 取而代之，因为任何数据的变化导致的组件更新都会执行 updated 钩子函数。另外注意， 不要在 updated 钩子函数中更改数据，因为这样会再次触发组件更新，导致无限递归更新 。 还有，父组件的更新不一定会导致子组件的更新，因为 Vue.js 的更新粒度是组件级别的。 接下来，我们来看通过 onBeforeUnmount 和 onUnmounted 注册的钩子函数。 onBeforeUnmount 和 onUnmountedonBeforeUnmount 注册的 beforeUnMount 钩子函数会在组件销毁之前执行，onUnmounted 注册的 unmounted 钩子函数会在组件销毁之后执行 。我们来看一下组件销毁相关逻辑实现： 1234567891011121314151617181920212223const unmountComponent = (instance, parentSuspense, doRemove) =&gt; &#123; const &#123; bum, effects, update, subTree, um &#125; = instance // 执行 beforeUnmount 钩子函数 if (bum) &#123; invokeArrayFns(bum) &#125; // 清理组件引用的 effects 副作用函数 if (effects) &#123; for (let i = 0; i &lt; effects.length; i++) &#123; stop(effects[i]) &#125; &#125; // 如果一个异步组件在加载前就销毁了，则不会注册副作用渲染函数 if (update) &#123; stop(update) // 调用 unmount 销毁子树 unmount(subTree, instance, parentSuspense, doRemove) &#125; // 执行 unmounted 钩子函数 if (um) &#123; queuePostRenderEffect(um, parentSuspense) &#125; &#125; 其实整个组件销毁的逻辑很简单，主要就是清理组件实例上绑定的 effects 副作用函数和注册的副作用渲染函数 update，以及调用 unmount 销毁子树 unmount 主要就是遍历子树，它会通过递归的方式来销毁子节点，遇到组件节点时执行 unmountComponent，遇到普通节点时则删除 DOM 元素。组件的销毁过程和渲染过程类似，都是递归的过程。 在组件销毁前，会检测组件实例上是有否有注册的 beforeUnmount 钩子函数 bum，如果有则通过 invokeArrayFns 执行。 在组件销毁后，会检测组件实例上是否有注册的 unmounted 钩子函数 um，如果有则通过 queuePostRenderEffect 把 unmounted 钩子函数推入到 postFlushCbs 中，因为组件的销毁就是组件更新的一个分支逻辑，所以在 nextTick 后进行 flushJobs，因此此时再次执行 queuePostRenderEffect 推入队列的任务，会在同一个 Tick 内执行这些 postFlushCbs，也就是执行所有的 unmounted 钩子函数。 对于嵌套组件，组件在执行销毁相关的生命周期钩子函数时，先执行父组件的 beforeUnmount，再执行子组件的 beforeUnmount，然后执行子组件的 unmounted ，最后执行父组件的 unmounted。 虽然组件在销毁阶段会清理一些定义的 effects 函数，删除组件内部的 DOM 元素，但是有一些需要清理的对象，组件并不能自动完成它们的清理，比如你在组件内部创建一个定时器，就应该在 beforeUnmount 或者 unmounted 钩子函数中清除，举个例子： 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import &#123; ref, onBeforeUnmount &#125; from &#x27;vue&#x27; export default &#123; setup () &#123; const count = ref(0) const timer = setInterval(() =&gt; &#123; console.log(count.value++) &#125;, 1000) onBeforeUnmount(() =&gt; &#123; clearInterval(timer) &#125;) return &#123; count &#125; &#125; &#125; &lt;/script&gt; 可以看到，这里我们在 setup 函数内部定义了一个 timer 计时器， count 每秒会加 1 并在控制台中输出。如果这个组件被销毁，就会触发 onBeforeUnmount 注册的 beforeUnmount 钩子函数，然后清除定时器。如果你不清除，就会发现组件销毁后，虽然 DOM 被移除了，计时器仍然存在，并且会一直计时并在控制台输出，这就造成了不必要的内存泄漏。 接下来，我们来看通过 onErrorCaptured 注册的钩子函数 onErrorCaptured在前面的课时中，我们多次接触过一个方法 callWithErrorHandling，它就是执行一段函数并通过 handleError 处理错误。那么，handleError 具体做了哪些事情呢？ 我们先来看一下它的实现： 12345678910111213141516171819202122232425function handleError(err, instance, type) &#123; const contextVNode = instance ? instance.vnode : null if (instance) &#123; let cur = instance.parent // 为了兼容 2.x 版本，暴露组件实例给钩子函数 const exposedInstance = instance.proxy // 获取错误信息 const errorInfo = (process.env.NODE_ENV !== &#x27;production&#x27;) ? ErrorTypeStrings[type] : type // 尝试向上查找所有父组件，执行 errorCaptured 钩子函数 while (cur) &#123; const errorCapturedHooks = cur.ec if (errorCapturedHooks) &#123; for (let i = 0; i &lt; errorCapturedHooks.length; i++) &#123; // 如果执行的 errorCaptured 钩子函数并返回 true，则停止向上查找。、 if (errorCapturedHooks[i](err, exposedInstance, errorInfo)) &#123; return &#125; &#125; &#125; cur = cur.parent &#125; &#125; // 往控制台输出未处理的错误 logError(err, type, contextVNode) &#125; handleError 的实现其实很简单，它会从当前报错的组件的父组件实例开始，尝试去查找注册的 errorCaptured 钩子函数，如果有则遍历执行并且判断 errorCaptured 钩子函数的返回值是否为 true，如果是则说明这个错误已经得到了正确的处理，就会直接结束。 否则会继续遍历，遍历完当前组件实例的 errorCaptured 钩子函数后，如果这个错误还没得到正确处理，则向上查找它的父组件实例，以同样的逻辑去查找是否有正确处理该错误的 errorCaptured 钩子函数，直到查找完毕。 如果整个链路上都没有正确处理错误的 errorCaptured 钩子函数，则通过 logError 往控制台输出未处理的错误。所以 errorCaptured 本质上是捕获一个来自子孙组件的错误，它返回 true 就可以阻止错误继续向上传播。 errorCaptured 在平时工作中可能用的不多，但它的确是一个很实用的功能，比如你可以在根组件注册一个 errorCaptured 钩子函数，去捕获所有子孙组件的错误，并且可以根据错误的类型和信息统计和上报错误。 接下来，我们来看通过 onRenderTracked 和 onRenderTriggered 注册的钩子函数。 onRenderTracked 和 onRenderTriggeredonRenderTracked 和 onRenderTriggered 是 Vue.js 3.0 新增的生命周期 API，它们是在开发阶段渲染调试用的。这里再次回顾一下我们创建的副作用渲染函数的第二个参数（这里你可以去 响应式内部的实现原理是怎样的？ ”中复习一下），在开发环境下它的代码是这样的： 12345678910instance.update = effect(function componentEffect() &#123; // 创建或者更组件 &#125;, createDevEffectOptions(instance)) function createDevEffectOptions(instance) &#123; return &#123; scheduler: queueJob, onTrack: instance.rtc ? e =&gt; invokeArrayFns(instance.rtc, e) : void 0, onTrigger: instance.rtg ? e =&gt; invokeArrayFns(instance.rtg, e) : void 0 &#125; &#125; 通过上述代码我们发现，onRenderTracked 和 onRenderTriggered 注册的钩子函数，原来是在副作用渲染函数的 onTrack 和 onTrigger 对应的函数中执行的。 我们当时介绍 effect 副作用函数的配置时并没有介绍这两个属性，那么它们是做什么用的呢？ 这就要先来看 onTrack 函数的执行时机。我们知道当访问一个响应式对象时，会执行 track 函数做依赖收集，我们来回顾一下它的实现： 12345678910111213141516function track(target, type, key) &#123; // 执行一些依赖收集的操作 if (!dep.has(activeEffect)) &#123; dep.add(activeEffect) activeEffect.deps.push(dep) if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; activeEffect.options.onTrack) &#123; // 执行 onTrack 函数 activeEffect.options.onTrack(&#123; effect: activeEffect, target, type, key &#125;) &#125; &#125;&#125; 可以看到，track 函数先执行依赖收集，然后在非生产环境下检测当前的 activeEffect 的配置有没有定义 onTrack 函数，如果有的则执行该方法。 因此对应到副作用渲染函数，当它执行的时候，activeEffect 就是这个副作用渲染函数，这时访问响应式数据就会触发 track 函数，在执行完依赖收集后，会执行 onTrack 函数，也就是遍历执行我们注册的 renderTracked 钩子函数。 接下来，我们再来回顾一下 trigger 函数的实现： 12345678910111213141516171819202122232425function trigger (target, type, key, newValue) &#123; // 添加要运行的 effects 集合 const run = (effect) =&gt; &#123; if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; effect.options.onTrigger) &#123; // 执行 onTrigger effect.options.onTrigger(&#123; effect, target, key, type, newValue, oldValue, oldTarget &#125;) &#125; if (effect.options.scheduler) &#123; effect.options.scheduler(effect) &#125; else &#123; effect() &#125; &#125; // 遍历执行 effects effects.forEach(run) &#125; 我们知道，trigger 函数首先要创建运行的 effects 集合，然后遍历执行，在执行的过程中，会在非生产环境下检测待执行的 effect 配置中有没有定义 onTrigger 函数，如果有则执行该方法。 因此对应到我们的副作用渲染函数，当它内部依赖的响应式对象值被修改后，就会触发 trigger 函数 ，这个时候副作用渲染函数就会被添加到要运行的 effects 集合中，在遍历执行 effects 的时候会执行 onTrigger 函数，也就是遍历执行我们注册的 renderTriggered 钩子函数。 了解完 renderTracked 和 renderTriggered 钩子函数的执行时机后，我们来看一下实际场景的应用： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;increase&quot;&gt;Increase&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import &#123; ref, onRenderTracked, onRenderTriggered &#125; from &#x27;vue&#x27; export default &#123; setup () &#123; const count = ref(0) function increase () &#123; count.value++ &#125; onRenderTracked((e) =&gt; &#123; console.log(e) debugger &#125;) onRenderTriggered((e) =&gt; &#123; console.log(e) debugger &#125;) return &#123; count, increase &#125; &#125; &#125; &lt;/script&gt; 像这样在开发阶段，我们可以通过注册这两个钩子函数，来追踪组件渲染的依赖来源以及触发组件重新渲染的数据更新来源。 总结好的，到这里我们这一节的学习就结束啦，通过学习，你应该掌握 Vue.js 中生命周期注册的 API，了解各个生命周期的执行时机和应用场景。 最后，我们通过一张图再来直观地感受一下组件的各个生命周期： Vue.js 3.0 还有 2 个生命周期 API，分别是 onActivated 和 onDeactivated，我们将会在介绍 KeepAlive 组件时详细分析。 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-core&#x2F;src&#x2F;apiLifecycle.tspackages&#x2F;runtime-core&#x2F;src&#x2F;renderer.tspackages&#x2F;reactivity&#x2F;src&#x2F;effect.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"life-cycle","slug":"life-cycle","permalink":"https://xiaozhouguo.github.io/tags/life-cycle/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"侦听器的实现原理和使用场景 - 上篇","slug":"vue3/watcher-one","date":"2022-07-05T07:38:34.000Z","updated":"2022-07-05T09:00:58.040Z","comments":true,"path":"2022/07/05/vue3/watcher-one/","link":"","permalink":"https://xiaozhouguo.github.io/2022/07/05/vue3/watcher-one/","excerpt":"在平时的开发工作中，我们经常使用侦听器帮助我们去观察某个数据的变化然后去执行一段逻辑。","text":"在平时的开发工作中，我们经常使用侦听器帮助我们去观察某个数据的变化然后去执行一段逻辑。 前言在 Vue.js 2.x 中，你可以通过 watch 选项去初始化一个侦听器，称作 watcher： 1234567export default &#123; watch: &#123; a(newVal, oldVal) &#123; console.log(&#x27;new: %s, old: %s&#x27;, newVal, oldVal) &#125; &#125; &#125; 当然你也可以通过 $watch API 去创建一个侦听器： 123const unwatch = vm.$watch(&#x27;a&#x27;, function(newVal, oldVal) &#123; console.log(&#x27;new: %s, old: %s&#x27;, newVal, oldVal) &#125;) 与 watch 选项不同，通过 $watch API 创建的侦听器 watcher 会返回一个 unwatch 函数，你可以随时执行它来停止这个 watcher 对数据的侦听，而对于 watch 选项创建的侦听器，它会随着组件的销毁而停止对数据的侦听。 在 Vue.js 3.0 中，虽然你仍可以使用 watch 选项，但针对 Composition API，Vue.js 3.0 提供了 watch API 来实现侦听器的效果。 那么，接下来就随我一起来学习 watch API 吧。 watch API 的用法我们先来看 Vue.js 3.0 中 watch API 有哪些用法。 watch API 可以侦听一个 getter 函数，但是它必须返回一个响应式对象，当该响应式对象更新后，会执行对应的回调函数。 12345import &#123; reactive, watch &#125; from &#x27;vue&#x27; const state = reactive(&#123; count: 0 &#125;) watch(() =&gt; state.count, (count, prevCount) =&gt; &#123; // 当 state.count 更新，会触发此回调函数 &#125;) watch API 也可以直接侦听一个响应式对象，当响应式对象更新后，会执行对应的回调函数。 12345import &#123; ref, watch &#125; from &#x27;vue&#x27; const count = ref(0) watch(count, (count, prevCount) =&gt; &#123; // 当 count.value 更新，会触发此回调函数 &#125;) watch API 还可以直接侦听多个响应式对象，任意一个响应式对象更新后，就会执行对应的回调函数。 123456import &#123; ref, watch &#125; from &#x27;vue&#x27; const count = ref(0) const count2 = ref(1) watch([count, count2], ([count, count2], [prevCount, prevCount2]) =&gt; &#123; // 当 count.value 或者 count2.value 更新，会触发此回调函数 &#125;) watch API 实现原理侦听器的言下之意就是，当侦听的对象或者函数发生了变化则自动执行某个回调函数，这和我们前面说过的副作用函数 effect 很像， 那它的内部实现是不是依赖了 effect 呢？带着这个疑问，我们来探究 watch API 的具体实现： 123456789101112131415function watch(source, cb, options) &#123; if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; !isFunction(cb)) &#123; warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` + `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` + `supports \\`watch(source, cb, options?) signature.`) &#125; return doWatch(source, cb, options) &#125; function doWatch(source, cb, &#123; immediate, deep, flush, onTrack, onTrigger &#125; = EMPTY_OBJ) &#123; // 标准化 source // 构造 applyCb 回调函数 // 创建 scheduler 时序执行函数 // 创建 effect 副作用函数 // 返回侦听器销毁函数 &#125; 从代码中可以看到，watch 函数内部调用了 doWatch 函数，调用前会在非生产环境下判断第二个参数 cb 是不是一个函数，如果不是则会报警告以告诉用户应该使用 watchEffect(fn, options) API，watchEffect API 也是侦听器相关的 API，稍后我们会详细介绍。 这个 doWatch 函数很长，所以我只贴出了需要理解的部分，我用注释将这个函数的实现逻辑拆解成了几个步骤。可以看到，内部确实创建了 effect 副作用函数。接下来，就随我一步步看它具体做了哪些事情吧。 标准化 source我们先来看watch 函数的第一个参数 source。 通过前文知道 source 可以是 getter 函数，也可以是响应式对象甚至是响应式对象数组，所以我们需要标准化 source，这是标准化 source 的流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// source 不合法的时候会报警告 const warnInvalidSource = (s) =&gt; &#123; warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` + `a reactive object, or an array of these types.`) &#125; // 当前组件实例 const instance = currentInstance let getter if (isArray(source)) &#123; getter = () =&gt; source.map(s =&gt; &#123; if (isRef(s)) &#123; return s.value &#125; else if (isReactive(s)) &#123; return traverse(s) &#125; else if (isFunction(s)) &#123; return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */) &#125; else &#123; (process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; warnInvalidSource(s) &#125; &#125;) &#125; else if (isRef(source)) &#123; getter = () =&gt; source.value &#125; else if (isReactive(source)) &#123; getter = () =&gt; source deep = true &#125; else if (isFunction(source)) &#123; if (cb) &#123; // getter with cb getter = () =&gt; callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */) &#125; else &#123; // watchEffect 的逻辑 &#125; &#125; else &#123; getter = NOOP (process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; warnInvalidSource(source) &#125; if (cb &amp;&amp; deep) &#123; const baseGetter = getter getter = () =&gt; traverse(baseGetter()) &#125; 其实，source 标准化主要是根据 source 的类型，将其变成 标准成 getter 函数。具体来说： 如果 source 是 ref 对象，则创建一个访问 source.value 的 getter 函数; 如果 source 是 reactive 对象，则创建一个访问 source 的 getter 函数，并设置 deep 为 true（deep 的作用我稍后会说）; 如果 source 是一个函数，则会进一步判断第二个参数 cb 是否存在，对于 watch API 来说，cb 是一定存在且是一个回调函数，这种情况下，getter 就是一个简单的对 source 函数封装的函数。 如果 source 不满足上述条件，则在非生产环境下报警告，提示 source 类型不合法。 我们来看一下最终标准化生成的 getter 函数，它会返回一个响应式对象，在后续创建 effect runner 副作用函数需要用到，每次执行 runner 就会把 getter 函数返回的响应式对象作为 watcher 求值的结果，effect runner 的创建流程我们后续会详细分析，这里不需要深入了解。 最后我们来关注一下 deep 为 true 的情况。此时，我们会发现生成的 getter 函数会被 traverse 函数包装一层。traverse 函数的实现很简单，即通过递归的方式访问 value 的每一个子属性。那么，为什么要递归访问每一个子属性呢？ 其实 deep 属于 watcher 的一个配置选项，Vue.js 2.x 也支持，表面含义是深度侦听，实际上是通过遍历对象的每一个子属性来实现。举个例子你就明白了： 123456789101112import &#123; reactive, watch &#125; from &#x27;vue&#x27; const state = reactive(&#123; count: &#123; a: &#123; b: 1 &#125; &#125; &#125;) watch(state.count, (count, prevCount) =&gt; &#123; console.log(count) &#125;) state.count.a.b = 2 这里，我们利用 reactive API 创建了一个嵌套层级较深的响应式对象 state，然后再调用 watch API 侦听 state.count 的变化。接下来我们修改内部属性 state.count.a.b 的值，你会发现 watcher 的回调函数执行了，为什么会执行呢？ 学过响应式章节，我们知道只有对象属性先被访问触发了依赖收集，再去修改这个属性，才可以通知对应的依赖更新。而从上述业务代码来看，我们修改 state.count.a.b 的值时并没有访问它 ，但还是触发了 watcher 的回调函数。 根本原因是，当我们执行 watch 函数的时候，我们知道如果侦听的是一个 reactive 对象，那么内部会设置 deep 为 true，然后执行 traverse 去递归访问对象深层子属性，这个时候就会访问 state.count.a.b 触发依赖收集，这里收集的依赖是 watcher 内部创建的 effect runner。因此，当我们再去修改 state.count.a.b 的时候，就会通知这个 effect ，所以最终会执行 watcher 的回调函数。 当我们侦听一个通过 reactive API 创建的响应式对象时，内部会执行 traverse 函数，如果这个对象非常复杂，比如嵌套层级很深，那么递归 traverse 就会有一定的性能耗时。因此如果我们需要侦听这个复杂响应式对象内部的某个具体属性，就可以想办法减少 traverse 带来的性能损耗。 比如刚才的例子，我们就可以直接侦听 state.count.a.b 的变化： 1234watch(state.count.a, (newVal, oldVal) =&gt; &#123; console.log(newVal) &#125;) state.count.a.b = 2 这样就可以减少内部执行 traverse 的次数。你可能会问，直接侦听 state.count.a.b 可以吗？答案是不行，因为 state.count.a.b 已经是一个基础数字类型了，不符合 source 要求的参数类型，所以会在非生产环境下报警告。 那么有没有办法优化使得 traverse 不执行呢？答案是可以的。我们可以侦听一个 getter 函数： 1234watch(() =&gt; state.count.a.b, (newVal, oldVal) =&gt; &#123; console.log(newVal) &#125;) state.count.a.b = 2 这样函数内部会访问并返回 state.count.a.b，一次 traverse 都不会执行并且依然可以侦听到它的变化从而执行 watcher 的回调函数。 构造回调函数处理完 watch API 第一个参数 source 后，接下来处理第二个参数 cb。 cb 是一个回调函数，它有三个参数：第一个 newValue 代表新值；第二个 oldValue 代表旧值。第三个参数 onInvalidate，我打算放在后面介绍。 其实这样的 API 设计非常好理解，即侦听一个值的变化，如果值变了就执行回调函数，回调函数里可以访问到新值和旧值。 接下来我们来看一下构造回调函数的处理逻辑： 12345678910111213141516171819202122232425262728293031323334ssssssslet cleanup // 注册无效回调函数 const onInvalidate = (fn) =&gt; &#123; cleanup = runner.options.onStop = () =&gt; &#123; callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */) &#125; &#125; // 旧值初始值 let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE /*&#123;&#125;*/ // 回调函数 const applyCb = cb ? () =&gt; &#123; // 组件销毁，则直接返回 if (instance &amp;&amp; instance.isUnmounted) &#123; return &#125; // 求得新值 const newValue = runner() if (deep || hasChanged(newValue, oldValue)) &#123; // 执行清理函数 if (cleanup) &#123; cleanup() &#125; callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [ newValue, // 第一次更改时传递旧值为 undefined oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate ]) // 更新旧值 oldValue = newValue &#125; &#125; : void 0 onInvalidate 函数用来注册无效回调函数 ，我们暂时不需要关注它，我们需要重点来看 applyCb。 这个函数实际上就是对 cb 做一层封装，当侦听的值发生变化时就会执行 applyCb 方法，我们来分析一下它的实现。 首先，watch API 和组件实例相关，因为通常我们会在组件的 setup 函数中使用它，当组件销毁后，回调函数 cb 不应该被执行而是直接返回。 接着，执行 runner 求得新值，这里实际上就是执行前面创建的 getter 函数求新值。 最后进行判断，如果是 deep 的情况或者新旧值发生了变化，则执行回调函数 cb，传入参数 newValue 和 oldValue。注意，第一次执行的时候旧值的初始值是空数组或者 undefined。执行完回调函数 cb 后，把旧值 oldValue 再更新为 newValue，这是为了下一次的比对。 创建 scheduler接下来我们要分析创建 scheduler 过程。 scheduler 的作用是根据某种调度的方式去执行某种函数，在 watch API 中，主要影响到的是回调函数的执行方式。我们来看一下它的实现逻辑： 12345678910111213141516171819202122const invoke = (fn) =&gt; fn() let scheduler if (flush === &#x27;sync&#x27;) &#123; // 同步 scheduler = invoke &#125; else if (flush === &#x27;pre&#x27;) &#123; scheduler = job =&gt; &#123; if (!instance || instance.isMounted) &#123; // 进入异步队列，组件更新前执行 queueJob(job) &#125; else &#123; // 如果组件还没挂载，则同步执行确保在组件挂载前 job() &#125; &#125; &#125; else &#123; // 进入异步队列，组件更新后执行 scheduler = job =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense) &#125; Watch API 的参数除了 source 和 cb，还支持第三个参数 options，不同的配置决定了 watcher 的不同行为。前面我们也分析了 deep 为 true 的情况，除了 source 为 reactive 对象时会默认把 deep 设置为 true，你也可以主动传入第三个参数，把 deep 设置为 true。 这里，scheduler 的创建逻辑受到了第三个参数 Options 中的 flush 属性值的影响，不同的 flush 决定了 watcher 的执行时机。 当 flush 为 sync 的时候，表示它是一个同步 watcher，即当数据变化时同步执行回调函数。 当 flush 为 pre 的时候，回调函数通过 queueJob 的方式在组件更新之前执行，如果组件还没挂载，则同步执行确保回调函数在组件挂载之前执行。 如果没设置 flush，那么回调函数通过 queuePostRenderEffect 的方式在组件更新之后执行。 queueJob 和 queuePostRenderEffect 在这里不是重点，所以我们放到后面介绍。总之，你现在要记住，watcher 的回调函数是通过一定的调度方式执行的。 创建 effect前面的分析我们提到了 runner，它其实就是 watcher 内部创建的 effect 函数，接下来，我们来分析它逻辑： 12345678910111213141516171819202122232425const runner = effect(getter, &#123; // 延时执行 lazy: true, // computed effect 可以优先于普通的 effect 先运行，比如组件渲染的 effect computed: true, onTrack, onTrigger, scheduler: applyCb ? () =&gt; scheduler(applyCb) : scheduler &#125;) // 在组件实例中记录这个 effect recordInstanceBoundEffect(runner) // 初次执行 if (applyCb) &#123; if (immediate) &#123; applyCb() &#125; else &#123; // 求旧值 oldValue = runner() &#125; &#125; else &#123; // 没有 cb 的情况 runner() &#125; 这块代码逻辑是整个 watcher 实现的核心部分，即通过 effect API 创建一个副作用函数 runner，我们需要关注以下几点。 runner 是一个 computed effect。因为 computed effect 可以优先于普通的 effect（比如组件渲染的 effect）先运行，这样就可以实现当配置 flush 为 pre 的时候，watcher 的执行可以优先于组件更新。 runner 执行的方式。runner 是 lazy 的，它不会在创建后立刻执行。第一次手动执行 runner 会执行前面的 getter 函数，访问响应式数据并做依赖收集。注意，此时activeEffect 就是 runner，这样在后面更新响应式数据时，就可以触发 runner 执行 scheduler 函数，以一种调度方式来执行回调函数。 runner 的返回结果。手动执行 runner 就相当于执行了前面标准化的 getter 函数，getter 函数的返回值就是 watcher 计算出的值，所以我们第一次执行 runner 求得的值可以作为 oldValue。 配置了 immediate 的情况。当我们配置了 immediate ，创建完 watcher 会立刻执行 applyCb 函数，此时 oldValue 还是初始值，在 applyCb 执行时也会执行 runner 进而执行前面的 getter 函数做依赖收集，求得新值。 返回销毁函数 最后，会返回侦听器销毁函数，也就是 watch API 执行后返回的函数。我们可以通过调用它来停止 watcher 对数据的侦听。 12345678910111213141516return () =&gt; &#123; stop(runner) if (instance) &#123; // 移除组件 effects 对这个 runner 的引用 remove(instance.effects, runner) &#125; &#125; function stop(effect) &#123; if (effect.active) &#123; cleanup(effect) if (effect.options.onStop) &#123; effect.options.onStop() &#125; effect.active = false &#125; &#125; 销毁函数内部会执行 stop 方法让 runner 失活，并清理 runner 的相关依赖，这样就可以停止对数据的侦听。并且，如果是在组件中注册的 watcher，也会移除组件 effects 对这个 runner 的引用。 好了，到这里我们对 watch API 的分析就可以告一段落了。侦听器的内部设计很巧妙，我们可以侦听响应式数据的变化，内部创建 effect runner，首次执行 runner 做依赖收集，然后在数据发生变化后，以某种调度方式去执行回调函数。 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-core&#x2F;src&#x2F;apiWatch.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"watch","slug":"watch","permalink":"https://xiaozhouguo.github.io/tags/watch/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"计算属性：相比普通函数好在哪里？","slug":"vue3/computed","date":"2022-07-04T07:17:47.000Z","updated":"2022-07-04T07:54:50.380Z","comments":true,"path":"2022/07/04/vue3/computed/","link":"","permalink":"https://xiaozhouguo.github.io/2022/07/04/vue3/computed/","excerpt":"上一篇文章，我们学习了响应式的实现原理，这次我们将学习一个非常常用的响应式 API——计算属性。","text":"上一篇文章，我们学习了响应式的实现原理，这次我们将学习一个非常常用的响应式 API——计算属性。 计算属性是 Vue.js 开发中一个非常实用的 API ，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。当依赖发生变化时，计算属性可以自动重新计算获取新值，所以使用起来非常方便。 在 Vue.js 2.x 中，相信你对计算属性的应用已经如数家珍了，我们可以在组件对象中定义 computed 属性。到了 Vue.js 3.0 ，虽然也可以在组件中沿用 Vue.js 2.x 的使用方式，但是我们也可以单独使用计算属性 API。 计算属性本质上还是对依赖的计算，那么为什么我们不直接用函数呢？在 Vue.js 3.0 中计算属性的 API 又是如何实现呢？接下来，就请你带着这些疑问，随我一起深入其实现原理的学习吧。 计算属性 API： computedVue.js 3.0 提供了一个 computed 函数作为计算属性 API，我们先来看看它是如何使用的。 我们举个简单的例子： 123456const count = ref(1) const plusOne = computed(() =&gt; count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // error count.value++ console.log(plusOne.value) // 3 从代码中可以看到，我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne，它的值是 count.value + 1，当我们修改 count.value 的时候， plusOne.value 就会自动发生变化。 注意，这里我们直接修改 plusOne.value 会报一个错误，这是因为如果我们传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。 在 getter 函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个响应式对象，就是计算属性的依赖。 当然，有时候我们也希望能够直接修改 computed 的返回值，那么我们可以给 computed 传入一个对象： 123456789const count = ref(1) const plusOne = computed(&#123; get: () =&gt; count.value + 1, set: val =&gt; &#123; count.value = val - 1 &#125; &#125;) plusOne.value = 1 console.log(count.value) // 0 在这个例子中，结合上述代码可以看到，我们给 computed 函数传入了一个拥有 getter 函数和 setter 函数的对象，getter 函数和之前一样，还是返回 count.value + 1；而 setter 函数，请注意，这里我们修改 plusOne.value 的值就会触发 setter 函数，其实 setter 函数内部实际上会根据传入的参数修改计算属性的依赖值 count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍 getter，所以这样获取的值也就发生了变化。 好了，我们现在已经知道了 computed API 的两种使用方式了，接下来就看看它是怎样实现的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function computed(getterOrOptions) &#123; // getter 函数 let getter // setter 函数 let setter // 标准化参数 if (isFunction(getterOrOptions)) &#123; // 表面传入的是 getter 函数，不能修改计算属性的值 getter = getterOrOptions setter = (process.env.NODE_ENV !== &#x27;production&#x27;) ? () =&gt; &#123; console.warn(&#x27;Write operation failed: computed value is readonly&#x27;) &#125; : NOOP &#125; else &#123; getter = getterOrOptions.get setter = getterOrOptions.set &#125; // 数据是否脏的 let dirty = true // 计算结果 let value let computed // 创建副作用函数 const runner = effect(getter, &#123; // 延时执行 lazy: true, // 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 computed: true, // 调度执行的实现 scheduler: () =&gt; &#123; if (!dirty) &#123; dirty = true // 派发通知，通知运行访问该计算属性的 activeEffect trigger(computed, &quot;set&quot; /* SET */, &#x27;value&#x27;) &#125; &#125; &#125;) // 创建 computed 对象 computed = &#123; __v_isRef: true, // 暴露 effect 对象以便计算属性可以停止计算 effect: runner, get value() &#123; // 计算属性的 getter if (dirty) &#123; // 只有数据为脏的时候才会重新计算 value = runner() dirty = false &#125; // 依赖收集，收集运行访问该计算属性的 activeEffect track(computed, &quot;get&quot; /* GET */, &#x27;value&#x27;) return value &#125;, set value(newValue) &#123; // 计算属性的 setter setter(newValue) &#125; &#125; return computed &#125; 从代码中可以看到，computed 函数的流程主要做了三件事情：标准化参数，创建副作用函数和创建 computed 对象。我们来详细分析一下这几个步骤。 首先是标准化参数。computed 函数接受两种类型的参数，一个是 getter 函数，一个是拥有 getter 和 setter 函数的对象，通过判断参数的类型，我们初始化了函数内部定义的 getter 和 setter 函数。 接着是创建副作用函数 runner。computed 内部通过 effect 创建了一个副作用函数，它是对 getter 函数做的一层封装，另外我们这里要注意第二个参数，也就是 effect 函数的配置对象。其中 lazy 为 true 表示 effect 函数返回的 runner 并不会立即执行；computed 为 true 用于表示这是一个 computed effect，用于 trigger 阶段的优先级排序，我们稍后会分析；scheduler 表示它的调度运行的方式，我们也稍后分析。 最后是创建 computed 对象并返回，这个对象也拥有 getter 和 setter 函数。当 computed 对象被访问的时候会触发 getter，然后会判断是否 dirty，如果是就执行 runner，然后做依赖收集；当我们直接设置 computed 对象时会触发 setter，即执行 computed 函数内部定义的 setter 函数。 计算属性的运行机制computed 函数的逻辑会有一点绕，不过不要紧，我们可以结合一个应用 computed 计算属性的例子，来理解整个计算属性的运行机制。分析之前我们需要记住 computed 内部两个重要的变量，第一个 dirty 表示一个计算属性的值是否是“脏的”，用来判断需不需要重新计算，第二个 value 表示计算属性每次计算后的结果。 现在，我们来看这个示例： 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &#123;&#123; plusOne &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;plus&quot;&gt;plus&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import &#123; ref, computed &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const count = ref(0) const plusOne = computed(() =&gt; &#123; return count.value + 1 &#125;) const plus = ()=&gt; &#123; count.value++ &#125; return &#123; plusOne, plus &#125; &#125; &#125;&lt;/script&gt; 可以看到，在这个例子中我们利用 computed API 创建了计算属性对象 plusOne，它传入的是一个 getter 函数，为了和后面计算属性对象的 getter 函数区分，我们把它称作 computed getter。另外，组件模板中引用了 plusOne 变量和 plus 函数。 组件渲染阶段会访问 plusOne，也就触发了 plusOne 对象的 getter 函数： 1234567891011get value() &#123; // 计算属性的 getter if (dirty) &#123; // 只有数据为脏的时候才会重新计算 value = runner() dirty = false &#125; // 依赖收集，收集运行访问该计算属性的 activeEffect track(computed, &quot;get&quot; /* GET */, &#x27;value&#x27;) return value &#125; 由于默认 dirty 是 true，所以这个时候会执行 runner 函数，并进一步执行 computed getter，也就是 count.value + 1，因为访问了 count 的值，并且由于 count 也是一个响应式对象，所以就会触发 count 对象的依赖收集过程。 请注意，由于是在 runner 执行的时候访问 count，所以这个时候的 activeEffect 是 runner 函数。runner 函数执行完毕，会把 dirty 设置为 false，并进一步执行 track（computed,”get”,’value’) 函数做依赖收集，这个时候 runner 已经执行完了，所以 activeEffect 是组件副作用渲染函数。 然后当我们点击按钮的时候，会执行 plus 函数，函数内部通过 count.value++ 修改 count 的值，并派发通知。请注意，这里不是直接调用 runner 函数，而是把 runner 作为参数去执行 scheduler 函数。我们来回顾一下 trigger 函数内部对于 effect 函数的执行方式: 12345678910const run = (effect) =&gt; &#123; // 调度执行 if (effect.options.scheduler) &#123; effect.options.scheduler(effect) &#125; else &#123; // 直接运行 effect() &#125; &#125; computed API 内部创建副作用函数时，已经配置了 scheduler 函数，如下： 1234567scheduler: () =&gt; &#123; if (!dirty) &#123; dirty = true // 派发通知，通知运行访问该计算属性的 activeEffect trigger(computed, &quot;set&quot; /* SET */, &#x27;value&#x27;) &#125; &#125; 它并没有对计算属性求新值，而仅仅是把 dirty 设置为 true，再执行 trigger(computed, “set” , ‘value’)，去通知执行 plusOne 依赖的组件渲染副作用函数，即触发组件的重新渲染。 在组件重新渲染的时候，会再次访问 plusOne，我们发现这个时候 dirty 为 true，然后会再次执行 computed getter，此时才会执行 count.value + 1 求得新值。这就是虽然组件没有直接访问 count，但是当我们修改 count 的值的时候，组件仍然会重新渲染的原因。 为了更加直观展示上述过程，我画了一张图： 通过以上分析，我们可以看出 computed 计算属性有两个特点： 延时计算，只有当我们访问计算属性的时候，它才会真正运行 computed getter 函数计算； 缓存，它的内部会缓存上次的计算结果 value，而且只有 dirty 为 true 时才会重新计算。如果访问计算属性时 dirty 为 false，那么直接返回这个 value。 现在，我们就可以回答开头提的问题了。和单纯使用普通函数相比，计算属性的优势是：只要依赖不变化，就可以使用缓存的 value 而不用每次在渲染组件的时候都执行函数去计算，这是典型的空间换时间的优化思想。 嵌套计算属性计算属性也支持嵌套，我们可以针对上述例子做个小修改，即不在渲染函数中访问 plusOne，而在另一个计算属性中访问： 12345678const count = ref(0) const plusOne = computed(() =&gt; &#123; return count.value + 1 &#125;) const plusTwo = computed(() =&gt; &#123; return plusOne.value + 1 &#125;) console.log(plusTwo.value) 从代码中可以看到，当我们访问 plusTwo 的时候，过程和前面都差不多，同样也是两个依赖收集的过程。对于 plusOne 来说，它收集的依赖是 plusTwo 内部的 runner 函数；对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。 接着当我们修改 count 的值时，它会派发通知，先运行 plusOne 内部的 scheduler 函数，把 plusOne 内部的 dirty 变为 true，然后执行 trigger 函数再次派发通知，接着运行 plusTwo 内部的 scheduler 函数，把 plusTwo 内部的 dirty 设置为 true。 然后当我们再次访问 plusTwo 的值时，发现 dirty 为 true，就会执行 plusTwo 的 computed getter 函数去执行 plusOne.value + 1，进而执行 plusOne 的 computed gette 即 count.value + 1 + 1，求得最终新值 2。 得益于 computed 这种巧妙的设计，无论嵌套多少层计算属性都可以正常工作。 计算属性的执行顺序我们曾提到计算属性内部创建副作用函数的时候会配置 computed 为 true，标识这是一个 computed effect，用于在 trigger 阶段的优先级排序。我们来回顾一下 trigger 函数执行 effects 的过程： 123456789101112131415161718192021222324const add = (effectsToAdd) =&gt; &#123; if (effectsToAdd) &#123; effectsToAdd.forEach(effect =&gt; &#123; if (effect !== activeEffect || !shouldTrack) &#123; if (effect.options.computed) &#123; computedRunners.add(effect) &#125; else &#123; effects.add(effect) &#125; &#125; &#125;) &#125; &#125; const run = (effect) =&gt; &#123; if (effect.options.scheduler) &#123; effect.options.scheduler(effect) &#125; else &#123; effect() &#125; &#125; computedRunners.forEach(run) effects.forEach(run) 在上一节课分析 trigger 函数的时候，为了方便你理解主干逻辑，我省略了 computedRunners 的分支逻辑。实际上，在添加待运行的 effects 的时候，我们会判断每一个 effect 是不是一个 computed effect，如果是的话会添加到 computedRunners 中，在后面运行的时候会优先执行 computedRunners，然后再执行普通的 effects。 那么为什么要这么设计呢？其实是考虑到了一些特殊场景，我们通过一个示例来说明： 12345678910111213import &#123; ref, computed &#125; from &#x27;vue&#x27; import &#123; effect &#125; from &#x27;@vue/reactivity&#x27; const count = ref(0) const plusOne = computed(() =&gt; &#123; return count.value + 1 &#125;) effect(() =&gt; &#123; console.log(plusOne.value + count.value) &#125;) function plus() &#123; count.value++ &#125; plus() 这个示例运行后的结果输出： 1231 3 3 在执行 effect 函数时运行 console.log(plusOne.value + count.value)，所以第一次输出 1，此时 count.value 是 0，plusOne.value 是 1。 后面连续输出两次 3 是因为， plusOne 和 count 的依赖都是这个 effect 函数，所以当我们执行 plus 函数修改 count 的值时，会触发并执行这个 effect 函数，因为 plusOne 的 runner 也是 count 的依赖，count 值修改也会执行 plusOne 的 runner，也就会再次执行 plusOne 的依赖即 effect 函数，因此会输出两次。 那么为什么两次都输出 3 呢？这就跟先执行 computed runner 有关。首先，由于 plusOne 的 runner 和 effect 都是 count 的依赖，当我们修改 count 值的时候， plusOne 的 runner 和 effect 都会执行，那么此时执行顺序就很重要了。 这里先执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value。这个时候，由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了新值 2， 再加上 1 就得到 3。执行完 plusOne 的 runner 以及依赖更新之后，再去执行 count 的普通effect 依赖，从而去执行 plusOne.value + count.value，这个时候 plusOne dirty 为 false， 直接返回上次的计算结果 2，然后再加 1 就又得到 3。 如果我们把 computed runner 和 effect 的执行顺序换一下会怎样呢？我来告诉你，会输出如下结果： 1231 2 3 第一次输出 1 很好理解，因为流程是一样的。第二次为什么会输出 2 呢？我们来分析一下，当我们执行 plus 函数修改 count 的值时，会触发 plusOne 的 runner 和 effect 的执行，这一次我们先让 effect 执行 plusOne.value + count.value，那么就会访问 plusOne.value，但由于 plusOne 的 runner 还没执行，所以此时 dirty 为 false，得到的值还是上一次的计算结果 1，然后再加 1 得到 2。 接着再执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value，这个时候由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了 2，然后再加上 1 就得到 3。 知道原因后，我们再回过头看例子。因为 effect 函数依赖了 plusOne 和 count，所以 plusOne 先计算会更合理，这就是为什么我们需要让 computed runner 的执行优先于普通的 effect 函数。 总结好的，到这里我们这一节的学习就结束啦，我希望通过学习，你能理解计算属性的工作机制，能搞明白计算属性嵌套场景代码的执行顺序，知道计算属性的两个特点——延时计算和缓存，也希望你能够在组件的开发中合理使用计算属性。 本节课的相关代码在源代码中的位置如下：packages&#x2F;reactivity&#x2F;src&#x2F;computed.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"computed","slug":"computed","permalink":"https://xiaozhouguo.github.io/tags/computed/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"响应式内部的实现原理是怎样的 - 上篇","slug":"vue3/reactive-inner","date":"2022-07-01T02:13:28.000Z","updated":"2022-07-04T09:10:15.128Z","comments":true,"path":"2022/07/01/vue3/reactive-inner/","link":"","permalink":"https://xiaozhouguo.github.io/2022/07/01/vue3/reactive-inner/","excerpt":"上一节课我们学习了 Composition API 的核心 setup 函数的实现，在 setup 函数中，我们多次使用一些 API 让数据变成响应式，那么这节课我们就来深入学习响应式内部的实现原理。","text":"上一节课我们学习了 Composition API 的核心 setup 函数的实现，在 setup 函数中，我们多次使用一些 API 让数据变成响应式，那么这节课我们就来深入学习响应式内部的实现原理。 除了组件化，Vue.js 另一个核心设计思想就是响应式。它的本质是当数据变化后会自动执行某个函数，映射到组件的实现就是，当数据变化后，会自动触发组件的重新渲染。响应式是 Vue.js 组件化更新渲染的一个核心机制。 在介绍 Vue.js 3.0 响应式实现之前，我们先来回顾一下 Vue.js 2.x 响应式实现的部分： 它在内部通过 Object.defineProperty API 劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新。我们用一张图可以直观地看清这个流程。 在 Vue.js 2.x 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。注意这里有两个流程，首先是依赖收集流程，组件在 render 的时候会访问模板中的数据，触发 getter 把 render watcher 作为依赖收集，并和数据建立联系；然后是派发通知流程，当我对这些数据修改的时候，会触发 setter，通知 render watcher 更新，进而触发了组件的重新渲染。 我们知道 Object.defineProperty API 的一些缺点：不能监听对象属性新增和删除；初始化阶段递归执行 Object.defineProperty 带来的性能负担。 Vue.js 3.0 为了解决 Object.defineProperty 的这些缺陷，使用 Proxy API 重写了响应式部分，并独立维护和发布整个 reactivity 库，下面我们就一起来深入学习 Vue.js 3.0 响应式部分的实现原理。 响应式对象的实现差异在 Vue.js 2.x 中构建组件时，只要我们在 data、props、computed 中定义数据，那么它就是响应式的，举个例子： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;random&quot;&gt;Random msg&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: &#x27;msg reactive&#x27; &#125; &#125;, methods: &#123; random() &#123; this.msg = Math.random() &#125; &#125; &#125;&lt;/script&gt; 上述组件初次渲染会显示“msg reactive”，当我们点击按钮的时候，会执行 random 函数，random 函数会修改 this.msg，就会发现组件重新渲染了。 我们对这个例子做一些改动，模板部分不变，我们把 msg 数据的定义放到created 钩子中： 12345678910export default &#123; created() &#123; this.msg = &#x27;msg not reactive&#x27; &#125;, methods: &#123; random() &#123; this.msg = Math.random() &#125; &#125;&#125; 此时，组件初次渲染显示“msg not reactive”，但是我们再次点击按钮就会发现组件并没有重新渲染。 这个问题相信你可能遇到过，其中的根本原因是我们在 created 中定义的 this.msg 并不是响应式对象，所以 Vue.js 内部不会对它做额外的处理。而 data 中定义的数据，Vue.js 内部在组件初始化的过程中会把它变成响应式，这是一个相对黑盒的过程，用户通常不会感知到。 你可能会好奇，为什么我在 created 钩子函数中定义数据而不在 data 中去定义？其实在 data 中定义数据最终也是挂载到组件实例 this 上，这和我直接在 created 钩子函数通过 this.xxx 定义的数据唯一区别就是，在 data 中定义的数据是响应式的。 在一些场景下，如果我们仅仅想在组件上下文中共享某个变量，而不必去监测它的这个数据变化，这时就特别适合在 created 钩子函数中去定义这个变量，因为创建响应式的过程是有性能代价的，这相当于一种 Vue.js 应用的性能优化小技巧，你掌握了这一点就可以在合适的场景中应用了。 到了 Vue.js 3.0 构建组件时，你可以不依赖于 Options API，而使用 Composition API 去编写。对于刚才的例子，我们可以用 Composition API 这样改写： 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; state.msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;random&quot;&gt;Random msg&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; reactive &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const state = reactive(&#123; msg: &#x27;msg reactive&#x27; &#125;) const random =()=&gt; &#123; state.msg = Math.random() &#125; return &#123; state, random &#125; &#125; &#125;&lt;/script&gt; 可以看到，我们通过 setup 函数实现和前面示例同样的功能。请注意，这里我们引入了 reactive API，它可以把一个对象数据变成响应式。 可以看出来 Composition API 更推荐用户主动定义响应式对象，而非内部的黑盒处理。这样用户可以更加明确哪些数据是响应式的，如果你不想让数据变成响应式，就定义成它的原始数据类型即可。 Reactive API我们先来看一下 reactive 函数的具体实现过程： 12345678910111213141516171819202122232425262728293031323334function reactive (target) &#123; // 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy if (target &amp;&amp; target.__v_isReadonly) &#123; return target &#125; return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers)&#125;function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) &#123; if (!isObject(target)) &#123; // 目标必须是对象或数组类型 if ((process.env.NODE_ENV !== &#x27;production&#x27;)) &#123; console.warn(`value cannot be made reactive: $&#123;String(target)&#125;`) &#125; return target &#125; if (target.__v_raw &amp;&amp; !(isReadonly &amp;&amp; target.__v_isReactive)) &#123; // target 已经是 Proxy 对象，直接返回 // 有个例外，如果是 readonly 作用于一个响应式对象，则继续 return target &#125; if (hasOwn(target, isReadonly ? &quot;__v_readonly&quot; /* readonly */ : &quot;__v_reactive&quot; /* reactive */)) &#123; // target 已经有对应的 Proxy 了 return isReadonly ? target.__v_readonly : target.__v_reactive &#125; // 只有在白名单里的数据类型才能变成响应式 if (!canObserve(target)) &#123; return target &#125; // 利用 Proxy 创建响应式 const observed = new Proxy(target, collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers) // 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了 def(target, isReadonly ? &quot;__v_readonly&quot; /* readonly */ : &quot;__v_reactive&quot; /* reactive */, observed) return observed&#125; 可以看到，reactive 内部通过 createReactiveObject 函数把 target 变成了一个响应式对象。 在这个过程中，createReactiveObject 函数主要做了以下几件事情。 函数首先判断 target 是不是数组或者对象类型，如果不是则直接返回。所以原始数据 target 必须是对象或者数组。 如果对一个已经是响应式的对象再次执行 reactive，还应该返回这个响应式对象，举个例子： 12345import &#123; reactive &#125; from &#x27;vue&#x27;const original = &#123; foo: 1 &#125;const observed = reactive(original)const observed2 = reactive(observed)observed === observed2 // true 可以看到 observed 已经是响应式结果了，如果对它再去执行 reactive，返回的值 observed2 和 observed 还是同一个对象引用。 因为这里 reactive 函数会通过 target.__v_raw 属性来判断 target 是否已经是一个响应式对象（因为响应式对象的 __v_raw 属性会指向它自身，后面会提到），如果是的话则直接返回响应式对象。 ​ 如果对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象，举个例子： 12345import &#123; reactive &#125; from &#x27;vue&#x27;const original = &#123; foo: 1 &#125;const observed = reactive(original)const observed2 = reactive(original)observed === observed2 // true 使用 canObserve 函数对 target 对象做一进步限制： 123456const canObserve = (value) =&gt; &#123; return (!value.__v_skip &amp;&amp; isObservableType(toRawType(value)) &amp;&amp; !Object.isFrozen(value))&#125;const isObservableType = /*#__PURE__*/ makeMap(&#x27;Object,Array,Map,Set,WeakMap,WeakSet&#x27;) 比如，带有 __v_skip 属性的对象、被冻结的对象，以及不在白名单内的对象如 Date 类型的对象实例是不能变成响应式的。 通过 Proxy API 劫持 target 对象，把它变成响应式。我们把 Proxy 函数返回的结果称作响应式对象，这里 Proxy 对应的处理器对象会根据数据类型的不同而不同，我们稍后会重点分析基本数据类型的 Proxy 处理器对象，reactive 函数传入的 baseHandlers 值是 mutableHandlers。 给原始数据打个标识，如下： 1target.__v_reactive = observed 这就是前面“对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象”逻辑的判断依据。 仔细想想看，响应式的实现方式无非就是劫持数据，Vue.js 3.0 的 reactive API 就是通过 Proxy 劫持数据，而且由于 Proxy 劫持的是整个对象，所以我们可以检测到任何对对象的修改，弥补了 Object.defineProperty API 的不足。 接下来，我们继续看 Proxy 处理器对象 mutableHandlers 的实现： 1234567const mutableHandlers = &#123; get, set, deleteProperty, has, ownKeys&#125; 它其实就是劫持了我们对 observed 对象的一些操作，比如： 访问对象属性会触发 get 函数； 设置对象属性会触发 set 函数； 删除对象属性会触发 deleteProperty 函数； in 操作符会触发 has 函数； 通过 Object.getOwnPropertyNames 访问对象属性名会触发 ownKeys 函数。 因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的 get 和 set 函数就可以了。 依赖收集：get 函数依赖收集发生在数据访问的阶段，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性被访问的时候就会执行 get 函数，我们来看一下 get 函数的实现，其实它是执行 createGetter 函数的返回值，为了分析主要流程，这里省略了 get 函数中的一些分支逻辑，isReadonly 也默认为 false： 123456789101112131415161718192021222324252627282930313233343536function createGetter(isReadonly = false) &#123; return function get(target, key, receiver) &#123; if (key === &quot;__v_isReactive&quot; /* isReactive */) &#123; // 代理 observed.__v_isReactive return !isReadonly &#125; else if (key === &quot;__v_isReadonly&quot; /* isReadonly */) &#123; // 代理 observed.__v_isReadonly return isReadonly; &#125; else if (key === &quot;__v_raw&quot; /* raw */) &#123; // 代理 observed.__v_raw return target &#125; const targetIsArray = isArray(target) // arrayInstrumentations 包含对数组一些方法修改的函数 if (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123; return Reflect.get(arrayInstrumentations, key, receiver) &#125; // 求值 const res = Reflect.get(target, key, receiver) // 内置 Symbol key 不需要依赖收集 if (isSymbol(key) &amp;&amp; builtInSymbols.has(key) || key === &#x27;__proto__&#x27;) &#123; return res &#125; // 依赖收集 !isReadonly &amp;&amp; track(target, &quot;get&quot; /* GET */, key) return isObject(res) ? isReadonly ? readonly(res) // 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式 : reactive(res) : res &#125;&#125; 结合上述代码来看，get 函数主要做了四件事情，首先对特殊的 key 做了代理，这就是为什么我们在 createReactiveObject 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。 接着通过 Reflect.get 方法求值，如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数，我们可以大概看一下 arrayInstrumentations 的实现： 1234567891011121314151617181920const arrayInstrumentations = &#123;&#125;[&#x27;includes&#x27;, &#x27;indexOf&#x27;, &#x27;lastIndexOf&#x27;].forEach(key =&gt; &#123; arrayInstrumentations[key] = function (...args) &#123; // toRaw 可以把响应式对象转成原始数据 const arr = toRaw(this) for (let i = 0, l = this.length; i &lt; l; i++) &#123; // 依赖收集 track(arr, &quot;get&quot; /* GET */, i + &#x27;&#x27;) &#125; // 先尝试用参数本身，可能是响应式数据 const res = arr[key](...args) if (res === -1 || res === false) &#123; // 如果失败，再尝试把参数转成原始数据 return arr[key](...args.map(toRaw)) &#125; else &#123; return res &#125; &#125;&#125;) 也就是说，当 target 是一个数组的时候，我们去访问 target.includes、target.indexOf 或者 target.lastIndexOf 就会执行 arrayInstrumentations 代理的函数，除了调用数组本身的方法求值外，还对数组每个元素做了依赖收集。因为一旦数组的元素被修改，数组的这几个 API 的返回结果都可能发生变化，所以我们需要跟踪数组每个元素的变化。 回到 get 函数，第三步就是通过 Reflect.get 求值，然后会执行 track 函数收集依赖，我们稍后重点分析这个过程。 函数最后会对计算的值 res 进行判断，如果它也是数组或对象，则递归执行 reactive 把 res 变成响应式对象。这么做是因为 Proxy 劫持的是对象本身，并不能劫持子对象的变化，这点和 Object.defineProperty API 一致。但是 Object.defineProperty 是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而 Proxy 是在对象属性被访问的时候才递归执行下一步 reactive，这其实是一种延时定义子对象响应式的实现，在性能上会有较大的提升。 整个 get 函数最核心的部分其实是执行 track 函数收集依赖，下面我们重点分析这个过程。 我们先来看一下 track 函数的实现： 123456789101112131415161718192021222324252627// 是否应该收集依赖let shouldTrack = true// 当前激活的 effectlet activeEffect// 原始数据对象 mapconst targetMap = new WeakMap()function track(target, type, key) &#123; if (!shouldTrack || activeEffect === undefined) &#123; return &#125; let depsMap = targetMap.get(target) if (!depsMap) &#123; // 每个 target 对应一个 depsMap targetMap.set(target, (depsMap = new Map())) &#125; let dep = depsMap.get(key) if (!dep) &#123; // 每个 key 对应一个 dep 集合 depsMap.set(key, (dep = new Set())) &#125; if (!dep.has(activeEffect)) &#123; // 收集当前激活的 effect 作为依赖 dep.add(activeEffect) // 当前激活的 effect 收集 dep 集合作为依赖 activeEffect.deps.push(dep) &#125;&#125; 分析这个函数的实现前，我们先想一下要收集的依赖是什么，我们的目的是实现响应式，就是当数据变化的时候可以自动做一些事情，比如执行某些函数，所以我们收集的依赖就是数据变化后执行的副作用函数。 再来看实现，我们把 target 作为原始的数据，key 作为访问的属性。我们创建了全局的 targetMap 作为原始数据对象的 Map，它的键是 target，值是 depsMap，作为依赖的 Map；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数。为了方便理解，可以通过下图表示它们之间的关系： 所以每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。 了解完依赖收集的过程，下节课我们来分析派发通知的过程。 本节课的相关代码在源代码中的位置如下：packages&#x2F;reactivity&#x2F;src&#x2F;baseHandlers.tspackages&#x2F;reactivity&#x2F;src&#x2F;effect.tspackages&#x2F;reactivity&#x2F;src&#x2F;reactive.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"reactive","slug":"reactive","permalink":"https://xiaozhouguo.github.io/tags/reactive/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"setup：组件渲染前的初始化过程是怎样的？","slug":"vue3/setup","date":"2022-06-29T02:23:30.000Z","updated":"2022-07-26T07:31:47.110Z","comments":true,"path":"2022/06/29/vue3/setup/","link":"","permalink":"https://xiaozhouguo.github.io/2022/06/29/vue3/setup/","excerpt":"Vue.js 3.0 允许我们在编写组件的时候添加一个 setup 启动函数，它是 Composition API 逻辑组织的入口，我们这就来分析一下这个函数。","text":"Vue.js 3.0 允许我们在编写组件的时候添加一个 setup 启动函数，它是 Composition API 逻辑组织的入口，我们这就来分析一下这个函数。 我们先通过一段代码认识它，在这里编写一个 button 组件： 1234567891011121314151617181920212223&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt; Count is: &#123;&#123; state.count &#125;&#125;, double is: &#123;&#123; state.double &#125;&#125; &lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, computed &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const state = reactive(&#123; count: 0, double: computed(() =&gt; state.count * 2) &#125;) function increment() &#123; state.count++ &#125; return &#123; state, increment &#125; &#125;&#125;&lt;/script&gt; 可以看到，这段代码和 Vue.js 2.x 组件的写法相比，多了一个 setup 启动函数，另外组件中也没有定义 props、data、computed 这些 options。 在 setup 函数内部，定义了一个响应式对象 state，它是通过 reactive API 创建的。state 对象有 count 和 double 两个属性，其中 count 对应一个数字属性的值；而double 通过 computed API 创建，对应一个计算属性的值。reactive API 和 computed API 不是我们关注的重点，在后续响应式章节我会详细介绍。 这里需要注意的是，模板中引用到的变量 state 和 increment 包含在 setup 函数的返回对象中，那么它们是如何建立联系的呢？ 我们先来回想一下 Vue.js 2.x 编写组件的时候，会在 props、data、methods、computed 等 options 中定义一些变量。在组件初始化阶段，Vue.js 内部会处理这些 options，即把定义的变量添加到了组件实例上。等模板编译成 render 函数的时候，内部通过 with(this){} 的语法去访问在组件实例中的变量。 那么到了 Vue.js 3.0，既支持组件定义 setup 函数，而且在模板 render 的时候，又可以访问到 setup 函数返回的值，这是如何实现的？我们来一探究竟。 创建和设置组件实例首先，我们来回顾一下组件的渲染流程：创建 vnode 、渲染 vnode 和生成 DOM。 其中渲染 vnode 的过程主要就是在挂载组件： 123456789const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; // 创建组件实例 const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense)) // 设置组件实例 setupComponent(instance) // 设置并运行带副作用的渲染函数 setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)&#125; 可以看到，这段挂载组件的代码主要做了三件事情：创建组件实例、设置组件实例和设置并运行带副作用的渲染函数。前两个流程就跟我们今天提到的问题息息相关，所以这一节课我们将重点分析它们。 创建组件实例我们要关注 createComponentInstance 方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105function createComponentInstance (vnode, parent, suspense) &#123; // 继承父组件实例上的 appContext，如果是根组件，则直接从根 vnode 中取。 const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext; const instance = &#123; // 组件唯一 id uid: uid++, // 组件 vnode vnode, // 父组件实例 parent, // app 上下文 appContext, // vnode 节点类型 type: vnode.type, // 根组件实例 root: null, // 新的组件 vnode next: null, // 子节点 vnode subTree: null, // 带副作用更新函数 update: null, // 渲染函数 render: null, // 渲染上下文代理 proxy: null, // 带有 with 区块的渲染上下文代理 withProxy: null, // 响应式相关对象 effects: null, // 依赖注入相关 provides: parent ? parent.provides : Object.create(appContext.provides), // 渲染代理的属性访问缓存 accessCache: null, // 渲染缓存 renderCache: [], // 渲染上下文 ctx: EMPTY_OBJ, // data 数据 data: EMPTY_OBJ, // props 数据 props: EMPTY_OBJ, // 普通属性 attrs: EMPTY_OBJ, // 插槽相关 slots: EMPTY_OBJ, // 组件或者 DOM 的 ref 引用 refs: EMPTY_OBJ, // setup 函数返回的响应式结果 setupState: EMPTY_OBJ, // setup 函数上下文数据 setupContext: null, // 注册的组件 components: Object.create(appContext.components), // 注册的指令 directives: Object.create(appContext.directives), // suspense 相关 suspense, // suspense 异步依赖 asyncDep: null, // suspense 异步依赖是否都已处理 asyncResolved: false, // 是否挂载 isMounted: false, // 是否卸载 isUnmounted: false, // 是否激活 isDeactivated: false, // 生命周期，before create bc: null, // 生命周期，created c: null, // 生命周期，before mount bm: null, // 生命周期，mounted m: null, // 生命周期，before update bu: null, // 生命周期，updated u: null, // 生命周期，unmounted um: null, // 生命周期，before unmount bum: null, // 生命周期, deactivated da: null, // 生命周期 activated a: null, // 生命周期 render triggered rtg: null, // 生命周期 render tracked rtc: null, // 生命周期 error captured ec: null, // 派发事件方法 emit: null &#125; // 初始化渲染上下文 instance.ctx = &#123; _: instance &#125; // 初始化根组件指针 instance.root = parent ? parent.root : instance // 初始化派发事件方法 instance.emit = emit.bind(null, instance) return instance&#125; 从上述代码中可以看到，组件实例 instance 上定义了很多属性，你千万不要被这茫茫多的属性吓到，因为其中一些属性是为了实现某个场景或者某个功能所定义的，你只需要通过我在代码中的注释大概知道它们是做什么的即可。 Vue.js 2.x 使用 new Vue 来初始化一个组件的实例，到了 Vue.js 3.0，我们直接通过创建对象去创建组件的实例。这两种方式并无本质的区别，都是引用一个对象，在整个组件的生命周期中去维护组件的状态数据和上下文环境。 创建好 instance 实例后，接下来就是设置它的一些属性。目前已完成了组件的上下文、根组件指针以及派发事件方法的设置。我们在后面会继续分析更多 instance 实例属性的设置逻辑。 设置组件实例接着是组件实例的设置流程，对 setup 函数的处理就在这里完成，我们来看一下 setupComponent 方法的实现： 1234567891011121314function setupComponent (instance, isSSR = false) &#123; const &#123; props, children, shapeFlag &#125; = instance.vnode // 判断是否是一个有状态的组件 const isStateful = shapeFlag &amp; 4 // 初始化 props initProps(instance, props, isStateful, isSSR) // 初始化 插槽 initSlots(instance, children) // 设置有状态的组件实例 const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined return setupResult&#125; 可以看到，我们从组件 vnode 中获取了 props、children、shapeFlag 等属性，然后分别对 props 和插槽进行初始化，这两部分逻辑在后续的章节再详细分析。根据 shapeFlag 的值，我们可以判断这是不是一个有状态组件，如果是则要进一步去设置有状态组件的实例。 接下来我们要关注到 setupStatefulComponent 函数，它主要做了三件事：创建渲染上下文代理、判断处理 setup 函数和完成组件实例设置。它代码如下所示： 12345678910111213141516171819202122function setupStatefulComponent (instance, isSSR) &#123; const Component = instance.type // 创建渲染代理的属性访问缓存 instance.accessCache = &#123;&#125; // 创建渲染上下文代理 instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers) // 判断处理 setup 函数 const &#123; setup &#125; = Component if (setup) &#123; // 如果 setup 函数带参数，则创建一个 setupContext const setupContext = (instance.setupContext = setup.length &gt; 1 ? createSetupContext(instance) : null) // 执行 setup 函数，获取结果 const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext]) // 处理 setup 执行结果 handleSetupResult(instance, setupResult) &#125; else &#123; // 完成组件实例设置 finishComponentSetup(instance) &#125;&#125; 创建渲染上下文代理首先是创建渲染上下文代理的流程，它主要对 instance.ctx 做了代理。在分析实现前，我们需要思考一个问题，这里为什么需要代理呢？ 其实在 Vue.js 2.x 中，也有类似的数据代理逻辑，比如 props 求值后的数据，实际上存储在 this._props 上，而 data 中定义的数据存储在 this._data上。举个例子： 12345678910&lt;template&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; msg: 1 &#125;&#125;&lt;/script&gt; 在初始化组件的时候，data 中定义的 msg 在组件内部是存储在 this._data 上的，而模板渲染的时候访问 this.msg，实际上访问的是 this._data.msg，这是因为 Vue.js 2.x 在初始化 data 的时候，做了一层 proxy 代理。 到了 Vue.js 3.0，为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到 setupState、ctx、data、props 中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 instance.ctx 中的属性，所以我们也要做一层 proxy，对渲染上下文 instance.ctx 属性的访问和修改，代理到对 setupState、ctx、data、props 中的数据的访问和修改。 明确了代理的需求后，我们接下来就要分析 proxy 的几个方法： get、set 和 has。 当我们访问 instance.ctx 渲染上下文中的属性时，就会进入 get 函数。我们来看一下它的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const PublicInstanceProxyHandlers = &#123; get (&#123; _: instance &#125;, key) &#123; const &#123; ctx, setupState, data, props, accessCache, type, appContext &#125; = instance if (key[0] !== &#x27;$&#x27;) &#123; // setupState / data / props / ctx // 渲染代理的属性访问缓存中 const n = accessCache[key] if (n !== undefined) &#123; // 从缓存中取 switch (n) &#123; case 0: /* SETUP */ return setupState[key] case 1 :/* DATA */ return data[key] case 3 :/* CONTEXT */ return ctx[key] case 2: /* PROPS */ return props[key] &#125; &#125; else if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123; accessCache[key] = 0 // 从 setupState 中取数据 return setupState[key] &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; accessCache[key] = 1 // 从 data 中取数据 return data[key] &#125; else if ( type.props &amp;&amp; hasOwn(normalizePropsOptions(type.props)[0], key)) &#123; accessCache[key] = 2 // 从 props 中取数据 return props[key] &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; accessCache[key] = 3 // 从 ctx 中取数据 return ctx[key] &#125; else &#123; // 都取不到 accessCache[key] = 4 &#125; &#125; const publicGetter = publicPropertiesMap[key] let cssModule, globalProperties // 公开的 $xxx 属性或方法 if (publicGetter) &#123; return publicGetter(instance) &#125; else if ( // css 模块，通过 vue-loader 编译的时候注入 (cssModule = type.__cssModules) &amp;&amp; (cssModule = cssModule[key])) &#123; return cssModule &#125; else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123; // 用户自定义的属性，也用 `$` 开头 accessCache[key] = 3 return ctx[key] &#125; else if ( // 全局定义的属性 ((globalProperties = appContext.config.globalProperties), hasOwn(globalProperties, key))) &#123; return globalProperties[key] &#125; else if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; currentRenderingInstance &amp;&amp; key.indexOf(&#x27;__v&#x27;) !== 0) &#123; if (data !== EMPTY_OBJ &amp;&amp; key[0] === &#x27;$&#x27; &amp;&amp; hasOwn(data, key)) &#123; // 如果在 data 中定义的数据以 $ 开头，会报警告，因为 $ 是保留字符，不会做代理 warn(`Property $&#123;JSON.stringify(key)&#125; must be accessed via $data because it starts with a reserved ` + `character and is not proxied on the render context.`) &#125; else &#123; // 在模板中使用的变量如果没有定义，报警告 warn(`Property $&#123;JSON.stringify(key)&#125; was accessed during render ` + `but is not defined on instance.`) &#125; &#125; &#125;&#125; 可以看到，函数首先判断 key 不以 $ 开头的情况，这部分数据可能是 setupState、data、props、ctx 中的一种，其中 data、props 我们已经很熟悉了；setupState 就是 setup 函数返回的数据，稍后我们会详细说；ctx 包括了计算属性、组件方法和用户自定义的一些数据。 如果 key 不以 $ 开头，那么就依次判断 setupState、data、props、ctx 中是否包含这个 key，如果包含就返回对应值。注意这个判断顺序很重要，在 key 相同时它会决定数据获取的优先级，举个例子： 12345678910111213141516171819&lt;template&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref &#125; from &#x27;vue&#x27; export default &#123; data() &#123; return &#123; msg: &#x27;msg from data&#x27; &#125; &#125;, setup() &#123; const msg = ref(&#x27;msg from setup&#x27;) return &#123; msg &#125; &#125; &#125;&lt;/script&gt; 我们在 data 和 setup 中都定义了 msg 变量，但最终输出到界面上的是”msg from setup”，这是因为 setupState 的判断优先级要高于 data。 再回到 get 函数中，我们可以看到这里定义了 accessCache 作为渲染代理的属性访问缓存，它具体是干什么的呢？组件在渲染时会经常访问数据进而触发 get 函数，这其中最昂贵的部分就是多次调用 hasOwn 去判断 key 在不在某个类型的数据中，但是在普通对象上执行简单的属性访问相对要快得多。所以在第一次获取 key 对应的数据后，我们利用 accessCache[key] 去缓存数据，下一次再次根据 key 查找数据，我们就可以直接通过 accessCache[key] 获取对应的值，就不需要依次调用 hasOwn 去判断了。这也是一个性能优化的小技巧。 如果 key 以 $ 开头，那么接下来又会有一系列的判断，首先判断是不是 Vue.js 内部公开的 $xxx 属性或方法（比如 $parent）；然后判断是不是 vue-loader 编译注入的 css 模块内部的 key；接着判断是不是用户自定义以 $ 开头的 key；最后判断是不是全局属性。如果都不满足，就剩两种情况了，即在非生产环境下就会报两种类型的警告，第一种是在 data 中定义的数据以 $ 开头的警告，因为 $ 是保留字符，不会做代理；第二种是在模板中使用的变量没有定义的警告。 接下来是 set 代理过程，当我们修改 instance.ctx 渲染上下文中的属性的时候，就会进入 set 函数。我们来看一下 set 函数的实现： 12345678910111213141516171819202122232425262728293031const PublicInstanceProxyHandlers = &#123; set (&#123; _: instance &#125;, key, value) &#123; const &#123; data, setupState, ctx &#125; = instance if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123; // 给 setupState 赋值 setupState[key] = value &#125; else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123; // 给 data 赋值 data[key] = value &#125; else if (key in instance.props) &#123; // 不能直接给 props 赋值 (process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; warn(`Attempting to mutate prop &quot;$&#123;key&#125;&quot;. Props are readonly.`, instance) return false &#125; if (key[0] === &#x27;$&#x27; &amp;&amp; key.slice(1) in instance) &#123; // 不能给 Vue 内部以 $ 开头的保留属性赋值 (process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; warn(`Attempting to mutate public property &quot;$&#123;key&#125;&quot;. ` + `Properties starting with $ are reserved and readonly.`, instance) return false &#125; else &#123; // 用户自定义数据赋值 ctx[key] = value &#125; return true &#125;&#125; 结合代码来看，函数主要做的事情就是对渲染上下文 instance.ctx 中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和 get 一样，优先判断 setupState，然后是 data，接着是 props。 我们对之前的例子做点修改，添加一个方法： 12345678910111213141516171819202122232425&lt;template&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;random&quot;&gt;Random msg&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref &#125; from &#x27;vue&#x27; export default &#123; data() &#123; return &#123; msg: &#x27;msg from data&#x27; &#125; &#125;, setup() &#123; const msg = ref(&#x27;msg from setup&#x27;) return &#123; msg &#125; &#125;, methods: &#123; random() &#123; this.msg = Math.random() &#125; &#125; &#125;&lt;/script&gt; 我们点击按钮会执行 random 函数，这里的 this 指向的就是 instance.ctx，我们修改 this.msg 会触发 set 函数，所以最终修改的是 setupState 中的 msg 对应的值。 注意，如果我们直接对 props 中的数据赋值，在非生产环境中会收到一条警告，这是因为直接修改 props 不符合数据单向流动的设计思想；如果对 Vue.js 内部以 $ 开头的保留属性赋值，同样也会收到一条警告。 如果是用户自定义的数据，比如在 created 生命周期内定义的数据，它仅用于组件上下文的共享，如下所示： 12345export default &#123; created() &#123; this.userMsg = &#x27;msg from user&#x27; &#125;&#125; 当执行 this.userMsg 赋值的时候，会触发 set 函数，最终 userMsg 会被保留到 ctx 中。 最后是 has 代理过程，当我们判断属性是否存在于 instance.ctx 渲染上下文中时，就会进入 has 函数，这个在平时项目中用的比较少，同样来举个例子，当执行 created 钩子函数中的 ‘msg’ in this 时，就会触发 has 函数。 12345export default &#123; created () &#123; console.log(&#x27;msg&#x27; in this) &#125;&#125; 下面我们来看一下 has 函数的实现： 12345678910111213const PublicInstanceProxyHandlers = &#123; has (&#123; _: &#123; data, setupState, accessCache, ctx, type, appContext &#125; &#125;, key) &#123; // 依次判断 return (accessCache[key] !== undefined || (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) || (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) || (type.props &amp;&amp; hasOwn(normalizePropsOptions(type.props)[0], key)) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key)) &#125;&#125; 这个函数的实现很简单，依次判断 key 是否存在于 accessCache、data、setupState、props 、用户数据、公开属性以及全局属性中，然后返回结果。 至此，我们就搞清楚了创建上下文代理的过程，让我们回到 setupStatefulComponent 函数中，接下来分析第二个流程——判断处理 setup 函数。 判断处理 setup 函数1234567891011// 判断处理 setup 函数const &#123; setup &#125; = Componentif (setup) &#123; // 如果 setup 函数带参数，则创建一个 setupContext const setupContext = (instance.setupContext = setup.length &gt; 1 ? createSetupContext(instance) : null) // 执行 setup 函数获取结果 const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext]) // 处理 setup 执行结果 handleSetupResult(instance, setupResult)&#125; 如果我们在组件中定义了 setup 函数，接下来就是处理 setup 函数的流程，主要是三个步骤：创建 setup 函数上下文、执行 setup 函数并获取结果和处理 setup 函数的执行结果。接下来我们就逐个来分析。 首先判断 setup 函数的参数长度，如果大于 1，则创建 setupContext 上下文。 12const setupContext = (instance.setupContext = setup.length &gt; 1 ? createSetupContext(instance) : null) 举个例子，我们有个 HelloWorld 子组件，如下： 12345678910111213141516171819&lt;template&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;onClick&quot;&gt;Toggle&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; msg: String &#125;, setup (props, &#123; emit &#125;) &#123; function onClick () &#123; emit(&#x27;toggle&#x27;) &#125; return &#123; onClick &#125; &#125; &#125;&lt;/script&gt; 我们在父组件引用这个组件： 1234567891011121314151617181920&lt;template&gt; &lt;HelloWorld @toggle=&quot;toggle&quot; :msg=&quot;msg&quot;&gt;&lt;/HelloWorld&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref &#125; from &#x27;vue&#x27; import HelloWorld from &quot;./components/HelloWorld&quot;; export default &#123; components: &#123; HelloWorld &#125;, setup () &#123; const msg = ref(&#x27;Hello World&#x27;) function toggle () &#123; msg.value = msg.value === &#x27;Hello World&#x27; ? &#x27;Hello Vue&#x27; : &#x27;Hello World&#x27; &#125; return &#123; toggle, msg &#125; &#125; &#125;&lt;/script&gt; 可以看到，HelloWorld 子组件的 setup 函数接收两个参数，第一个参数 props 对应父组件传入的 props 数据，第二个参数是一个对象，实际上就是 setupContext。 下面我们来看一下用 createSetupContext 函数来创建 setupContext： 1234567function createSetupContext (instance) &#123; return &#123; attrs: instance.attrs, slots: instance.slots, emit: instance.emit &#125;&#125; 这里返回了一个对象，包括 attrs、slots 和 emit 三个属性。setupContext 让我们在 setup 函数内部可以获取到组件的属性、插槽以及派发事件的方法 emit。 可以预见的是，这个 setupContext 对应的就是 setup 函数第二个参数，我们接下来看一下 setup 函数具体是如何执行的。 我们通过下面这行代码来执行 setup 函数并获取结果： 1const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext]) 我们具体来看一下 callWithErrorHandling 函数的实现： 12345678910function callWithErrorHandling (fn, instance, type, args) &#123; let res try &#123; res = args ? fn(...args) : fn() &#125; catch (err) &#123; handleError(err, instance, type) &#125; return res&#125; 可以看到，它其实就是对 fn 做的一层包装，内部还是执行了 fn，并在有参数的时候传入参数，所以 setup 的第一个参数是 instance.props，第二个参数是 setupContext。函数执行过程中如果有 JavaScript 执行错误就会捕获错误，并执行 handleError 函数来处理。 执行 setup 函数并拿到了返回的结果，那么接下来就要用 handleSetupResult 函数来处理结果。 1handleSetupResult(instance, setupResult) 我们详细看一下 handleSetupResult 函数的实现： 1234567891011function handleSetupResult(instance, setupResult) &#123; if (isFunction(setupResult)) &#123; // setup 返回渲染函数 instance.render = setupResult &#125; else if (isObject(setupResult)) &#123; // 把 setup 返回结果变成响应式 instance.setupState = reactive(setupResult) &#125; finishComponentSetup(instance)&#125; 可以看到，当 setupResult 是一个对象的时候，我们把它变成了响应式并赋值给 instance.setupState，这样在模板渲染的时候，依据前面的代理规则，instance.ctx 就可以从 instance.setupState 上获取到对应的数据，这就在 setup 函数与模板渲染间建立了联系。 另外 setup 不仅仅支持返回一个对象，也可以返回一个函数作为组件的渲染函数。我们可以改写前面的示例，来看一下这时的情况： 12345678910111213141516171819&lt;script&gt; import &#123; h &#125; from &#x27;vue&#x27; export default &#123; props: &#123; msg: String &#125;, setup (props, &#123; emit &#125;) &#123; function onClick () &#123; emit(&#x27;toggle&#x27;) &#125; return (ctx) =&gt; &#123; return [ h(&#x27;p&#x27;, null, ctx.msg), h(&#x27;button&#x27;, &#123; onClick: onClick &#125;, &#x27;Toggle&#x27;) ] &#125; &#125; &#125;&lt;/script&gt; 这里，我们删除了 HelloWorld 子组件的 template 部分，并把 setup 函数的返回结果改成了函数，也就是说它会作为组件的渲染函数，一切运行正常。 在 handleSetupResult 的最后，会执行 finishComponentSetup 函数完成组件实例的设置，其实这个函数和 setup 函数的执行结果已经没什么关系了，提取到外面放在 handleSetupResult 函数后面执行更合理一些。 另外当组件没有定义的 setup 的时候，也会执行 finishComponentSetup 函数去完成组件实例的设置。 完成组件实例设置1234567891011121314151617181920212223242526272829303132333435363738function finishComponentSetup (instance) &#123; const Component = instance.type // 对模板或者渲染函数的标准化 if (!instance.render) &#123; if (compile &amp;&amp; Component.template &amp;&amp; !Component.render) &#123; // 运行时编译 Component.render = compile(Component.template, &#123; isCustomElement: instance.appContext.config.isCustomElement || NO &#125;) Component.render._rc = true &#125; if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; !Component.render) &#123; if (!compile &amp;&amp; Component.template) &#123; // 只编写了 template 但使用了 runtime-only 的版本 warn(`Component provided template option but ` + `runtime compilation is not supported in this build of Vue.` + (` Configure your bundler to alias &quot;vue&quot; to &quot;vue/dist/vue.esm-bundler.js&quot;.` ) /* should not happen */) &#125; else &#123; // 既没有写 render 函数，也没有写 template 模板 warn(`Component is missing template or render function.`) &#125; &#125; // 组件对象的 render 函数赋值给 instance instance.render = (Component.render || NOOP) if (instance.render._rc) &#123; // 对于使用 with 块的运行时编译的渲染函数，使用新的渲染上下文的代理 instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers) &#125; &#125; // 兼容 Vue.js 2.x Options API &#123; currentInstance = instance applyOptions(instance, Component) currentInstance = null &#125;&#125; 函数主要做了两件事情：标准化模板或者渲染函数和兼容 Options API。接下来我们详细分析这两个流程。 标准化模板或者渲染函数在分析这个过程之前，我们需要了解一些背景知识。组件最终通过运行 render 函数生成子树 vnode，但是我们很少直接去编写 render 函数，通常会使用两种方式开发组件。 第一种是使用 SFC（Single File Components）单文件的开发方式来开发组件，即通过编写组件的 template 模板去描述一个组件的 DOM 结构。我们知道 .vue 类型的文件无法在 Web 端直接加载，因此在 webpack 的编译阶段，它会通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分转换成 render 函数添加到组件对象的属性中。 另外一种开发方式是不借助 webpack 编译，直接引入 Vue.js，开箱即用，我们直接在组件对象 template 属性中编写组件的模板，然后在运行阶段编译生成 render 函数，这种方式通常用于有一定历史包袱的古老项目。 因此 Vue.js 在 Web 端有两个版本：runtime-only 和 runtime-compiled。我们更推荐用 runtime-only 版本的 Vue.js，因为相对而言它体积更小，而且在运行时不用编译，不仅耗时更少而且性能更优秀。遇到一些不得已的情况比如上述提到的古老项目，我们也可以选择 runtime-compiled 版本。 runtime-only 和 runtime-compiled 的主要区别在于是否注册了这个 compile 方法。 在 Vue.js 3.0 中，compile 方法是通过外部注册的： 1234let compile;function registerRuntimeCompiler(_compile) &#123; compile = _compile;&#125; 回到标准化模板或者渲染函数逻辑，我们先看 instance.render 是否存在，如果不存在则开始标准化流程，这里主要需要处理以下三种情况。 compile 和组件 template 属性存在，render 方法不存在的情况。此时， runtime-compiled 版本会在 JavaScript 运行时进行模板编译，生成 render 函数。 compile 和 render 方法不存在，组件 template 属性存在的情况。此时由于没有 compile，这里用的是 runtime-only 的版本，因此要报一个警告来告诉用户，想要运行时编译得使用 runtime-compiled 版本的 Vue.js。 组件既没有写 render 函数，也没有写 template 模板，此时要报一个警告，告诉用户组件缺少了 render 函数或者 template 模板。 处理完以上情况后，就要把组件的 render 函数赋值给 instance.render。到了组件渲染的时候，就可以运行 instance.render 函数生成组件的子树 vnode 了。 另外对于使用 with 块运行时编译的渲染函数，渲染上下文的代理是 RuntimeCompiledPublicInstanceProxyHandlers，它是在之前渲染上下文代理 PublicInstanceProxyHandlers 的基础上进行的扩展，主要对 has 函数的实现做了优化： 1234567891011121314151617const RuntimeCompiledPublicInstanceProxyHandlers = &#123; ...PublicInstanceProxyHandlers, get(target, key) &#123; if (key === Symbol.unscopables) &#123; return &#125; return PublicInstanceProxyHandlers.get(target, key, target) &#125;, has(_, key) &#123; // 如果 key 以 _ 开头或者 key 在全局变量白名单内，则 has 为 false const has = key[0] !== &#x27;_&#x27; &amp;&amp; !isGloballyWhitelisted(key) if ((process.env.NODE_ENV !== &#x27;production&#x27;) &amp;&amp; !has &amp;&amp; PublicInstanceProxyHandlers.has(_, key)) &#123; warn(`Property $&#123;JSON.stringify(key)&#125; should not start with _ which is a reserved prefix for Vue internals.`) &#125; return has &#125;&#125; 这里如果 key 以 _ 开头，或者 key 在全局变量的白名单内，则 has 为 false，此时则直接命中警告，不用再进行之前那一系列的判断了。 了解完标准化模板或者渲染函数流程，我们来看完成组件实例设置的最后一个流程——兼容 Vue.js 2.x 的 Options API。 Options API：兼容 Vue.js 2.x我们知道 Vue.js 2.x 是通过组件对象的方式去描述一个组件，之前我们也说过，Vue.js 3.0 仍然支持 Vue.js 2.x Options API 的写法，这主要就是通过 applyOptions方法实现的。 12345678910111213141516171819202122232425262728function applyOptions(instance, options, deferredData = [], deferredWatch = [], asMixin = false) &#123; const &#123; // 组合 mixins, extends: extendsOptions, // 数组状态 props: propsOptions, data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, // 组件和指令 components, directives, // 生命周期 beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured &#125; = options; // instance.proxy 作为 this const publicThis = instance.proxy; const ctx = instance.ctx; // 处理全局 mixin // 处理 extend // 处理本地 mixins // props 已经在外面处理过了 // 处理 inject // 处理 methods // 处理 data // 处理 computed // 处理 watch // 处理 provide // 处理组件 // 处理指令 // 处理生命周期 option&#125; 由于 applyOptions 的代码特别长，所以这里我用注释列出了它主要做的事情，感兴趣的同学可以去翻阅它的源码。 总结这节课我们主要分析了组件的初始化流程，主要包括创建组件实例和设置组件实例。通过进一步细节的深入，我们也了解了渲染上下文的代理过程；了解了 Composition API 中的 setup 启动函数执行的时机，以及如何建立 setup 返回结果和模板渲染之间的联系；了解了组件定义的模板或者渲染函数的标准化过程；了解了如何兼容 Vue.js 2.x 的 Options API。 我们通过一张图再直观感受一下 Vue.js 3.0 组件的初始化流程： 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.tspackages&#x2F;runtime-core&#x2F;src&#x2F;component.tspackages&#x2F;runtime-core&#x2F;src&#x2F;componentProxy.tspackages&#x2F;runtime-core&#x2F;src&#x2F;errorHandling.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"setup","slug":"setup","permalink":"https://xiaozhouguo.github.io/tags/setup/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"完整的 DOM diff 流程下篇","slug":"vue3/dom-diff-process2","date":"2022-06-28T02:08:41.000Z","updated":"2022-07-26T07:46:43.984Z","comments":true,"path":"2022/06/28/vue3/dom-diff-process2/","link":"","permalink":"https://xiaozhouguo.github.io/2022/06/28/vue3/dom-diff-process2/","excerpt":"下面我们来继续讲解上节课提到的核心 diff 算法。","text":"下面我们来继续讲解上节课提到的核心 diff 算法。 新子节点数组相对于旧子节点数组的变化，无非是通过更新、删除、添加和移动节点来完成，而核心 diff 算法，就是在已知旧子节点的 DOM 结构、vnode 和新子节点的 vnode 情况下，以较低的成本完成子节点的更新为目的，求解生成新子节点 DOM 的系列操作。 为了方便你理解，我先举个例子，假设有这样一个列表： 123456&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt;&lt;/ul&gt; 然后我们在中间插入一行，得到一个新列表： 1234567&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt;&lt;/ul&gt; 在插入操作的前后，它们对应渲染生成的 vnode 可以用一张图表示： 从图中我们可以直观地感受到，差异主要在新子节点中的 b 节点后面多了一个 e 节点。 我们再把这个例子稍微修改一下，多添加一个 e 节点： 1234567&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt;&lt;/ul&gt; 然后我们删除中间一项，得到一个新列表： 123456&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt;&lt;/ul&gt; 在删除操作的前后，它们对应渲染生成的 vnode 可以用一张图表示： 我们可以看到，这时差异主要在新子节点中的 b 节点后面少了一个 c 节点。 综合这两个例子，我们很容易发现新旧 children 拥有相同的头尾节点。对于相同的节点，我们只需要做对比更新即可，所以 diff 算法的第一步从头部开始同步。 同步头部节点我们先来看一下头部节点同步的实现代码： 123456789101112131415161718192021222324const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let i = 0 const l2 = c2.length // 旧子节点的尾部索引 let e1 = c1.length - 1 // 新子节点的尾部索引 let e2 = l2 - 1 // 1. 从头部开始同步 // i = 0, e1 = 3, e2 = 4 // (a b) c d // (a b) e c d while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123; const n1 = c1[i] const n2 = c2[i] if (isSameVNodeType(n1, n2)) &#123; // 相同的节点，递归执行 patch 更新节点 patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else &#123; break &#125; i++ &#125;&#125; 在整个 diff 的过程，我们需要维护几个变量：头部的索引 i、旧子节点的尾部索引 e1和新子节点的尾部索引 e2。 同步头部节点就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。 我们拿第一个例子来说，通过下图看一下同步头部节点后的结果： 可以看到，完成头部节点同步后：i 是 2，e1 是 3，e2 是 4。 同步尾部节点接着从尾部开始同步尾部节点，实现代码如下： 12345678910111213141516171819202122232425262728const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let i = 0 const l2 = c2.length // 旧子节点的尾部索引 let e1 = c1.length - 1 // 新子节点的尾部索引 let e2 = l2 - 1 // 1. 从头部开始同步 // i = 0, e1 = 3, e2 = 4 // (a b) c d // (a b) e c d // 2. 从尾部开始同步 // i = 2, e1 = 3, e2 = 4 // (a b) (c d) // (a b) e (c d) while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123; const n1 = c1[e1] const n2 = c2[e2] if (isSameVNodeType(n1, n2)) &#123; patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else &#123; break &#125; e1-- e2-- &#125;&#125; 同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点；如果不同或者索引 i 大于索引 e1 或者 e2，则同步过程结束。 我们来通过下图看一下同步尾部节点后的结果： 可以看到，完成尾部节点同步后：i 是 2，e1 是 1，e2 是 2。 接下来只有 3 种情况要处理： 新子节点有剩余要添加的新节点； 旧子节点有剩余要删除的多余节点； 未知子序列。 我们继续看一下具体是怎样操作的。 添加新的节点首先要判断新子节点是否有剩余的情况，如果满足则添加新子节点，实现代码如下： 12345678910111213141516171819202122232425262728293031const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let i = 0 const l2 = c2.length // 旧子节点的尾部索引 let e1 = c1.length - 1 // 新子节点的尾部索引 let e2 = l2 - 1 // 1. 从头部开始同步 // i = 0, e1 = 3, e2 = 4 // (a b) c d // (a b) e c d // ... // 2. 从尾部开始同步 // i = 2, e1 = 3, e2 = 4 // (a b) (c d) // (a b) e (c d) // ... // 3. 挂载剩余的新节点 // i = 2, e1 = 1, e2 = 2 if (i &gt; e1) &#123; if (i &lt;= e2) &#123; const nextPos = e2 + 1 const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor while (i &lt;= e2) &#123; // 挂载新节点 patch(null, c2[i], container, anchor, parentComponent, parentSuspense, isSVG) i++ &#125; &#125; &#125;&#125; 如果索引 i 大于尾部索引 e1 且 i 小于 e2，那么从索引 i 开始到索引 e2 之间，我们直接挂载新子树这部分的节点。 对我们的例子而言，同步完尾部节点后 i 是 2，e1 是 1，e2 是 2，此时满足条件需要添加新的节点，我们来通过下图看一下添加后的结果： 添加完 e 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。 删除多余节点如果不满足添加新节点的情况，我就要接着判断旧子节点是否有剩余，如果满足则删除旧子节点，实现代码如下： 1234567891011121314151617181920212223242526272829303132const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let i = 0 const l2 = c2.length // 旧子节点的尾部索引 let e1 = c1.length - 1 // 新子节点的尾部索引 let e2 = l2 - 1 // 1. 从头部开始同步 // i = 0, e1 = 4, e2 = 3 // (a b) c d e // (a b) d e // ... // 2. 从尾部开始同步 // i = 2, e1 = 4, e2 = 3 // (a b) c (d e) // (a b) (d e) // ... // 3. 普通序列挂载剩余的新节点 // i = 2, e1 = 2, e2 = 1 // 不满足 if (i &gt; e1) &#123; &#125; // 4. 普通序列删除多余的旧节点 // i = 2, e1 = 2, e2 = 1 else if (i &gt; e2) &#123; while (i &lt;= e1) &#123; // 删除节点 unmount(c1[i], parentComponent, parentSuspense, true) i++ &#125; &#125;&#125; 如果索引 i 大于尾部索引 e2，那么从索引 i 开始到索引 e1 之间，我们直接删除旧子树这部分的节点。 第二个例子是就删除节点的情况，我们从同步头部节点开始，用图的方式演示这一过程。 首先从头部同步节点： 此时的结果：i 是 2，e1 是 4，e2 是 3。 接着从尾部同步节点： 此时的结果：i 是 2，e1 是 2，e2 是 1，满足删除条件，因此删除子节点中的多余节点： 删除完 c 节点后，旧子节点的 DOM 和新子节点对应的 vnode 映射一致，也就完成了更新。 处理未知子序列单纯的添加和删除节点都是比较理想的情况，操作起来也很容易，但是有些时候并非这么幸运，我们会遇到比较复杂的未知子序列，这时候 diff 算法会怎么做呢？ 我们再通过例子来演示存在未知子序列的情况，假设一个按照字母表排列的列表： 12345678910&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;f&quot;&gt;f&lt;/li&gt; &lt;li key=&quot;g&quot;&gt;g&lt;/li&gt; &lt;li key=&quot;h&quot;&gt;h&lt;/li&gt;&lt;/ul&gt; 然后我们打乱之前的顺序得到一个新列表： 12345678910&lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;i&quot;&gt;i&lt;/li&gt; &lt;li key=&quot;g&quot;&gt;g&lt;/li&gt; &lt;li key=&quot;h&quot;&gt;h&lt;/li&gt;&lt;/ul&gt; 在操作前，它们对应渲染生成的 vnode 可以用一张图表示： 我们还是从同步头部节点开始，用图的方式演示这一过程。 首先从头部同步节点： 同步头部节点后的结果：i 是 2，e1 是 7，e2 是 7。 接着从尾部同步节点： 同步尾部节点后的结果：i 是 2，e1 是 5，e2 是 5。可以看到它既不满足添加新节点的条件，也不满足删除旧节点的条件。那么对于这种情况，我们应该怎么处理呢？ 结合上图可以知道，要把旧子节点的 c、d、e、f 转变成新子节点的 e、c、d、i。从直观上看，我们把 e 节点移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点即可。 其实无论多复杂的情况，最终无非都是通过更新、删除、添加、移动这些动作来操作节点，而我们要做的就是找到相对优的解。 当两个节点类型相同时，我们执行更新操作；当新子节点中没有旧子节点中的某些节点时，我们执行删除操作；当新子节点中多了旧子节点中没有的节点时，我们执行添加操作，这些操作我们在前面已经阐述清楚了。相对来说这些操作中最麻烦的就是移动，我们既要判断哪些节点需要移动也要清楚如何移动。 移动子节点那么什么时候需要移动呢，就是当子节点排列顺序发生变化的时候，举个简单的例子具体看一下： 12let prev = [1, 2, 3, 4, 5, 6]let next = [1, 3, 2, 6, 4, 5] 可以看到，从 prev 变成 next，数组里的一些元素的顺序发生了变化，我们可以把子节点类比为元素，现在问题就简化为我们如何用最少的移动使元素顺序从 prev 变化为 next 。 一种思路是在 next 中找到一个递增子序列，比如 [1, 3, 6] 、[1, 2, 4, 5]。之后对 next 数组进行倒序遍历，移动所有不在递增序列中的元素即可。 如果选择了 [1, 3, 6] 作为递增子序列，那么在倒序遍历的过程中，遇到 6、3、1 不动，遇到 5、4、2 移动即可，从prev -&gt; next 子节点移动如下图所示： 如果选择了 [1, 2, 4, 5] 作为递增子序列，那么在倒序遍历的过程中，遇到 5、4、2、1 不动，遇到 6、3 移动即可，如下图所示： 可以看到从第一种移动了三次，而第二种只移动了两次，递增子序列越长，所需要移动元素的次数越少，所以如何移动的问题就回到了求解最长递增子序列的问题。我们稍后会详细讲求解最长递增子序列的算法，所以先回到我们这里的问题，对未知子序列的处理。 我们现在要做的是在新旧子节点序列中找出相同节点并更新，找出多余的节点删除，找出新的节点添加，找出是否有需要移动的节点，如果有该如何移动。 在查找过程中需要对比新旧子序列，那么我们就要遍历某个序列，如果在遍历旧子序列的过程中需要判断某个节点是否在新子序列中存在，这就需要双重循环，而双重循环的复杂度是 O(n2) ，为了优化这个复杂度，我们可以用一种空间换时间的思路，建立索引图，把时间复杂度降低到 O(n)。 建立索引图所以处理未知子序列的第一步，就是建立索引图。 通常我们在开发过程中， 会给 v-for 生成的列表中的每一项分配唯一 key 作为项的唯一 ID，这个 key 在 diff 过程中起到很关键的作用。对于新旧子序列中的节点，我们认为 key 相同的就是同一个节点，直接执行 patch 更新即可。 我们根据 key 建立新子序列的索引图，实现如下： 1234567891011121314151617181920212223242526272829const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let i = 0 const l2 = c2.length // 旧子节点的尾部索引 let e1 = c1.length - 1 // 新子节点的尾部索引 let e2 = l2 - 1 // 1. 从头部开始同步 // i = 0, e1 = 7, e2 = 7 // (a b) c d e f g h // (a b) e c d i g h // 2. 从尾部开始同步 // i = 2, e1 = 7, e2 = 7 // (a b) c d e f (g h) // (a b) e c d i (g h) // 3. 普通序列挂载剩余的新节点， 不满足 // 4. 普通序列删除多余的旧节点，不满足 // i = 2, e1 = 5, e2 = 5 // 旧子序列开始索引，从 i 开始记录 const s1 = i // 新子序列开始索引，从 i 开始记录 const s2 = i // // 5.1 根据 key 建立新子序列的索引图 const keyToNewIndexMap = new Map() for (i = s2; i &lt;= e2; i++) &#123; const nextChild = c2[i] keyToNewIndexMap.set(nextChild.key, i) &#125;&#125; 新旧子序列是从 i 开始的，所以我们先用 s1、s2 分别作为新旧子序列的开始索引，接着建立一个 keyToNewIndexMap 的 Map&lt;key, index&gt; 结构，遍历新子序列，把节点的 key 和 index 添加到这个 Map 中，注意我们这里假设所有节点都是有 key 标识的。 keyToNewIndexMap 存储的就是新子序列中每个节点在新子序列中的索引，我们来看一下示例处理后的结果，如下图所示： 我们得到了一个值为 {e:2,c:3,d:4,i:5} 的新子序列索引图。 更新和移除旧节点接下来，我们就需要遍历旧子序列，有相同的节点就通过 patch 更新，并且移除那些不在新子序列中的节点，同时找出是否有需要移动的节点，我们来看一下这部分逻辑的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let i = 0 const l2 = c2.length // 旧子节点的尾部索引 let e1 = c1.length - 1 // 新子节点的尾部索引 let e2 = l2 - 1 // 1. 从头部开始同步 // i = 0, e1 = 7, e2 = 7 // (a b) c d e f g h // (a b) e c d i g h // 2. 从尾部开始同步 // i = 2, e1 = 7, e2 = 7 // (a b) c d e f (g h) // (a b) e c d i (g h) // 3. 普通序列挂载剩余的新节点，不满足 // 4. 普通序列删除多余的旧节点，不满足 // i = 2, e1 = 5, e2 = 5 // 旧子序列开始索引，从 i 开始记录 const s1 = i // 新子序列开始索引，从 i 开始记录 const s2 = i // 5.1 根据 key 建立新子序列的索引图 // 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点 // 新子序列已更新节点的数量 let patched = 0 // 新子序列待更新节点的数量，等于新子序列的长度 const toBePatched = e2 - s2 + 1 // 是否存在要移动的节点 let moved = false // 用于跟踪判断是否有节点移动 let maxNewIndexSoFar = 0 // 这个数组存储新子序列中的元素在旧子序列节点的索引，用于确定最长递增子序列 const newIndexToOldIndexMap = new Array(toBePatched) // 初始化数组，每个元素的值都是 0 // 0 是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明这个新节点没有对应的旧节点 for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0 // 正序遍历旧子序列 for (i = s1; i &lt;= e1; i++) &#123; // 拿到每一个旧子序列节点 const prevChild = c1[i] if (patched &gt;= toBePatched) &#123; // 所有新的子序列节点都已经更新，剩余的节点删除 unmount(prevChild, parentComponent, parentSuspense, true) continue &#125; // 查找旧子序列中的节点在新子序列中的索引 let newIndex = keyToNewIndexMap.get(prevChild.key) if (newIndex === undefined) &#123; // 找不到说明旧子序列已经不存在于新子序列中，则删除该节点 unmount(prevChild, parentComponent, parentSuspense, true) &#125; else &#123; // 更新新子序列中的元素在旧子序列中的索引，这里加 1 偏移，是为了避免 i 为 0 的特殊情况，影响对后续最长递增子序列的求解 newIndexToOldIndexMap[newIndex - s2] = i + 1 // maxNewIndexSoFar 始终存储的是上次求值的 newIndex，如果不是一直递增，则说明有移动 if (newIndex &gt;= maxNewIndexSoFar) &#123; maxNewIndexSoFar = newIndex &#125; else &#123; moved = true &#125; // 更新新旧子序列中匹配的节点 patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized) patched++ &#125; &#125;&#125; 我们建立了一个 newIndexToOldIndexMap 的数组，来存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，用于确定最长递增子序列，这个数组的长度为新子序列的长度，每个元素的初始值设为 0， 它是一个特殊的值，如果遍历完了仍有元素的值为 0，则说明遍历旧子序列的过程中没有处理过这个节点，这个节点是新添加的。 下面我们说说具体的操作过程：正序遍历旧子序列，根据前面建立的 keyToNewIndexMap 查找旧子序列中的节点在新子序列中的索引，如果找不到就说明新子序列中没有该节点，就删除它；如果找得到则将它在旧子序列中的索引更新到 newIndexToOldIndexMap 中。 注意这里索引加了长度为 1 的偏移，是为了应对 i 为 0 的特殊情况，如果不这样处理就会影响后续求解最长递增子序列。 遍历过程中，我们用变量 maxNewIndexSoFar 跟踪判断节点是否移动，maxNewIndexSoFar 始终存储的是上次求值的 newIndex，一旦本次求值的 newIndex 小于 maxNewIndexSoFar，这说明顺序遍历旧子序列的节点在新子序列中的索引并不是一直递增的，也就说明存在移动的情况。 除此之外，这个过程中我们也会更新新旧子序列中匹配的节点，另外如果所有新的子序列节点都已经更新，而对旧子序列遍历还未结束，说明剩余的节点就是多余的，删除即可。 至此，我们完成了新旧子序列节点的更新、多余旧节点的删除，并且建立了一个 newIndexToOldIndexMap 存储新子序列节点的索引和旧子序列节点的索引之间的映射关系，并确定是否有移动。 我们来看一下示例处理后的结果，如下图所示： 可以看到， c、d、e 节点被更新，f 节点被删除，newIndexToOldIndexMap 的值为 [5, 3, 4 ,0]，此时 moved 也为 true，也就是存在节点移动的情况。 移动和挂载新节点接下来，就到了处理未知子序列的最后一个流程，移动和挂载新节点，我们来看一下这部分逻辑的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let i = 0 const l2 = c2.length // 旧子节点的尾部索引 let e1 = c1.length - 1 // 新子节点的尾部索引 let e2 = l2 - 1 // 1. 从头部开始同步 // i = 0, e1 = 6, e2 = 7 // (a b) c d e f g // (a b) e c d h f g // 2. 从尾部开始同步 // i = 2, e1 = 6, e2 = 7 // (a b) c (d e) // (a b) (d e) // 3. 普通序列挂载剩余的新节点， 不满足 // 4. 普通序列删除多余的节点，不满足 // i = 2, e1 = 5, e2 = 5 // 旧子节点开始索引，从 i 开始记录 const s1 = i // 新子节点开始索引，从 i 开始记录 const s2 = i // // 5.1 根据 key 建立新子序列的索引图 // 5.2 正序遍历旧子序列，找到匹配的节点更新，删除不在新子序列中的节点，判断是否有移动节点 // 5.3 移动和挂载新节点 // 仅当节点移动时生成最长递增子序列 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR let j = increasingNewIndexSequence.length - 1 // 倒序遍历以便我们可以使用最后更新的节点作为锚点 for (i = toBePatched - 1; i &gt;= 0; i--) &#123; const nextIndex = s2 + i const nextChild = c2[nextIndex] // 锚点指向上一个更新的节点，如果 nextIndex 超过新子节点的长度，则指向 parentAnchor const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex + 1].el : parentAnchor if (newIndexToOldIndexMap[i] === 0) &#123; // 挂载新的子节点 patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG) &#125; else if (moved) &#123; // 没有最长递增子序列（reverse 的场景）或者当前的节点索引不在最长递增子序列中，需要移动 if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123; move(nextChild, container, anchor, 2) &#125; else &#123; // 倒序递增子序列 j-- &#125; &#125; &#125;&#125; 我们前面已经判断了是否移动，如果 moved 为 true 就通过 getSequence(newIndexToOldIndexMap) 计算最长递增子序列，这部分算法我会放在后文详细介绍。 接着我们采用倒序的方式遍历新子序列，因为倒序遍历可以方便我们使用最后更新的节点作为锚点。在倒序的过程中，锚点指向上一个更新的节点，然后判断 newIndexToOldIndexMap[i] 是否为 0，如果是则表示这是新节点，就需要挂载它；接着判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果在则倒序最长递增子序列，否则把它移动到锚点的前面。 为了便于你更直观地理解，我们用前面的例子展示一下这个过程，此时 toBePatched 的值为 4，j 的值为 1，最长递增子序列 increasingNewIndexSequence 的值是 [1, 2]。在倒序新子序列的过程中，首先遇到节点 i，发现它在 newIndexToOldIndexMap 中的值是 0，则说明它是新节点，我们需要挂载它；然后继续遍历遇到节点 d，因为 moved 为 true，且 d 的索引存在于最长递增子序列中，则执行 j– 倒序最长递增子序列，j 此时为 0；接着继续遍历遇到节点 c，它和 d 一样，索引也存在于最长递增子序列中，则执行 j–，j 此时为 -1；接着继续遍历遇到节点 e，此时 j 是 -1 并且 e 的索引也不在最长递增子序列中，所以做一次移动操作，把 e 节点移到上一个更新的节点，也就是 c 节点的前面。 新子序列倒序完成，即完成了新节点的插入和旧节点的移动操作，也就完成了整个核心 diff 算法对节点的更新。 我们来看一下示例处理后的结果，如下图所示： 可以看到新子序列中的新节点 i 被挂载，旧子序列中的节点 e 移动到了 c 节点前面，至此，我们就在已知旧子节点 DOM 结构和 vnode、新子节点 vnode 的情况下，求解出生成新子节点的 DOM 的更新、移动、删除、新增等系列操作，并且以一种较小成本的方式完成 DOM 更新。 我们知道了子节点更新调用的是 patch 方法， Vue.js 正是通过这种递归的方式完成了整个组件树的更新。 核心 diff 算法中最复杂就是求解最长递增子序列，下面我们再来详细学习一下这个算法。 最长递增子序列求解最长递增子序列是一道经典的算法题，多数解法是使用动态规划的思想，算法的时间复杂度是 O(n^2)，而 Vue.js 内部使用的是维基百科提供的一套“贪心 + 二分查找”的算法，贪心算法的时间复杂度是 O(n)，二分查找的时间复杂度是 O(logn)，所以它的总时间复杂度是 O(nlogn)。 单纯地看代码并不好理解，我们用示例来看一下这个子序列的求解过程。 假设我们有这个样一个数组 arr：[2, 1, 5, 3, 6, 4, 8, 9, 7]，求解它最长递增子序列的步骤如下： 最终求得最长递增子序列的值就是 [1, 3, 4, 8, 9]。 通过演示我们可以得到这个算法的主要思路：对数组遍历，依次求解长度为 i 时的最长递增子序列，当 i 元素大于 i - 1 的元素时，添加 i 元素并更新最长子序列；否则往前查找直到找到一个比 i 小的元素，然后插在该元素后面并更新对应的最长递增子序列。 这种做法的主要目的是让递增序列的差尽可能的小，从而可以获得更长的递增子序列，这便是一种贪心算法的思想。 了解了算法的大致思想后，接下来我们看一下源码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function getSequence (arr) &#123; const p = arr.slice() const result = [0] let i, j, u, v, c const len = arr.length for (i = 0; i &lt; len; i++) &#123; const arrI = arr[i] if (arrI !== 0) &#123; j = result[result.length - 1] if (arr[j] &lt; arrI) &#123; // 存储在 result 更新前的最后一个索引的值 p[i] = j result.push(i) continue &#125; u = 0 v = result.length - 1 // 二分搜索，查找比 arrI 小的节点，更新 result 的值 while (u &lt; v) &#123; c = ((u + v) / 2) | 0 if (arr[result[c]] &lt; arrI) &#123; u = c + 1 &#125; else &#123; v = c &#125; &#125; if (arrI &lt; arr[result[u]]) &#123; if (u &gt; 0) &#123; p[i] = result[u - 1] &#125; result[u] = i &#125; &#125; &#125; u = result.length v = result[u - 1] // 回溯数组 p，找到最终的索引 while (u-- &gt; 0) &#123; result[u] = v v = p[v] &#125; return result&#125; 其中 result 存储的是长度为 i 的递增子序列最小末尾值的索引。比如我们上述例子的第九步，在对数组 p 回溯之前， result 值就是 [1, 3, 4, 7, 9] ，这不是最长递增子序列，它只是存储的对应长度递增子序列的最小末尾。因此在整个遍历过程中会额外用一个数组 p，来存储在每次更新 result 前最后一个索引的值，并且它的 key 是这次要更新的 result 值： 123j = result[result.length - 1]p[i] = jresult.push(i) 可以看到，result 添加的新值 i 是作为 p 存储 result 最后一个值 j 的 key。上述例子遍历后 p 的结果如图所示： 从 result 最后一个元素 9 对应的索引 7 开始回溯，可以看到 p[7] &#x3D; 6，p[6] &#x3D; 5，p[5] &#x3D; 3，p[3] &#x3D; 1，所以通过对 p 的回溯，得到最终的 result 值是 [1, 3 ,5 ,6 ,7]，也就找到最长递增子序列的最终索引了。这里要注意，我们求解的是最长子序列索引值，它的每个元素其实对应的是数组的下标。对于我们的例子而言，[2, 1, 5, 3, 6, 4, 8, 9, 7] 的最长子序列是 [1, 3, 4, 8, 9]，而我们求解的 [1, 3 ,5 ,6 ,7] 就是最长子序列中元素在原数组中的下标所构成的新数组。 总结这两节课我们主要分析了组件的更新流程，知道了 Vue.js 的更新粒度是组件级别的，并且 Vue.js 在 patch 某个组件的时候，如果遇到组件这类抽象节点，在某些条件下也会触发子组件的更新。 对于普通元素节点的更新，主要是更新一些属性，以及它的子节点。子节点的更新又分为多种情况，其中最复杂的情况为数组到数组的更新，内部又根据不同情况分成几个流程去 diff，遇到需要移动的情况还要去求解子节点的最长递增子序列。 整个更新过程还是利用了树的深度遍历，递归执行 patch 方法，最终完成了整个组件树的更新。 下面，我们通过一张图来更加直观感受组件的更新流程： 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"DOM-diff","slug":"DOM-diff","permalink":"https://xiaozhouguo.github.io/tags/DOM-diff/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"完整的 DOM diff 流程上篇","slug":"vue3/dom-diff-process1","date":"2022-06-27T01:36:20.000Z","updated":"2022-07-26T07:40:13.337Z","comments":true,"path":"2022/06/27/vue3/dom-diff-process1/","link":"","permalink":"https://xiaozhouguo.github.io/2022/06/27/vue3/dom-diff-process1/","excerpt":"上一节课我们梳理了组件渲染的过程，本质上就是把各种类型的 vnode 渲染成真实 DOM。我们也知道了组件是由模板、组件描述对象和数据构成的，数据的变化会影响组件的变化。组件的渲染过程中创建了一个带副作用的渲染函数，当数据变化的时候就会执行这个渲染函数来触发组件的更新。那么接下来，我们就具体分析一下组件的更新过程。","text":"上一节课我们梳理了组件渲染的过程，本质上就是把各种类型的 vnode 渲染成真实 DOM。我们也知道了组件是由模板、组件描述对象和数据构成的，数据的变化会影响组件的变化。组件的渲染过程中创建了一个带副作用的渲染函数，当数据变化的时候就会执行这个渲染函数来触发组件的更新。那么接下来，我们就具体分析一下组件的更新过程。 副作用渲染函数更新组件的过程我们先来回顾一下带副作用渲染函数 setupRenderEffect 的实现，但是这次我们要重点关注更新组件部分的逻辑： 12345678910111213141516171819202122232425262728293031323334353637const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; &#123; // 创建响应式的副作用渲染函数 instance.update = effect(function componentEffect() &#123; if (!instance.isMounted) &#123; // 渲染组件 &#125; else &#123; // 更新组件 let &#123; next, vnode &#125; = instance // next 表示新的组件 vnode if (next) &#123; // 更新组件 vnode 节点信息 updateComponentPreRender(instance, next, optimized) &#125; else &#123; next = vnode &#125; // 渲染新的子树 vnode const nextTree = renderComponentRoot(instance) // 缓存旧的子树 vnode const prevTree = instance.subTree // 更新子树 vnode instance.subTree = nextTree // 组件更新核心逻辑，根据新旧子树 vnode 做 patch patch(prevTree, nextTree, // 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点 hostParentNode(prevTree.el), // 参考节点在 fragment 的情况可能改变，所以直接找旧树 DOM 元素的下一个节点 getNextHostNode(prevTree), instance, parentSuspense, isSVG) // 缓存更新后的 DOM 节点 next.el = nextTree.el &#125; &#125;, prodEffectOptions)&#125; 可以看到，更新组件主要做三件事情：更新组件 vnode 节点、渲染新的子树 vnode、根据新旧子树 vnode 执行 patch 逻辑。 首先是更新组件 vnode 节点，这里会有一个条件判断，判断组件实例中是否有新的组件 vnode（用 next 表示），有则更新组件 vnode，没有 next 指向之前的组件 vnode。为什么需要判断，这其实涉及一个组件更新策略的逻辑，我们稍后会讲。 接着是渲染新的子树 vnode，因为数据发生了变化，模板又和数据相关，所以渲染生成的子树 vnode 也会发生相应的变化。 最后就是核心的 patch 逻辑，用来找出新旧子树 vnode 的不同，并找到一种合适的方式更新 DOM，接下来我们就来分析这个过程。 核心逻辑：patch 流程我们先来看 patch 流程的实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) =&gt; &#123; // 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点 if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123; anchor = getNextHostNode(n1) unmount(n1, parentComponent, parentSuspense, true) // n1 设置为 null 保证后续都走 mount 逻辑 n1 = null &#125; const &#123; type, shapeFlag &#125; = n2 switch (type) &#123; case Text: // 处理文本节点 break case Comment: // 处理注释节点 break case Static: // 处理静态节点 break case Fragment: // 处理 Fragment 元素 break default: if (shapeFlag &amp; 1 /* ELEMENT */) &#123; // 处理普通 DOM 元素 processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else if (shapeFlag &amp; 6 /* COMPONENT */) &#123; // 处理组件 processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else if (shapeFlag &amp; 64 /* TELEPORT */) &#123; // 处理 TELEPORT &#125; else if (shapeFlag &amp; 128 /* SUSPENSE */) &#123; // 处理 SUSPENSE &#125; &#125;&#125;function isSameVNodeType (n1, n2) &#123; // n1 和 n2 节点的 type 和 key 都相同，才是相同节点 return n1.type === n2.type &amp;&amp; n1.key === n2.key&#125; 在这个过程中，首先判断新旧节点是否是相同的 vnode 类型，如果不同，比如一个 div 更新成一个 ul，那么最简单的操作就是删除旧的 div 节点，再去挂载新的 ul 节点。 如果是相同的 vnode 类型，就需要走 diff 更新流程了，接着会根据不同的 vnode 类型执行不同的处理逻辑，这里我们仍然只分析普通元素类型和组件类型的处理过程。 1. 处理组件如何处理组件的呢？举个例子，我们在父组件 App 中里引入了 Hello 组件： 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;p&gt;This is an app.&lt;/p&gt; &lt;hello :msg=&quot;msg&quot;&gt;&lt;/hello&gt; &lt;button @click=&quot;toggle&quot;&gt;Toggle msg&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: &#x27;Vue&#x27; &#125; &#125;, methods: &#123; toggle() &#123; this.msg = this.msg ==== &#x27;Vue&#x27;? &#x27;World&#x27;: &#x27;Vue&#x27; &#125; &#125; &#125;&lt;/script&gt; Hello 组件中是 &lt;div&gt; 包裹着一个 &lt;p&gt; 标签， 如下所示： 123456789101112&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;p&gt;Hello, &#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; msg: String &#125; &#125;&lt;/script&gt; 点击 App 组件中的按钮执行 toggle 函数，就会修改 data 中的 msg，并且会触发App 组件的重新渲染。 结合前面对渲染函数的流程分析，这里 App 组件的根节点是 div 标签，重新渲染的子树 vnode 节点是一个普通元素的 vnode，应该先走 processElement 逻辑。组件的更新最终还是要转换成内部真实 DOM 的更新，而实际上普通元素的处理流程才是真正做 DOM 的更新，由于稍后我们会详细分析普通元素的处理流程，所以我们先跳过这里，继续往下看。 和渲染过程类似，更新过程也是一个树的深度优先遍历过程，更新完当前节点后，就会遍历更新它的子节点，因此在遍历的过程中会遇到 hello 这个组件 vnode 节点，就会执行到 processComponent 处理逻辑中，我们再来看一下它的实现，我们重点关注一下组件更新的相关逻辑： 1234567891011121314151617181920212223242526const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; if (n1 == null) &#123; // 挂载组件 &#125; else &#123; // 更新子组件 updateComponent(n1, n2, parentComponent, optimized) &#125;&#125;const updateComponent = (n1, n2, parentComponent, optimized) =&gt; &#123; const instance = (n2.component = n1.component) // 根据新旧子组件 vnode 判断是否需要更新子组件 if (shouldUpdateComponent(n1, n2, parentComponent, optimized)) &#123; // 新的子组件 vnode 赋值给 instance.next instance.next = n2 // 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新 invalidateJob(instance.update) // 执行子组件的副作用渲染函数 instance.update() &#125; else &#123; // 不需要更新，只复制属性 n2.component = n1.component n2.el = n1.el &#125;&#125; 可以看到，processComponent 主要通过执行 updateComponent 函数来更新子组件，updateComponent 函数在更新子组件的时候，会先执行 shouldUpdateComponent 函数，根据新旧子组件 vnode 来判断是否需要更新子组件。这里你只需要知道，在 shouldUpdateComponent 函数的内部，主要是通过检测和对比组件 vnode 中的 props、chidren、dirs、transiton 等属性，来决定子组件是否需要更新。 这是很好理解的，因为在一个组件的子组件是否需要更新，我们主要依据子组件 vnode 是否存在一些会影响组件更新的属性变化进行判断，如果存在就会更新子组件。 虽然 Vue.js 的更新粒度是组件级别的，组件的数据变化只会影响当前组件的更新，但是在组件更新的过程中，也会对子组件做一定的检查，判断子组件是否也要更新，并通过某种机制避免子组件重复更新。 我们接着看 updateComponent 函数，如果 shouldUpdateComponent 返回 true ，那么在它的最后，先执行 invalidateJob（instance.update）避免子组件由于自身数据变化导致的重复更新，然后又执行了子组件的副作用渲染函数 instance.update 来主动触发子组件的更新。 再回到副作用渲染函数中，有了前面的讲解，我们再看组件更新的这部分代码，就能很好地理解它的逻辑了： 123456789101112131415161718192021222324// 更新组件let &#123; next, vnode &#125; = instance// next 表示新的组件 vnodeif (next) &#123; // 更新组件 vnode 节点信息 updateComponentPreRender(instance, next, optimized)&#125;else &#123; next = vnode&#125;const updateComponentPreRender = (instance, nextVNode, optimized) =&gt; &#123; // 新组件 vnode 的 component 属性指向组件实例 nextVNode.component = instance // 旧组件 vnode 的 props 属性 const prevProps = instance.vnode.props // 组件实例的 vnode 属性指向新的组件 vnode instance.vnode = nextVNode // 清空 next 属性，为了下一次重新渲染准备 instance.next = null // 更新 props updateProps(instance, nextVNode.props, prevProps, optimized) // 更新 插槽 updateSlots(instance, nextVNode.children)&#125; 结合上面的代码，我们在更新组件的 DOM 前，需要先更新组件 vnode 节点信息，包括更改组件实例的 vnode 指针、更新 props 和更新插槽等一系列操作，因为组件在稍后执行 renderComponentRoot 时会重新渲染新的子树 vnode ，它依赖了更新后的组件 vnode 中的 props 和 slots 等数据。 所以我们现在知道了一个组件重新渲染可能会有两种场景，一种是组件本身的数据变化，这种情况下 next 是 null；另一种是父组件在更新的过程中，遇到子组件节点，先判断子组件是否需要更新，如果需要则主动执行子组件的重新渲染方法，这种情况下 next 就是新的子组件 vnode。 你可能还会有疑问，这个子组件对应的新的组件 vnode 是什么时候创建的呢？答案很简单，它是在父组件重新渲染的过程中，通过 renderComponentRoot 渲染子树 vnode 的时候生成，因为子树 vnode 是个树形结构，通过遍历它的子节点就可以访问到其对应的组件 vnode。再拿我们前面举的例子说，当 App 组件重新渲染的时候，在执行 renderComponentRoot 生成子树 vnode 的过程中，也生成了 hello 组件对应的新的组件 vnode。 所以 processComponent 处理组件 vnode，本质上就是去判断子组件是否需要更新，如果需要则递归执行子组件的副作用渲染函数来更新，否则仅仅更新一些 vnode 的属性，并让子组件实例保留对组件 vnode 的引用，用于子组件自身数据变化引起组件重新渲染的时候，在渲染函数内部可以拿到新的组件 vnode。 前面也说过，组件是抽象的，组件的更新最终还是会落到对普通 DOM 元素的更新。所以接下来我们详细分析一下组件更新中对普通元素的处理流程。 2. 处理普通元素我们再来看如何处理普通元素，我把之前的示例稍加修改，将其中的 Hello 组件删掉，如下所示： 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;p&gt;This is &#123;&#123;msg&#125;&#125;.&lt;/p&gt; &lt;button @click=&quot;toggle&quot;&gt;Toggle msg&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: &#x27;Vue&#x27; &#125; &#125;, methods: &#123; toggle() &#123; this.msg = &#x27;Vue&#x27;? &#x27;World&#x27;: &#x27;Vue&#x27; &#125; &#125; &#125;&lt;/script&gt; 当我们点击 App 组件中的按钮会执行 toggle 函数，然后修改 data 中的 msg，这就触发了 App 组件的重新渲染。 App 组件的根节点是 div 标签，重新渲染的子树 vnode 节点是一个普通元素的 vnode，所以应该先走 processElement 逻辑，我们来看这个函数的实现： 1234567891011121314151617181920const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; isSVG = isSVG || n2.type === &#x27;svg&#x27; if (n1 == null) &#123; // 挂载元素 &#125; else &#123; // 更新元素 patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized) &#125;&#125;const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; const el = (n2.el = n1.el) const oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ const newProps = n2.props || EMPTY_OBJ // 更新 props patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG) const areChildrenSVG = isSVG &amp;&amp; n2.type !== &#x27;foreignObject&#x27; // 更新子节点 patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG)&#125; 可以看到，更新元素的过程主要做两件事情：更新 props 和更新子节点。其实这是很好理解的，因为一个 DOM 节点元素就是由它自身的一些属性和子节点构成的。 首先是更新 props，这里的 patchProps 函数就是在更新 DOM 节点的 class、style、event 以及其它的一些 DOM 属性，这个过程我不再深入分析了，感兴趣的同学可以自己看这部分代码。 其次是更新子节点，我们来看一下这里的 patchChildren 函数的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) =&gt; &#123; const c1 = n1 &amp;&amp; n1.children const prevShapeFlag = n1 ? n1.shapeFlag : 0 const c2 = n2.children const &#123; shapeFlag &#125; = n2 // 子节点有 3 种可能情况：文本、数组、空 if (shapeFlag &amp; 8 /* TEXT_CHILDREN */) &#123; if (prevShapeFlag &amp; 16 /* ARRAY_CHILDREN */) &#123; // 数组 -&gt; 文本，则删除之前的子节点 unmountChildren(c1, parentComponent, parentSuspense) &#125; if (c2 !== c1) &#123; // 文本对比不同，则替换为新文本 hostSetElementText(container, c2) &#125; &#125; else &#123; if (prevShapeFlag &amp; 16 /* ARRAY_CHILDREN */) &#123; // 之前的子节点是数组 if (shapeFlag &amp; 16 /* ARRAY_CHILDREN */) &#123; // 新的子节点仍然是数组，则做完整地 diff patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else &#123; // 数组 -&gt; 空，则仅仅删除之前的子节点 unmountChildren(c1, parentComponent, parentSuspense, true) &#125; &#125; else &#123; // 之前的子节点是文本节点或者为空 // 新的子节点是数组或者为空 if (prevShapeFlag &amp; 8 /* TEXT_CHILDREN */) &#123; // 如果之前子节点是文本，则把它清空 hostSetElementText(container, &#x27;&#x27;) &#125; if (shapeFlag &amp; 16 /* ARRAY_CHILDREN */) &#123; // 如果新的子节点是数组，则挂载新子节点 mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; &#125; &#125;&#125; 对于一个元素的子节点 vnode 可能会有三种情况：纯文本、vnode 数组和空。那么根据排列组合对于新旧子节点来说就有九种情况，我们可以通过三张图来表示。 首先来看一下旧子节点是纯文本的情况： 如果新子节点也是纯文本，那么做简单地文本替换即可； 如果新子节点是空，那么删除旧子节点即可； 如果新子节点是 vnode 数组，那么先把旧子节点的文本清空，再去旧子节点的父容器下添加多个新子节点。 接下来看一下旧子节点是空的情况： 如果新子节点是纯文本，那么在旧子节点的父容器下添加新文本节点即可； 如果新子节点也是空，那么什么都不需要做； 如果新子节点是 vnode 数组，那么直接去旧子节点的父容器下添加多个新子节点即可。 最后来看一下旧子节点是 vnode 数组的情况： 如果新子节点是纯文本，那么先删除旧子节点，再去旧子节点的父容器下添加新文本节点； 如果新子节点是空，那么删除旧子节点即可； 如果新子节点也是 vnode 数组，那么就需要做完整的 diff 新旧子节点了，这是最复杂的情况，内部运用了核心 diff 算法。 下节课我们就来深入探究一下这个复杂的 diff 算法。 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-core&#x2F;src&#x2F;renderer.tspackages&#x2F;runtime-core&#x2F;src&#x2F;componentRenderUtils.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"DOM-diff","slug":"DOM-diff","permalink":"https://xiaozhouguo.github.io/tags/DOM-diff/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"组件渲染，从VNode到真实DOM的转变","slug":"vue3/component-render","date":"2022-06-24T03:23:34.000Z","updated":"2022-10-13T08:18:59.435Z","comments":true,"path":"2022/06/24/vue3/component-render/","link":"","permalink":"https://xiaozhouguo.github.io/2022/06/24/vue3/component-render/","excerpt":"在 Vue.js 中，组件是一个非常重要的概念，整个应用的页面都是通过组件渲染来实现的，但是你知道当我们编写这些组件的时候，它的内部是如何工作的吗？从我们编写组件开始，到最终真实的 DOM 又是怎样的一个转变过程呢？这节课，我们将会学习 Vue.js 3.0 中的组件是如何渲染的，通过学习，你的这些问题将会迎刃而解。","text":"在 Vue.js 中，组件是一个非常重要的概念，整个应用的页面都是通过组件渲染来实现的，但是你知道当我们编写这些组件的时候，它的内部是如何工作的吗？从我们编写组件开始，到最终真实的 DOM 又是怎样的一个转变过程呢？这节课，我们将会学习 Vue.js 3.0 中的组件是如何渲染的，通过学习，你的这些问题将会迎刃而解。 首先，组件是一个抽象的概念，它是对一棵 DOM 树的抽象，我们在页面中写一个组件节点： 1&lt;hello-world&gt;&lt;/hello-world&gt; 这段代码并不会在页面上渲染一个&lt;hello-world&gt;标签，而它具体渲染成什么，取决于你怎么编写 HelloWorld 组件的模板。举个例子，HelloWorld 组件内部的模板定义是这样的： 12345&lt;template&gt; &lt;div&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 可以看到，模板内部最终会在页面上渲染一个 div，内部包含一个 p 标签，用来显示 Hello World 文本。 所以，从表现上来看，组件的模板决定了组件生成的 DOM 标签，而在 Vue.js 内部，一个组件想要真正的渲染生成 DOM，还需要经历“创建 vnode - 渲染 vnode - 生成 DOM” 这几个步骤： 你可能会问，什么是 vnode，它和组件什么关系呢？先不要着急，我们在后面会详细说明。这里，你只需要记住它就是一个可以描述组件信息的 JavaScript 对象即可。 接下来，我们就从应用程序的入口开始，逐步来看 Vue.js 3.0 中的组件是如何渲染的。 应用程序初始化一个组件可以通过“模板加对象描述”的方式创建，组件创建好以后是如何被调用并初始化的呢？因为整个组件树是由根组件开始渲染的，为了找到根组件的渲染入口，我们需要从应用程序的初始化过程开始分析。 在这里，我分别给出了通过 Vue.js 2.x 和 Vue.js 3.0 来初始化应用的代码： 123456789101112// 在 Vue.js 2.x 中，初始化一个应用的方式如下import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;const app = new Vue(&#123; render: h =&gt; h(App)&#125;)app.$mount(&#x27;#app&#x27;)// 在 Vue.js 3.0 中，初始化一个应用的方式如下import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./app&#x27;const app = createApp(App)app.mount(&#x27;#app&#x27;) 可以看到，Vue.js 3.0 初始化应用的方式和 Vue.js 2.x 差别并不大，本质上都是把 App 组件挂载到 id 为 app 的 DOM 节点上。 但是，在 Vue.js 3.0 中还导入了一个 createApp，其实这是个入口函数，它是 Vue.js 对外暴露的一个函数，我们来看一下它的内部实现： 12345678910const createApp = ((...args) =&gt; &#123; // 创建 app 对象 const app = ensureRenderer().createApp(...args) const &#123; mount &#125; = app // 重写 mount 方法 app.mount = (containerOrSelector) =&gt; &#123; // ... &#125; return app&#125;) 从代码中可以看出 createApp 主要做了两件事情：创建 app 对象和重写 app.mount 方法。接下来，我们就具体来分析一下它们。 1. 创建 app 对象首先，我们使用 ensureRenderer().createApp() 来创建 app 对象 ： 1const app = ensureRenderer().createApp(...args) 其中 ensureRenderer() 用来创建一个渲染器对象，它的内部代码是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940// 渲染相关的一些配置，比如更新属性的方法，操作 DOM 的方法const rendererOptions = &#123; patchProp, ...nodeOps&#125;let renderer// 延时创建渲染器，当用户只依赖响应式包的时候，可以通过 tree-shaking 移除核心渲染逻辑相关的代码function ensureRenderer() &#123; return renderer || (renderer = createRenderer(rendererOptions))&#125;function createRenderer(options) &#123; return baseCreateRenderer(options)&#125;function baseCreateRenderer(options) &#123; function render(vnode, container) &#123; // 组件渲染的核心逻辑 &#125; return &#123; render, createApp: createAppAPI(render) &#125;&#125;function createAppAPI(render) &#123; // createApp createApp 方法接受的两个参数：根组件的对象和 prop return function createApp(rootComponent, rootProps = null) &#123; const app = &#123; _component: rootComponent, _props: rootProps, mount(rootContainer) &#123; // 创建根组件的 vnode const vnode = createVNode(rootComponent, rootProps) // 利用渲染器渲染 vnode render(vnode, rootContainer) app._container = rootContainer return vnode.component.proxy &#125; &#125; return app &#125;&#125; 可以看到，这里先用 ensureRenderer() 来延时创建渲染器，这样做的好处是当用户只依赖响应式包的时候，就不会创建渲染器，因此可以通过 tree-shaking 的方式移除核心渲染逻辑相关的代码。 这里涉及了渲染器的概念，它是为跨平台渲染做准备的，之后我会在自定义渲染器的相关内容中详细说明。在这里，你可以简单地把渲染器理解为包含平台渲染核心逻辑的 JavaScript 对象。 我们结合上面的代码继续深入，在 Vue.js 3.0 内部通过 createRenderer 创建一个渲染器，这个渲染器内部会有一个 createApp 方法，它是执行 createAppAPI 方法返回的函数，接受了 rootComponent 和 rootProps 两个参数，我们在应用层面执行 createApp(App) 方法时，会把 App 组件对象作为根组件传递给 rootComponent。这样，createApp 内部就创建了一个 app 对象，它会提供 mount 方法，这个方法是用来挂载组件的。 在整个 app 对象创建过程中，Vue.js 利用闭包和函数柯里化的技巧，很好地实现了参数保留。比如，在执行 app.mount 的时候，并不需要传入渲染器 render，这是因为在执行 createAppAPI 的时候渲染器 render 参数已经被保留下来了。 2. 重写 app.mount 方法接下来，是重写 app.mount 方法。 根据前面的分析，我们知道 createApp 返回的 app 对象已经拥有了 mount 方法了，但在入口函数中，接下来的逻辑却是对 app.mount 方法的重写。先思考一下，为什么要重写这个方法，而不把相关逻辑放在 app 对象的 mount 方法内部来实现呢？ 这是因为 Vue.js 不仅仅是为 Web 平台服务，它的目标是支持跨平台渲染，而 createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程： 12345678mount(rootContainer) &#123; // 创建根组件的 vnode const vnode = createVNode(rootComponent, rootProps) // 利用渲染器渲染 vnode render(vnode, rootContainer) app._container = rootContainer return vnode.component.proxy&#125; 标准的跨平台渲染流程是先创建 vnode，再渲染 vnode。此外参数 rootContainer 也可以是不同类型的值，比如，在 Web 平台它是一个 DOM 对象，而在其他平台（比如 Weex 和小程序）中可以是其他类型的值。所以这里面的代码不应该包含任何特定平台相关的逻辑，也就是说这些代码的执行逻辑都是与平台无关的。因此我们需要在外部重写这个方法，来完善 Web 平台下的渲染逻辑。 接下来，我们再来看 app.mount 重写都做了哪些事情： 123456789101112131415app.mount = (containerOrSelector) =&gt; &#123; // 标准化容器 const container = normalizeContainer(containerOrSelector) if (!container) return const component = app._component // 如组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容 if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123; component.template = container.innerHTML &#125; // 挂载前清空容器内容 container.innerHTML = &#x27;&#x27; // 真正的挂载 return mount(container)&#125; 首先是通过 normalizeContainer 标准化容器（这里可以传字符串选择器或者 DOM 对象，但如果是字符串选择器，就需要把它转成 DOM 对象，作为最终挂载的容器），然后做一个 if 判断，如果组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容；接着在挂载前清空容器内容，最终再调用 app.mount 的方法走标准的组件渲染流程。 在这里，重写的逻辑都是和 Web 平台相关的，所以要放在外部实现。此外，这么做的目的是既能让用户在使用 API 时可以更加灵活，也兼容了 Vue.js 2.x 的写法，比如 app.mount 的第一个参数就同时支持选择器字符串和 DOM 对象两种类型。 从 app.mount 开始，才算真正进入组件渲染流程，那么接下来，我们就重点看一下核心渲染流程做的两件事情：创建 vnode 和渲染 vnode。 核心渲染流程：创建 vnode 和渲染 vnode1. 创建 vnode首先，是创建 vnode 的过程。 vnode 本质上是用来描述 DOM 的 JavaScript 对象，它在 Vue.js 中可以描述不同类型的节点，比如普通元素节点、组件节点等。 什么是普通元素节点呢？举个例子，在 HTML 中我们使用 &lt;button&gt; 标签来写一个按钮： 1&lt;button class=&quot;btn&quot; style=&quot;width:100px;height:50px&quot;&gt;click me&lt;/button&gt; 我们可以用 vnode 这样表示&lt;button&gt;标签： 1234567891011const vnode = &#123; type: &#x27;button&#x27;, props: &#123; &#x27;class&#x27;: &#x27;btn&#x27;, style: &#123; width: &#x27;100px&#x27;, height: &#x27;50px&#x27; &#125; &#125;, children: &#x27;click me&#x27;&#125; 其中，type 属性表示 DOM 的标签类型，props 属性表示 DOM 的一些附加信息，比如 style 、class 等，children 属性表示 DOM 的子节点，它也可以是一个 vnode 数组，只不过 vnode 可以用字符串表示简单的文本 。 什么是组件节点呢？其实， vnode 除了可以像上面那样用于描述一个真实的 DOM，也可以用来描述组件。 我们先在模板中引入一个组件标签 &lt;custom-component&gt;： 1&lt;custom-component msg=&quot;test&quot;&gt;&lt;/custom-component&gt; 我们可以用 vnode 这样表示 &lt;custom-component&gt; 组件标签： 123456789const CustomComponent = &#123; // 在这里定义组件对象&#125;const vnode = &#123; type: CustomComponent, props: &#123; msg: &#x27;test&#x27; &#125;&#125; 组件 vnode 其实是对抽象事物的描述，这是因为我们并不会在页面上真正渲染一个 &lt;custom-component&gt; 标签，而是渲染组件内部定义的 HTML 标签。 除了上两种 vnode 类型外，还有纯文本 vnode、注释 vnode 等等，但鉴于我们的主线只需要研究组件 vnode 和普通元素 vnode，所以我在这里就不赘述了。 另外，Vue.js 3.0 内部还针对 vnode 的 type，做了更详尽的分类，包括 Suspense、Teleport 等，且把 vnode 的类型信息做了编码，以便在后面的 patch 阶段，可以根据不同的类型执行相应的处理逻辑： 1234567891011const shapeFlag = isString(type) ? 1 /* ELEMENT */ : isSuspense(type) ? 128 /* SUSPENSE */ : isTeleport(type) ? 64 /* TELEPORT */ : isObject(type) ? 4 /* STATEFUL_COMPONENT */ : isFunction(type) ? 2 /* FUNCTIONAL_COMPONENT */ : 0 知道什么是 vnode 后，你可能会好奇，那么 vnode 有什么优势呢？为什么一定要设计 vnode 这样的数据结构呢？ 首先是抽象，引入 vnode，可以把渲染过程抽象化，从而使得组件的抽象能力也得到提升。 其次是跨平台，因为 patch vnode 的过程不同平台可以有自己的实现，基于 vnode 再做服务端渲染、Weex 平台、小程序平台的渲染都变得容易了很多。 不过这里要特别注意，使用 vnode 并不意味着不用操作 DOM 了，很多同学会误以为 vnode 的性能一定比手动操作原生 DOM 好，这个其实是不一定的。 因为，首先这种基于 vnode 实现的 MVVM 框架，在每次 render to vnode 的过程中，渲染组件会有一定的 JavaScript 耗时，特别是大组件，比如一个 1000 * 10 的 Table 组件，render to vnode 的过程会遍历 1000 * 10 次去创建内部 cell vnode，整个耗时就会变得比较长，加上 patch vnode 的过程也会有一定的耗时，当我们去更新组件的时候，用户会感觉到明显的卡顿。虽然 diff 算法在减少 DOM 操作方面足够优秀，但最终还是免不了操作 DOM，所以说性能并不是 vnode 的优势。 那么，Vue.js 内部是如何创建这些 vnode 的呢？ 回顾 app.mount 函数的实现，内部是通过 createVNode 函数创建了根组件的 vnode ： 1const vnode = createVNode(rootComponent, rootProps) 我们来看一下 createVNode 函数的大致实现： 123456789101112131415161718192021222324252627function createVNode(type, props = null,children = null) &#123; if (props) &#123; // 处理 props 相关逻辑，标准化 class 和 style &#125; // 对 vnode 类型信息编码 const shapeFlag = isString(type) ? 1 /* ELEMENT */ : isSuspense(type) ? 128 /* SUSPENSE */ : isTeleport(type) ? 64 /* TELEPORT */ : isObject(type) ? 4 /* STATEFUL_COMPONENT */ : isFunction(type) ? 2 /* FUNCTIONAL_COMPONENT */ : 0 const vnode = &#123; type, props, shapeFlag, // 一些其他属性 &#125; // 标准化子节点，把不同数据类型的 children 转成数组或者文本类型 normalizeChildren(vnode, children) return vnode&#125; 通过上述代码可以看到，其实 createVNode 做的事情很简单，就是：对 props 做标准化处理、对 vnode 的类型信息编码、创建 vnode 对象，标准化子节点 children 。 我们现在拥有了这个 vnode 对象，接下来要做的事情就是把它渲染到页面中去。 2. 渲染 vnode接下来，是渲染 vnode 的过程。 回顾 app.mount 函数的实现，内部通过执行这段代码去渲染创建好的 vnode： 1234567891011121314render(vnode, rootContainer)const render = (vnode, container) =&gt; &#123; if (vnode == null) &#123; // 销毁组件 if (container._vnode) &#123; unmount(container._vnode, null, null, true) &#125; &#125; else &#123; // 创建或者更新组件 patch(container._vnode || null, vnode, container) &#125; // 缓存 vnode 节点，表示已经渲染 container._vnode = vnode&#125; 这个渲染函数 render 的实现很简单，如果它的第一个参数 vnode 为空，则执行销毁组件的逻辑，否则执行创建或者更新组件的逻辑。 接下来我们接着看一下上面渲染 vnode 的代码中涉及的 patch 函数的实现： 1234567891011121314151617181920212223242526272829303132333435363738const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) =&gt; &#123; // 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点 if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123; anchor = getNextHostNode(n1) unmount(n1, parentComponent, parentSuspense, true) n1 = null &#125; const &#123; type, shapeFlag &#125; = n2 switch (type) &#123; case Text: // 处理文本节点 break case Comment: // 处理注释节点 break case Static: // 处理静态节点 break case Fragment: // 处理 Fragment 元素 break default: if (shapeFlag &amp; 1 /* ELEMENT */) &#123; // 处理普通 DOM 元素 processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else if (shapeFlag &amp; 6 /* COMPONENT */) &#123; // 处理组件 processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else if (shapeFlag &amp; 64 /* TELEPORT */) &#123; // 处理 TELEPORT &#125; else if (shapeFlag &amp; 128 /* SUSPENSE */) &#123; // 处理 SUSPENSE &#125; &#125;&#125; patch 本意是打补丁的意思，这个函数有两个功能，一个是根据 vnode 挂载 DOM，一个是根据新旧 vnode 更新 DOM。对于初次渲染，我们这里只分析创建过程，更新过程在后面的章节分析。 在创建的过程中，patch 函数接受多个参数，这里我们目前只重点关注前三个： 第一个参数 n1 表示旧的 vnode，当 n1 为 null 的时候，表示是一次挂载的过程； 第二个参数 n2 表示新的 vnode 节点，后续会根据这个 vnode 类型执行不同的处理逻辑； 第三个参数 container 表示 DOM 容器，也就是 vnode 渲染生成 DOM 后，会挂载到 container 下面。 对于渲染的节点，我们这里重点关注两种类型节点的渲染逻辑：对组件的处理和对普通 DOM 元素的处理。 先来看对组件的处理。由于初始化渲染的是 App 组件，它是一个组件 vnode，所以我们来看一下组件的处理逻辑是怎样的。首先是用来处理组件的 processComponent 函数的实现： 12345678910const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; if (n1 == null) &#123; // 挂载组件 mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else &#123; // 更新组件 updateComponent(n1, n2, parentComponent, optimized) &#125;&#125; 该函数的逻辑很简单，如果 n1 为 null，则执行挂载组件的逻辑，否则执行更新组件的逻辑。 我们接着来看挂载组件的 mountComponent 函数的实现： 12345678const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; // 创建组件实例 const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense)) // 设置组件实例 setupComponent(instance) // 设置并运行带副作用的渲染函数 setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)&#125; 可以看到，挂载组件函数 mountComponent 主要做三件事情：创建组件实例、设置组件实例、设置并运行带副作用的渲染函数。 首先是创建组件实例，Vue.js 3.0 虽然不像 Vue.js 2.x 那样通过类的方式去实例化组件，但内部也通过对象的方式去创建了当前渲染的组件实例。 其次设置组件实例，instance 保留了很多组件相关的数据，维护了组件的上下文，包括对 props、插槽，以及其他实例的属性的初始化处理。 创建和设置组件实例这两个流程我们这里不展开讲，会在后面的章节详细分析。 最后是运行带副作用的渲染函数 setupRenderEffect，我们重点来看一下这个函数的实现： 1234567891011121314151617const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; &#123; // 创建响应式的副作用渲染函数 instance.update = effect(function componentEffect() &#123; if (!instance.isMounted) &#123; // 渲染组件生成子树 vnode const subTree = (instance.subTree = renderComponentRoot(instance)) // 把子树 vnode 挂载到 container 中 patch(null, subTree, container, anchor, instance, parentSuspense, isSVG) // 保留渲染生成的子树根 DOM 节点 initialVNode.el = subTree.el instance.isMounted = true &#125; else &#123; // 更新组件 &#125; &#125;, prodEffectOptions)&#125; 该函数利用响应式库的 effect 函数创建了一个副作用渲染函数 componentEffect （effect 的实现我们后面讲响应式章节会具体说）。副作用，这里你可以简单地理解为，当组件的数据发生变化时，effect 函数包裹的内部渲染函数 componentEffect 会重新执行一遍，从而达到重新渲染组件的目的。 渲染函数内部也会判断这是一次初始渲染还是组件更新。这里我们只分析初始渲染流程。 初始渲染主要做两件事情：渲染组件生成 subTree、把 subTree 挂载到 container 中。 首先，是渲染组件生成 subTree，它也是一个 vnode 对象。这里要注意别把 subTree 和 initialVNode 弄混了（其实在 Vue.js 3.0 中，根据命名我们已经能很好地区分它们了，而在 Vue.js 2.x 中它们分别命名为 _vnode 和 $vnode）。我来举个例子说明，在父组件 App 中里引入了 Hello 组件： 123456&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;p&gt;This is an app.&lt;/p&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt;&lt;/template&gt; 在 Hello 组件中是 &lt;div&gt; 标签包裹着一个 &lt;p&gt; 标签： 12345&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;p&gt;Hello, Vue 3.0!&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 在 App 组件中， &lt;hello&gt; 节点渲染生成的 vnode ，对应的就是 Hello 组件的 initialVNode ，为了好记，你也可以把它称作“组件 vnode”。而 Hello 组件内部整个 DOM 节点对应的 vnode 就是执行 renderComponentRoot 渲染生成对应的 subTree，我们可以把它称作“子树 vnode”。 我们知道每个组件都会有对应的 render 函数，即使你写 template，也会编译成 render 函数，而 renderComponentRoot 函数就是去执行 render 函数创建整个组件树内部的 vnode，把这个 vnode 再经过内部一层标准化，就得到了该函数的返回结果：子树 vnode。 渲染生成子树 vnode 后，接下来就是继续调用 patch 函数把子树 vnode 挂载到 container 中了。 那么我们又再次回到了 patch 函数，会继续对这个子树 vnode 类型进行判断，对于上述例子，App 组件的根节点是 &lt;div&gt; 标签，那么对应的子树 vnode 也是一个普通元素 vnode，那么我们接下来看对普通 DOM 元素的处理流程。 首先我们来看一下处理普通 DOM元素的 processElement 函数的实现： 1234567891011const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; isSVG = isSVG || n2.type === &#x27;svg&#x27; if (n1 == null) &#123; //挂载元素节点 mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125; else &#123; //更新元素节点 patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized) &#125;&#125; 该函数的逻辑很简单，如果 n1 为 null，走挂载元素节点的逻辑，否则走更新元素节点逻辑。 我们接着来看挂载元素的 mountElement 函数的实现： 123456789101112131415161718192021222324const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; &#123; let el const &#123; type, props, shapeFlag &#125; = vnode // 创建 DOM 元素节点 el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is) if (props) &#123; // 处理 props，比如 class、style、event 等属性 for (const key in props) &#123; if (!isReservedProp(key)) &#123; hostPatchProp(el, key, null, props[key], isSVG) &#125; &#125; &#125; if (shapeFlag &amp; 8 /* TEXT_CHILDREN */) &#123; // 处理子节点是纯文本的情况 hostSetElementText(el, vnode.children) &#125; else if (shapeFlag &amp; 16 /* ARRAY_CHILDREN */) &#123; // 处理子节点是数组的情况 mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG &amp;&amp; type !== &#x27;foreignObject&#x27;, optimized || !!vnode.dynamicChildren) &#125; // 把创建的 DOM 元素节点挂载到 container 上 hostInsert(el, container, anchor)&#125; 可以看到，挂载元素函数主要做四件事：创建 DOM 元素节点、处理 props、处理 children、挂载 DOM 元素到 container 上。 首先是创建 DOM 元素节点，通过 hostCreateElement 方法创建，这是一个平台相关的方法，我们来看一下它在 Web 环境下的定义： 1234function createElement(tag, isSVG, is) &#123; isSVG ? document.createElementNS(svgNS, tag) : document.createElement(tag, is ? &#123; is &#125; : undefined)&#125; 它调用了底层的 DOM API document.createElement 创建元素，所以本质上 Vue.js 强调不去操作 DOM ，只是希望用户不直接碰触 DOM，它并没有什么神奇的魔法，底层还是会操作 DOM。 另外，如果是其他平台比如 Weex，hostCreateElement 方法就不再是操作 DOM ，而是平台相关的 API 了，这些平台相关的方法是在创建渲染器阶段作为参数传入的。 创建完 DOM 节点后，接下来要做的是判断如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的，这里就不展开讲了。 接下来是对子节点的处理，我们知道 DOM 是一棵树，vnode 同样也是一棵树，并且它和 DOM 结构是一一映射的。 如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本： 123function setElementText(el, text) &#123; el.textContent = text&#125; 如果子节点是数组，则执行 mountChildren 方法： 12345678910const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) =&gt; &#123; for (let i = start; i &lt; children.length; i++) &#123; // 预处理 child const child = (children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i])) // 递归 patch 挂载 child patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized) &#125;&#125; 子节点的挂载逻辑同样很简单，遍历 children 获取到每一个 child，然后递归执行 patch 方法挂载每一个 child 。注意，这里有对 child 做预处理的情况（后面编译优化的章节会详细分析）。 可以看到，mountChildren 函数的第二个参数是 container，而我们调用 mountChildren 方法传入的第二个参数是在 mountElement 时创建的 DOM 节点，这就很好地建立了父子关系。 另外，通过递归 patch 这种深度优先遍历树的方式，我们就可以构造完整的 DOM 树，完成组件的渲染。 处理完所有子节点后，最后通过 hostInsert 方法把创建的 DOM 元素节点挂载到 container 上，它在 Web 环境下这样定义： 12345678function insert(child, parent, anchor) &#123; if (anchor) &#123; parent.insertBefore(child, anchor) &#125; else &#123; parent.appendChild(child) &#125;&#125; 这里会做一个 if 判断，如果有参考元素 anchor，就执行 parent.insertBefore ，否则执行 parent.appendChild 来把 child 添加到 parent 下，完成节点的挂载。 因为 insert 的执行是在处理子节点后，所以挂载的顺序是先子节点，后父节点，最终挂载到最外层的容器上。 知识延伸：嵌套组件细心的你可能会发现，在 mountChildren 的时候递归执行的是 patch 函数，而不是 mountElement 函数，这是因为子节点可能有其他类型的 vnode，比如组件 vnode。 在真实开发场景中，嵌套组件场景是再正常不过的了，前面我们举的 App 和 Hello 组件的例子就是嵌套组件的场景。组件 vnode 主要维护着组件的定义对象，组件上的各种 props，而组件本身是一个抽象节点，它自身的渲染其实是通过执行组件定义的 render 函数渲染生成的子树 vnode 来完成，然后再 patch 。通过这种递归的方式，无论组件的嵌套层级多深，都可以完成整个组件树的渲染。 总结OK，到这里我们这一节的学习也要结束啦，这节课我们主要分析了组件的渲染流程，从入口开始，一层层分析组件渲染。 你可能发现了，文中提到的很多技术点我会放在后面的章节去讲，这样做是为了让我们不跑题，重点放在理解组件的渲染流程上。下节课我将会带你具体分析一下组件的更新过程。 这里，我用一张图来带你更加直观地感受下整个组件渲染流程： 本节课的相关代码在源代码中的位置如下：packages&#x2F;runtime-dom&#x2F;src&#x2F;index.tspackages&#x2F;runtime-core&#x2F;src&#x2F;apiCreateApp.tspackages&#x2F;runtime-core&#x2F;src&#x2F;vnode.tspackages&#x2F;runtime-core&#x2F;src&#x2F;renderer.tspackages&#x2F;runtime-dom&#x2F;src&#x2F;nodeOps.ts","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"Vue3.0的优化简述","slug":"vue3/vue3-optimization-summary","date":"2022-06-23T09:23:05.000Z","updated":"2022-07-26T07:36:27.623Z","comments":true,"path":"2022/06/23/vue3/vue3-optimization-summary/","link":"","permalink":"https://xiaozhouguo.github.io/2022/06/23/vue3/vue3-optimization-summary/","excerpt":"Vue.js 从 1.x 到 2.0 版本，最大的升级就是引入了虚拟 DOM 的概念，它为后续做服务端渲染以及跨端框架 Weex 提供了基础。","text":"Vue.js 从 1.x 到 2.0 版本，最大的升级就是引入了虚拟 DOM 的概念，它为后续做服务端渲染以及跨端框架 Weex 提供了基础。 Vue.js 2.x 发展了很久，现在周边的生态设施都已经非常完善了，而且对于 Vue.js 用户而言，它几乎满足了我们日常开发的所有需求。你可能觉得 Vue.js 2.x 已经足够优秀，但是在 Vue.js 作者尤尤大的眼中它还不够完美。在迭代 2.x 版本的过程中，尤大发现了很多需要解决的痛点，比如源码自身的维护性，数据量大后带来的渲染和更新的性能问题，一些想舍弃但为了兼容一直保留的鸡肋 API 等；另外，尤大还希望能给开发人员带来更好的编程体验，比如更好的 TypeScript 支持、更好的逻辑复用实践等，所以他希望能从源码、性能和语法 API 三个大的方面优化框架。 那么接下来，我们就一起来看一下 Vue.js 3.0 具体做了哪些优化。相信你学习完这篇文章，不仅能知道 Vue.js 3.0 的升级给我们开发带来的收益，还能学习到一些设计思想和理念，并在自己的开发工作中应用，获得提升。 源码优化首先是源码优化，也就是尤大对于 Vue.js 框架本身开发的优化，它的目的是让代码更易于开发和维护。源码的优化主要体现在使用 monorepo 和 TypeScript 管理和开发源码，这样做的目标是提升自身代码可维护性。接下来我们就来看一下这两个方面的具体变化。 更好的代码管理方式：monorepo首先，源码的优化体现在代码管理方式上。Vue.js 2.x 的源码托管在 src 目录，然后依据功能拆分出了 compiler（模板编译的相关代码）、core（与平台无关的通用运行时代码）、platforms（平台专有代码）、server（服务端渲染的相关代码）、sfc（.vue 单文件解析相关代码）、shared（共享工具代码） 等目录： 而到了 Vue.js 3.0 ，整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中： 可以看出相对于 Vue.js 2.x 的源码组织方式，monorepo 把这些模块拆分到不同的 package 中，每个 package 有各自的 API、类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue.js 使用的，这样用户如果只想使用 Vue.js 3.0 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue.js，减小了引用包的体积大小，而 Vue.js 2 .x 是做不到这一点的。 有类型的 JavaScript：TypeScript其次，源码的优化还体现在 Vue.js 3.0 自身采用了 TypeScript 开发。Vue.js 1.x 版本的源码是没有用类型语言的，尤大用 JavaScript 开发了整个框架，但对于复杂的框架项目开发，使用类型语言非常有利于代码的维护，因为它可以在编码期间帮你做类型检查，避免一些因类型问题导致的错误；也可以利于它去定义接口的类型，利于 IDE 对变量类型的推导。因此在重构 2.0 的时候，尤大选型了 Flow，但是在 Vue.js 3.0 的时候抛弃 Flow 转而采用 TypeScript 重构了整个项目，这里有两方面原因，接下来我们具体说一下。首先，Flow 是 Facebook 出品的 JavaScript 静态类型检查工具，它可以以非常小的成本对已有的 JavaScript 代码迁入，非常灵活，这也是 Vue.js 2.0 当初选型它时一方面的考量。但是 Flow 对于一些复杂场景类型的检查，支持得并不好。记得在看 Vue.js 2.x 源码的时候，在某行代码的注释中看到了对 Flow 的吐槽，比如在组件更新 props 的地方出现了： 1const propOptions: any = vm.$options.props // wtf flow? 什么意思呢？其实是由于这里 Flow 并没有正确推导出 vm.$options.props 的类型 ，开发人员不得不强制申明 propsOptions 的类型为 any，显得很不合理；另外他也在社区平台吐槽过 Flow 团队的烂尾。其次，Vue.js 3.0 抛弃 Flow 后，使用 TypeScript 重构了整个项目。 TypeScript提供了更好的类型检查，能支持复杂的类型推导；由于源码就使用 TypeScript 编写，也省去了单独维护 d.ts 文件的麻烦；就整个 TypeScript 的生态来看，TypeScript 团队也是越做越好，TypeScript 本身保持着一定频率的迭代和更新，支持的 feature 也越来越多。此外，尤大和 TypeScript 团队也一直保持了良好的沟通，我们可以期待 TypeScript 对 Vue.js 的支持会越来越好。 性能优化性能优化一直是前端老生常谈的问题。那么对于 Vue.js 2.x 已经足够优秀的前端框架，它的性能优化可以从哪些方面进行突破呢？ 源码体积优化首先是源码体积优化，我们在平时工作中也经常会尝试优化静态资源的体积，因为 JavaScript 包体积越小，意味着网络传输时间越短，JavaScript 引擎解析包的速度也越快。那么，Vue.js 3.0 在源码体积的减少方面做了哪些工作呢？ + 首先，移除一些冷门的 feature（比如 filter、inline-template 等）； + 其次，引入 tree-shaking 的技术，减少打包体积。 第一点很好理解，所以这里我们来看看 tree-shaking，它的原理很简单，tree-shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块并打上标记。举个例子，一个 math 模块定义了 2 个方法 square(x) 和 cube(x) ： 123456export function square(x) &#123; return x * x&#125;export function cube(x) &#123; return x * x * x&#125; 我们在这个模块外面只引入了 cube 方法： 12import &#123; cube &#125; from &#x27;./math.js&#x27;// do something with cube 最终 math 模块会被 webpack 打包生成如下代码： 123456789101112/* 1 *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123; &#x27;use strict&#x27;; /* unused harmony export square */ /* harmony export (immutable) */ __webpack_exports__[&#x27;a&#x27;] = cube; function square(x) &#123; return x * x; &#125; function cube(x) &#123; return x * x * x; &#125;&#125;); 可以看到，未被引入的 square 模块被标记了， 然后压缩阶段会利用例如 uglify-js、terser 等压缩工具真正地删除这些没有用到的代码。也就是说，利用 tree-shaking 技术，如果你在项目中没有引入 Transition、KeepAlive 等组件，那么它们对应的代码就不会打包，这样也就间接达到了减少项目引入的 Vue.js 包体积的目的。 数据劫持优化其次是数据劫持优化。Vue.js 区别于 React 的一大特色是它的数据是响应式的，这个特性从 Vue.js 1.x 版本就一直伴随着，这也是 Vue.js 粉喜欢 Vue.js 的原因之一，DOM 是数据的一种映射，数据发生变化后可以自动更新 DOM，用户只需要专注于数据的修改，没有其余的心智负担。在 Vue.js 内部，想实现这个功能是要付出一定代价的，那就是必须劫持数据的访问和更新。其实这点很好理解，当数据改变后，为了自动更新 DOM，那么就必须劫持数据的更新，也就是说当数据发生改变后能自动执行一些代码去更新 DOM，那么问题来了，Vue.js 怎么知道更新哪一片 DOM 呢？因为在渲染 DOM 的时候访问了数据，我们可以对它进行访问劫持，这样就在内部建立了依赖关系，也就知道数据对应的 DOM 是什么了。以上只是大体的思路，具体实现要比这更复杂，内部还依赖了一个 watcher 的数据结构做依赖管理，参考下图： Vue.js 1.x 和 Vue.js 2.x 内部都是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter，具体是这样的： 12345678Object.defineProperty(data, &#x27;a&#x27;,&#123; get()&#123; // track &#125;, set()&#123; // trigger &#125;&#125;) 但这个 API 有一些缺陷，它必须预先知道要拦截的 key 是什么，所以它并不能检测对象属性的添加和删除。尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法，但是对于用户来说，还是增加了一定的心智负担。 另外 Object.defineProperty 的方式还有一个问题，举个例子，比如这个嵌套层级比较深的对象： 1234567891011export default &#123; data: &#123; a: &#123; b: &#123; c: &#123; d: 1 &#125; &#125; &#125; &#125;&#125; 由于 Vue.js 无法判断你在运行时到底会访问到哪个属性，所以对于这样一个嵌套层级较深的对象，如果要劫持它内部深层次的对象变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的。毫无疑问，如果我们定义的响应式数据过于复杂，这就会有相当大的性能负担。 为了解决上述 2 个问题，Vue.js 3.0 使用了 Proxy API 做数据劫持，它的内部是这样的： 12345678observed = new Proxy(data, &#123; get() &#123; // track &#125;, set() &#123; // trigger &#125;&#125;) 由于它劫持的是整个对象，那么自然对于对象的属性的增加和删除都能检测到。 但要注意的是，Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能，我会在后面分析响应式章节详细介绍它的具体实现原理。 编译优化最后是编译优化，为了便于理解，我们先来看一张图： 这是 Vue.js 2.x 从 new Vue 开始渲染成 DOM 的流程，上面说过的响应式过程就发生在图中的 init 阶段，另外 template compile to render function 的流程是可以借助 vue-loader 在 webpack 编译阶段离线完成，并非一定要在运行时完成。 所以想优化整个 Vue.js 的运行时，除了数据劫持部分的优化，我们可以在耗时相对较多的 patch 阶段想办法，Vue.js 3.0 也是这么做的，并且它通过在编译阶段优化编译的结果，来实现运行时 patch 过程的优化。 我们知道，通过数据劫持和依赖收集，Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的： 虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树，举个例子，比如我们要更新这个组件： 123456789&lt;template&gt; &lt;div id=&quot;content&quot;&gt; &lt;p class=&quot;text&quot;&gt;static text&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;static text&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;static text&lt;/p&gt; &lt;p class=&quot;text&quot;&gt;static text&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 整个 diff 过程如图所示： 可以看到，因为这段代码中只有一个动态节点，所以这里有很多 diff 和遍历其实都是不需要的，这就会导致 vnode 的性能跟模版大小正相关，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。 而对于上述例子，理想状态只需要 diff 这个绑定 message 动态节点的 p 标签即可。 Vue.js 3.0 做到了，它通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破，我会在后续的章节详细分析它是如何实现的。 除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法，这些性能优化的内容我在后续特定的章节与你分享。 语法优化：Composition API优化组织逻辑在 Vue.js 1.x 和 2.x 版本中，编写组件本质就是在编写一个“包含了描述组件选项的对象”，我们把它称为 Options API，它的好处是在于写法非常符合直觉思维，对于新手来说这样很容易理解，这也是很多人喜欢 Vue.js 的原因之一。 Options API 的设计是按照 methods、computed、data、props 这些不同的选项分类，当组件小的时候，这种分类方式一目了然；但是在大型组件中，一个组件可能有多个逻辑关注点，当使用 Options API 的时候，每一个关注点都有自己的 Options，如果需要修改一个逻辑点关注点，就需要在单个文件中不断上下切换和寻找。 举一个官方例子 Vue CLI UI file explorer，它是 vue-cli GUI 应用程序中的一个复杂的文件浏览器组件。这个组件需要处理许多不同的逻辑关注点： 跟踪当前文件夹状态并显示其内容 处理文件夹导航（比如打开、关闭、刷新等） 处理新文件夹的创建 切换显示收藏夹 切换显示隐藏文件夹 处理当前工作目录的更改 如果我们按照逻辑关注点做颜色编码，就可以看到当使用 Options API 去编写组件时，这些逻辑关注点是非常分散的： Vue.js 3.0 提供了一种新的 API：Composition API，它有一个很好的机制去解决这样的问题，就是将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。 通过下图，我们可以很直观地感受到 Composition API 在逻辑组织方面的优势： 优化逻辑复用当我们开发项目变得复杂的时候，免不了需要抽象出一些复用的逻辑。在 Vue.js 2.x 中，我们通常会用 mixins 去复用逻辑，举一个鼠标位置侦听的例子，我们会编写如下函数 mousePositionMixin： 123456789101112131415161718192021const mousePositionMixin = &#123; data() &#123; return &#123; x: 0, y: 0 &#125; &#125;, mounted() &#123; window.addEventListener(&#x27;mousemove&#x27;, this.update) &#125;, destroyed() &#123; window.removeEventListener(&#x27;mousemove&#x27;, this.update) &#125;, methods: &#123; update(e) &#123; this.x = e.pageX this.y = e.pageY &#125; &#125;&#125;export default mousePositionMixin 然后在组件中使用： 1234567891011&lt;template&gt; &lt;div&gt; Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import mousePositionMixin from &#x27;./mouse&#x27;export default &#123; mixins: [mousePositionMixin]&#125;&lt;/script&gt; 使用单个 mixin 似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候，会存在两个非常明显的问题：命名冲突和数据来源不清晰。 首先每个 mixin 都可以定义自己的 props、data，它们之间是无感的，所以很容易定义相同的变量，导致命名冲突。另外对组件而言，如果模板中使用不在当前组件中定义的变量，那么就会不太容易知道这些变量在哪里定义的，这就是数据来源不清晰。但是Vue.js 3.0 设计的 Composition API，就很好地帮助我们解决了 mixins 的这两个问题。 我们来看一下在 Vue.js 3.0 中如何书写这个示例： 12345678910111213141516import &#123; ref, onMounted, onUnmounted &#125; from &#x27;vue&#x27;export default function useMousePosition() &#123; const x = ref(0) const y = ref(0) const update = e =&gt; &#123; x.value = e.pageX y.value = e.pageY &#125; onMounted(() =&gt; &#123; window.addEventListener(&#x27;mousemove&#x27;, update) &#125;) onUnmounted(() =&gt; &#123; window.removeEventListener(&#x27;mousemove&#x27;, update) &#125;) return &#123; x, y &#125;&#125; 这里我们约定 useMousePosition 这个函数为 hook 函数，然后在组件中使用： 1234567891011121314&lt;template&gt; &lt;div&gt; Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import useMousePosition from &#x27;./mouse&#x27; export default &#123; setup() &#123; const &#123; x, y &#125; = useMousePosition() return &#123; x, y &#125; &#125; &#125;&lt;/script&gt; 可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题。 Composition API 除了在逻辑复用方面有优势，也会有更好的类型支持，因为它们都是一些函数，在调用函数时，自然所有的类型就被推导出来了，不像 Options API 所有的东西使用 this。另外，Composition API 对 tree-shaking 友好，代码也更容易压缩。 虽然 Composition API 有诸多优势，它也不是一点缺点都没有，关于它的具体用法和设计原理，我们会在后续的章节详细说明。这里还需要说明的是，Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，你还是可以使用 Options API。 引入RFC：使每个版本改动可控 作为一个流行开源框架的作者，尤大可能每天都会收到各种各样的 feature request。但并不是社区一有新功能的需求，框架就会立马支持，因为随着 Vue.js 的用户越来越多，尤大会更加重视稳定性，会仔细考虑所做的每一个可能对最终用户影响的更改，以及有意识去防止新 API 对框架本身实现带来的复杂性的提升。 因此在 Vue.js 2.x 版本开发到后期的阶段 ，尤大就启用了 RFC ，它的全称是 Request For Comments，旨在为新功能进入框架提供一个一致且受控的路径。当社区有一些新需求的想法时，它可以提交一个 RFC，然后由社区和 Vue.js 的核心团队一起讨论，如果这个 RFC 最终被通过了，那么它才会被实现。比如 2.6 版本对于 slot 新 API 的改动，就是这条 RFC 里。 到了 Vue.js 3.0 ，尤大在实现代码前就大规模启用 RFC，来确保他的改动和设计都是经过讨论并确认的，这样可以避免走弯路。Vue.js 3.0 版本有很多重大的改动，每一条改动都会有对应的 RFC，通过阅读这些 RFC，你可以了解每一个 feature 采用或被废弃掉的前因后果。 Vue.js 3.0 目前已被实现并合并的 RFC 都在这里，通过阅读它们，你也可以大致了解 Vue.js 3.0 的一些变化，以及为什么会产生这些变化，帮助你了解它的前因后果。 过渡期接下来，我想再带你来了解一下 Vue.js 各版本迭代的过渡期，希望能够对你在 Vue.js 的技术选型方面和学习方向上有所帮助。 通常框架的 major 版本从升级到大规模投入使用，都需要经历相当长的一段过渡期。不过， Vue.js 1.x 到 Vue.js 2.0 的升级过渡期不长，主要是因为那个时候 Vue.js 的用户还不多，生态也不完善，很多用户都是直接上手的 2.0 版本，没有旧项目的历史包袱。 而 Vue.js 2.x 的发展历经了 3 年多的时间，用户众多，而且周边生态也已经非常完善了。通常 major 版本的升级会有很多 breaking change，这就意味着想从 2.x 升级到 3.0 的项目需要改代码，而且不仅仅项目的代码要修改，所依赖的周边生态也需要升级。这其实是一个相当大的工作量，也需要承担一定的风险，所以如果你的项目非常庞大且已经相对稳定，没有什么特别的痛点，那么升级要慎重。 Vue.js 3.0 使用 ES2015 的语法开发，有些 API 如 Proxy 是没有 polyfill 的，这就意味着官方需要单独出一个 IE11 compat 版本来支持 IE11。如果你的项目需要兼容 IE11，你就不得不小心使用某些 API，这也就带来了一些额外的心智负担。 因此可能在 Vue.js 3.0 出来的相当长的一段时间，复杂的大项目都不会考虑去升级，而一些小的、对浏览器兼容要求不高的新项目可以考虑尝鲜了。 官方会继续维护 Vue.js 2.x 版本 18 个月，如果你的有些项目一辈子都不打算升级 Vue.js 3.0，那么你应该去认真学习 Vue.js 2.x 的源码，在官方不再维护的时候遇到问题你可以自己去修改它的源码来解决。 不过，虽然 Vue.js 3.0 距离大规模应用还有相当长一段时间，但是越早开始学习你就越能在未来掌握主动权。这段时间里，你可以关注它的发展，去学习它的设计思想，也可以去为它的生态建设贡献代码，从而提升自己的技术能力。另外也可以尝试在一些小项目中应用 Vue.js 3.0，不仅可以享受 Vue.js 3.0 带来的性能方面的优势以及 Composition API 在逻辑复用方面便利，也为了将来某一天全面升级 Vue.js 3.0 做技术储备。","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"type-challanges 记录","slug":"typescript/type-challanges","date":"2022-05-30T03:43:03.000Z","updated":"2022-06-08T03:09:19.707Z","comments":true,"path":"2022/05/30/typescript/type-challanges/","link":"","permalink":"https://xiaozhouguo.github.io/2022/05/30/typescript/type-challanges/","excerpt":"TypeScript 类型体操姿势合集记录 type-challenges&#x2F;README.zh-CN.md at main · type-challenges&#x2F;type-challenges (github.com)","text":"TypeScript 类型体操姿势合集记录 type-challenges&#x2F;README.zh-CN.md at main · type-challenges&#x2F;type-challenges (github.com) 298 - Length of String 计算字符串的长度，类似于 String#length，在 Github 上查看。 12345type LengthOfString&lt; S extends string, arr extends unknown[] = []&gt; = S extends `$&#123;infer first&#125;$&#123;infer rest&#125;` ? LengthOfString&lt;rest,[...arr,first]&gt; : arr[&#x27;length&#x27;] 459 - Flatten 在这个挑战中，你需要写一个接受数组的类型，并且返回扁平化的数组类型。在 Github 上查看，例如: 1type flatten = Flatten&lt;[1, 2, [3, 4], [[[5]]]]&gt; // [1, 2, 3, 4, 5] 1234567891011type FlattenArrayVal&lt;S extends any,T extends unknown[]=[]&gt; = S extends unknown[] ? S extends [infer first,...infer rest] ? FlattenArrayVal&lt;rest, first extends unknown[] ? FlattenArrayVal&lt;first,T&gt; : [...T,first]&gt; : T : Stype Flatten&lt;S extends unknown[],T extends unknown[]=[]&gt; = S extends [infer first,...infer rest] ? Flatten&lt;FlattenArrayVal&lt;rest&gt;, [...T,FlattenArrayVal&lt;first&gt;]&gt; : T 解释：类型 flattenArrayVal的作用是处理数组中的每一项，非数组类型直接返回原样，数组类型返回扁平化后的数组，给Flatten使用。 527 - Append to object 实现一个为接口添加一个新字段的类型。该类型接收三个参数，返回带有新字段的接口类型。在 Github 上查看，例如: 12type Test = &#123; id: &#x27;1&#x27; &#125;type Result = AppendToObject&lt;Test, &#x27;value&#x27;, 4&gt; // expected to be &#123; id: &#x27;1&#x27;, value: 4 &#125; 123type AppendToObject&lt;T extends Object, U extends string, V&gt; = &#123; [K in keyof T | U]: K extends keyof T ? T[K] : V&#125; 529 - Absolute 实现一个接收string,number或bigInt类型参数的Absolute类型,返回一个正数字符串。在 Github 上查看，例如： 12type Test = -100;type Result = Absolute&lt;Test&gt;; // expected to be &quot;100&quot; 12type Absolute&lt;T extends number | string | bigint&gt; = `$&#123;T&#125;` extends `-$&#123;infer V&#125;` ? V : `$&#123;T&#125;` 501 - String to Union 实现一个将接收到的String参数转换为一个字母Union的类型。在Github 上查看，例如： 12type Test = &#x27;123&#x27;;type Result = StringToUnion&lt;Test&gt;; // expected to be &quot;1&quot; | &quot;2&quot; | &quot;3&quot; 12345type StringToUnion&lt;T extends string&gt; = T extends &quot;&quot; ? never : T extends `$&#123;infer first&#125;$&#123;infer rest&#125;` ? first | StringToUnion&lt;rest&gt; : T 599 - Merge 将两个类型合并成一个类型，第二个类型的键会覆盖第一个类型的键。在 Github 上查看，例如： 1234567891011type foo = &#123; name: string; age: string;&#125;type coo = &#123; age: number; sex: string&#125;type Result = Merge&lt;foo,coo&gt;; // expected to be &#123;name: string, age: number, sex: string&#125; 123type Merge&lt;F extends Object, S extends Object&gt; = &#123; [K in keyof F | keyof S]: K extends keyof S ? S[K] : K extends keyof F ? F[K] : never&#125; 612 - KebabCase FooBarBaz-&gt;foo-bar-baz，在Github上查看。 12345678type FirstLowcase&lt;T extends string&gt; = T extends `$&#123;infer F&#125;$&#123;infer R&#125;` ? F extends Lowercase&lt;F&gt; ? T : `$&#123;Lowercase&lt;F&gt;&#125;$&#123;R&#125;` : Ttype KebabCase&lt;S extends string&gt; = S extends `$&#123;infer F&#125;$&#123;infer R&#125;` ? R extends FirstLowcase&lt;R&gt; ? `$&#123;FirstLowcase&lt;F&gt;&#125;$&#123;KebabCase&lt;R&gt;&#125;` : `$&#123;FirstLowcase&lt;F&gt;&#125;-$&#123;KebabCase&lt;FirstLowcase&lt;R&gt;&gt;&#125;` : S 12345678910111213141516171819202122232425262728293031323334353637383940type KebabMap = &#123; A: &quot;a&quot; B: &quot;b&quot; C: &quot;c&quot; D: &quot;d&quot; E: &quot;e&quot; F: &quot;f&quot; G: &quot;g&quot; H: &quot;h&quot; I: &quot;i&quot; J: &quot;j&quot; K: &quot;k&quot; L: &quot;l&quot; M: &quot;m&quot; N: &quot;n&quot; O: &quot;o&quot; P: &quot;p&quot; Q: &quot;q&quot; R: &quot;r&quot; S: &quot;s&quot; T: &quot;t&quot; U: &quot;u&quot; V: &quot;v&quot; W: &quot;w&quot; X: &quot;x&quot; Y: &quot;y&quot; Z: &quot;z&quot;&#125;type KebabCase&lt; S extends string, U extends string = &quot;&quot;&gt; = S extends `$&#123;infer Target&#125;$&#123;infer R&#125;` ? Target extends keyof KebabMap ? U extends &quot;&quot; ? KebabCase&lt;R, `$&#123;U&#125;$&#123;KebabMap[Target]&#125;`&gt; : KebabCase&lt;R, `$&#123;U&#125;-$&#123;KebabMap[Target]&#125;`&gt; : KebabCase&lt;R, `$&#123;U&#125;$&#123;Target&#125;`&gt; : U 645 - Diff 获取两个接口类型中的差值属性。在 Github 上查看，例如： 1234567891011type Foo = &#123; a: string; b: number;&#125;type Bar = &#123; a: string; c: boolean&#125;type Result1 = Diff&lt;Foo,Bar&gt; // &#123; b: number, c: boolean &#125;type Result2 = Diff&lt;Bar,Foo&gt; // &#123; b: number, c: boolean &#125; 第一种： 123type Diff&lt;O extends object, O1 extends object&gt; = &#123; [K in (keyof Omit&lt;O &amp; O1, keyof (O | O1)&gt;)]: K extends keyof O ? O[K] : K extends keyof O1 ? O1[K]:neve 第二种： 1234type Diff&lt;O extends object, O1 extends object&gt; = &#123; [K in keyof Omit&lt;O1, keyof O&gt; | keyof Omit&lt;O, keyof O1&gt;]: K extends keyof O ? O[K] : K extends keyof O1 ? O1[K]:never&#125; 949 AnyOf 在类型系统中实现类似于 Python 中 any 函数。类型接收一个数组，如果数组中任一个元素为真，则返回 true，否则返回 fasle。如果数组为空，返回 false。在Github上查看，例如： 12type Sample1 = AnyOf&lt;[1, &#x27;&#x27;, false, [], &#123;&#125;]&gt; // expected to be true.type Sample2 = AnyOf&lt;[0, &#x27;&#x27;, false, [], &#123;&#125;]&gt; // expected to be false. 第一种： 12type FalsyVal&lt;V&gt; = V extends [] | Record&lt;string, never&gt; | &#x27;&#x27; | 0 | false ? false : truetype AnyOf&lt;T extends readonly any[]&gt; = true extends FalsyVal&lt;T[number]&gt; ? true : false 第二种： 12type FalsyVal = [] | Record&lt;string, never&gt; | &#x27;&#x27; | 0 | falsetype AnyOf&lt;T extends readonly any[]&gt; = T extends [infer Head, ...infer Tail] ? Head extends FalsyVal ? AnyOf&lt;Tail&gt; : true : false 1042 IsNever Implement a type IsNever, which takes input type T. If the type of resolves to never, return true, otherwise false. 在Github上查看。For example: 12345type A = IsNever&lt;never&gt; // expected to be truetype B = IsNever&lt;undefined&gt; // expected to be falsetype C = IsNever&lt;null&gt; // expected to be falsetype D = IsNever&lt;[]&gt; // expected to be falsetype E = IsNever&lt;number&gt; // expected to be false 第一种： 123// https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919// https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-typestype IsNever&lt;T&gt; = [T] extends [never] ? true : false 第二种： 1type IsNever&lt;T&gt; = &#123;[key: string]: T&#125; extends &#123;[key: string]: never&#125; ? true : false;","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://xiaozhouguo.github.io/categories/TypeScript/"}],"tags":[{"name":"type-challanges","slug":"type-challanges","permalink":"https://xiaozhouguo.github.io/tags/type-challanges/"}],"keywords":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://xiaozhouguo.github.io/categories/TypeScript/"}]},{"title":"一窥 vue3 响应式系统","slug":"vue3/simple-reactive","date":"2022-05-25T02:07:59.000Z","updated":"2022-05-26T07:05:00.000Z","comments":true,"path":"2022/05/25/vue3/simple-reactive/","link":"","permalink":"https://xiaozhouguo.github.io/2022/05/25/vue3/simple-reactive/","excerpt":"在 Vue 中，响应式系统采取的是发布订阅的模式，Vue2 中主要依赖 ES5 Object.defineProperty 的 API，在 vue3 中重写了响应式系统，使用的是 ES6 Proxy Reflect，在它们不受支持的情况下会降级使用 Object.defineProperty。今天我们来实现一个极其简易版的响应式系统。","text":"在 Vue 中，响应式系统采取的是发布订阅的模式，Vue2 中主要依赖 ES5 Object.defineProperty 的 API，在 vue3 中重写了响应式系统，使用的是 ES6 Proxy Reflect，在它们不受支持的情况下会降级使用 Object.defineProperty。今天我们来实现一个极其简易版的响应式系统。 前提JS 本身并没有响应式的特性，那 Vue 是如何实现这一魔法的呢，我们先来看下： 12345678let product = &#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;let total = product.quantity * product.price // 10product.price = 12console.log(&#x27;total :&gt;&gt; &#x27;, total); // 10 total 并没有自动更新为 12。我们可以修改下： 123456789101112let product = &#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;let total = 0;const effect = () =&gt; &#123; total = product.quantity * product.price&#125;effect() //total: 10product.price = 12effect() //total: 12 但此时我们仍然需要手动执行下 effect 才能让 total 的值变成”响应式”，如何能够自动更新呢？我们可以先修改下： 1234567891011121314151617181920212223242526272829303132333435const targetMap = new WeakMap();function track(target, key) &#123; let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; let deps = depsMap.get(key) if (!deps) &#123; depsMap.set(key, (deps = new Set())) &#125; deps.add(effect)&#125;function trigger(target, key) &#123; const depsMap = targetMap.get(target) if (!depsMap) &#123; return &#125; const deps = depsMap.get(key) if (deps) &#123; deps.forEach(effect =&gt; effect()) &#125;&#125;let product = &#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;let total = 0;const effect = () =&gt; &#123; total = product.quantity * product.price&#125;track(product, &#x27;price&#x27;)product.price = 12trigger(product, &#x27;price&#x27;) //total: 12 如上，我们收集了依赖，当它被改变时，触发更新，使得 total 更新成功，这里使用到了 ES6 中的WeakMap Map Set。 WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。WeakMap 的 key 是不可枚举的，因为 WeakMap 中每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象时这个对象将会被垃圾回收（相应的key则变成无效的）。 简易版本响应式如何能让依赖发生变更时自动更新呢，我们更新如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const targetMap = new WeakMap();function track(target, key) &#123; let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; let deps = depsMap.get(key) if (!deps) &#123; depsMap.set(key, (deps = new Set())) &#125; deps.add(effect)&#125;function trigger(target, key) &#123; const depsMap = targetMap.get(target) if (!depsMap) &#123; return &#125; const deps = depsMap.get(key) if (deps) &#123; deps.forEach(effect =&gt; effect()) &#125;&#125;const reactive = (target) =&gt; &#123; const handler = (target, &#123; get(target, key, receiver) &#123; console.log(&#x27;get key :&gt;&gt; &#x27;, key); track(target, key) return Reflect.get(target, key, receiver) &#125;, set(target, key, value, receiver) &#123; console.log(&#x27;set key :&gt;&gt; &#x27;, key); const oldValue = target[key] const result = Reflect.set(target, key, value, receiver) if (oldValue !== value) &#123; trigger(target, key) &#125; return result &#125; &#125;) return new Proxy(target, handler)&#125;let product = reactive(&#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;)let total = 0;const effect = () =&gt; &#123; total = product.quantity * product.price&#125;effect() // 建立 quantity 和 price 的依赖和副作用console.log(&#x27;total :&gt;&gt; &#x27;, total); // 10product.price = 12console.log(&#x27;total :&gt;&gt; &#x27;, total); // 12 成功了🙌，但是呢，如果我们在末尾加上一个 1console.log(&#x27;name :&gt;&gt;&#x27;, product.name) 此时，由于读取了 name ，由于拦截会重新进入到 getter 中，会重新 track，会为 name 建立多余的依赖和副作用 effect，虽然副作用本身和 name 并无关系。所以，我们可以在此基础上优化之： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364let activeEffect = null;const targetMap = new WeakMap();function effect(eff) &#123; activeEffect = eff; eff(); activeEffect = null;&#125;function track(target, key) &#123; if (activeEffect) &#123; let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; let deps = depsMap.get(key) if (!deps) &#123; depsMap.set(key, (deps = new Set())) &#125; deps.add(activeEffect) &#125;&#125;function trigger(target, key) &#123; const depsMap = targetMap.get(target) if (!depsMap) &#123; return &#125; const deps = depsMap.get(key) if (deps) &#123; deps.forEach(effect =&gt; effect()) &#125;&#125;const reactive = (target) =&gt; &#123; const handler = (target, &#123; get(target, key, receiver) &#123; console.log(&#x27;get key :&gt;&gt; &#x27;, key); track(target, key) return Reflect.get(target, key, receiver) &#125;, set(target, key, value, receiver) &#123; console.log(&#x27;set key :&gt;&gt; &#x27;, key); const oldValue = target[key] const result = Reflect.set(target, key, value, receiver) if (oldValue !== value) &#123; trigger(target, key) &#125; return result &#125; &#125;) return new Proxy(target, handler)&#125;let product = reactive(&#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;)let total = 0;effect(() =&gt; &#123; total = product.quantity * product.price&#125;)console.log(&#x27;total :&gt;&gt; &#x27;, total); // 10product.price = 12console.log(&#x27;total :&gt;&gt; &#x27;, total); // 12 如上，已经比较好的实现了我们想要的效果。让我们来看看下面的测试用例： 12345678910111213141516let product = reactive(&#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;)let total = 0;let saleTotal = 0;effect(() =&gt; &#123; total = product.quantity * product.price&#125;)effect(() =&gt; &#123; saleTotal = total * 0.8&#125;)console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total, saleTotal); //10 8product.price = 12console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total, saleTotal); //12 8 total 确实响应式更新了，但是 saleTotal 并没有相对应更新，这是因为这里的 total 并不是响应式数据，那如何让它变为响应式数据呢， 我们可以借助已经实现的 reactive ，包装如下，不过有些繁琐🤣 12345678910111213141516171819const ref = (initVal) =&gt; &#123; return reactive(&#123; value: initVal &#125;)&#125;let product = reactive(&#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;)let total = ref(0);let saleTotal = 0;effect(() =&gt; &#123; total.value = product.quantity * product.price&#125;)effect(() =&gt; &#123; saleTotal = parseFloat(total.value * 0.8).toFixed(2) / 1&#125;)console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total.value, saleTotal); //10 8product.price = 12console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total.value, saleTotal); //12 9.6 使用 ES5 提供的对象访问器或者 JS 的计算属性 Object Accessors。 123456789101112131415161718192021222324252627282930313233const ref = (raw) =&gt; &#123; const r = &#123; get value() &#123; track(r, &#x27;value&#x27;) return raw &#125;, set value(newVal) &#123; console.log(&#x27;newVal,raw :&gt;&gt; &#x27;, newVal, raw); if (newVal !== raw) &#123; raw = newVal trigger(r, &#x27;value&#x27;) &#125; &#125; &#125; return r&#125;let product = reactive(&#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;)let total = ref(0);let saleTotal = 0;effect(() =&gt; &#123; total.value = product.quantity * product.price&#125;)effect(() =&gt; &#123; saleTotal = parseFloat(total.value * 0.8).toFixed(2) / 1&#125;)console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total.value, saleTotal); //10 8product.price = 12console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total.value, saleTotal); //12 9.6 接下来实现 Vue3中的 真正的计算属性computed： 123456789101112131415const computed = (getter) =&gt; &#123; const result = ref() effect(() =&gt; result.value = getter()) return result&#125;let product = reactive(&#123; name: &#x27;西葫芦&#x27;, price: 10, quantity: 1,&#125;)const total = computed(() =&gt; product.price * product.quantity)const saleTotal = computed(() =&gt; parseFloat(total.value * 0.8).toFixed(2) / 1)console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total.value, saleTotal.value); //10 8product.price = 12console.log(&#x27;total,saleTotal :&gt;&gt; &#x27;, total.value, saleTotal.value); //12 9.6","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}],"tags":[{"name":"reactive","slug":"reactive","permalink":"https://xiaozhouguo.github.io/tags/reactive/"}],"keywords":[{"name":"Vue3","slug":"Vue3","permalink":"https://xiaozhouguo.github.io/categories/Vue3/"}]},{"title":"JS 数组改变长度 - 探究 JS V8 引擎下的“数组”底层实现","slug":"javascript-array","date":"2022-05-23T09:56:41.000Z","updated":"2022-06-02T04:49:09.634Z","comments":true,"path":"2022/05/23/javascript-array/","link":"","permalink":"https://xiaozhouguo.github.io/2022/05/23/javascript-array/","excerpt":"JavaScript 中的数组有很多特性：存放不同类型元素、数组长度可变等等，这与数据结构中定义的数组结构或者C++、Java等语言中的数组不太一样，那么JS数组的这些特性底层是如何实现的呢，我们打开V8引擎的源码，从中寻找到了答案。V8中对数组做了一层封装，使其有两种实现方式：快数组和慢数组，快数组底层是连续内存，通过索引直接定位，慢数组底层是哈希表，通过计算哈希值来定位。两种实现方式各有特点，有各自的使用情况，也会相互转换。","text":"JavaScript 中的数组有很多特性：存放不同类型元素、数组长度可变等等，这与数据结构中定义的数组结构或者C++、Java等语言中的数组不太一样，那么JS数组的这些特性底层是如何实现的呢，我们打开V8引擎的源码，从中寻找到了答案。V8中对数组做了一层封装，使其有两种实现方式：快数组和慢数组，快数组底层是连续内存，通过索引直接定位，慢数组底层是哈希表，通过计算哈希值来定位。两种实现方式各有特点，有各自的使用情况，也会相互转换。 一、背景使用 JS 的数组时，发现 JS 的数组可以存放不同类型的元素、并且数组长度是可变的。数据结构中定义的数组是定长的、数据类型一致的存储结构。JS 中的数组竟然如此特殊，这也是为什么标题中数组二字加上了“”的原因。带着一脸的懵逼，打开V8源码，一探究竟。 二、什么是数组首先来看下什么是数组，下面的图是维基百科上对于数组的定义： 图中有两个关键的点，相同类型、连续内存。 这两个关键点先不必深究，继续往下看，下面来解释。 看完数据结构中的定义，再来看下具体语言中对数组的实现： C、C++、Java、Scala 等语言中数组的实现，是通过在内存中划分一串连续的、固定长度的空间，来实现存放一组有限个相同数据类型的数据结构。这里面也涉及到了几个重要的概念：连续、固定长度、相同数据类型，与数据结构中的定义是类似的。 下面来分别解释下这几个概念： 1.连续 连续空间存储是数组的特点，下图是数组在内存中的存储示意图。 可以明显的看出各元素在内存中是相邻的，是一种线性的存储结构。 2.固定长度因为数组的空间是连续的，这就意味着在内存中会有一整块空间来存放数组，如果不是固定长度，那么内存中位于数组之后的区域会没办法分配，内存不知道数组还要不要继续存放，要使用多长的空间。长度固定，就界定了数组使用内存的界限，数组之外的空间可以分配给别人使用。 3.相同数据类型因为数组的长度是固定的，如果不是相同数据类型，一会存 int ，一会存String ，两种不同长度的数据类型，不能保证各自存放几个，这样有悖固定长度的规定，所以也要是相同的数据类型。 看到这，想必大部分人应该感觉：嗯，这跟我认识的数组几乎吻合吧。 那我们再来点刺激的，进入正菜，JavaScript 中的数组。 三、JavaScript 中的数组先来看段代码： 1234let arr = [100, 12.3, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr[arr.length] = &quot;black&quot;;console.log(arr.length); // 6console.log(arr[arr.length-1]); //black 这短短几行代码可以看出 JS 数组非同寻常的地方。 第一行代码，数组中竟然存放了三种数据类型？ 第二行代码，竟然向数组中添加了一个值？ 第三行和第四行代码验证了，数组的长度改变了，添加的值也生效了。 除了这些，JS的数组还有很多特殊的地方： JS 数组中不止可以存放上面的三种数据类型，它可以存放数组、对象、函数、Number、Undefined、Null、String、Boolean 等等。 JS 数组可以动态的改变容量，根据元素的数量来扩容、收缩。 JS 数组可以表现的像栈一样，为数组提供了push()和pop()方法。也可以表现的像队列一样，使用shift()和 push()方法，可以像使用队列一样使用数组。 JS 数组可以使用for-each遍历，可以排序，可以倒置。 JS 提供了很多操作数组的方法，比如Array.concat()、Array.join()、Array.slice()。 看到这里，应该可以看出一点端倪，大胆猜想，JS的数组不是基础的数据结构实现的，应该是在基础上面做了一些封装。 下面发车，一步一步地验证我们的猜想。 四、刨根问底：从V8源码上看数组的实现Talk is cheap，show me the code. 下面一图是 V8 中数组的源码： 首先，我们看到JSArray 是继承自JSObject，也就是说，数组是一个特殊的对象。 那这就好解释为什么JS的数组可以存放不同的数据类型，它是个对象嘛，内部也是key-value的存储形式。 我们使用这段代码来验证一下： 123let a = [1, &quot;hello&quot;, true, function () &#123; return 1;&#125;]; 通过 jsvu 来看一下底层是如何实现的： 可以看到，底层就是个 Map ，key 为0，1，2，3这种索引，value 就是数组的元素。 其中，数组的index其实是字符串。 验证完这个问题，我们再继续看上面的V8源码，摩拳擦掌，准备见大招了！从注释上可以看出，JS 数组有两种表现形式，fast 和 slow ，啥？英文看不懂？那我让谷歌帮我们翻译好了！ fast ： 快速的后备存储结构是 FixedArray ，并且数组长度 &lt;&#x3D; elements.length(); slow ： 缓慢的后备存储结构是一个以数字为键的 HashTable 。 HashTable，维基百科中解释的很好： 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 源码注释中的fast和slow，只是简单的解释了一下，其对应的是快数组和慢数组，下面来具体的看一下两种形式是如何实现的。 1、快数组（FAST ELEMENTS）快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，那来看下源码中是怎么扩容和收缩的。 源码中扩容的实现方法（C++）： 新容量的的计算方式： 即new_capacity &#x3D; old_capacity &#x2F;2 + old_capacity + 16 也就是，扩容后的新容量 &#x3D; 旧容量的1.5倍 + 16 扩容后会将数组拷贝到新的内存空间中，源码： 看完了扩容，再来看看当空间多余时如何收缩数组空间。 源码中收缩的实现方法（C++）: 可以看出收缩数组的判断是：如果容量 &gt;&#x3D; length的2倍 + 16，则进行收缩容量调整，否则用holes对象（什么是holes对象？下面来解释）填充未被初始化的位置。 如果收缩，那收缩到多大呢？ 看上面图中的这段代码： 这个elements_to_trim就是需要收缩的大小，需要根据 length + 1 和 old_length 进行判断，是将空出的空间全部收缩掉还是只收缩二分之一。 解释完了扩容和减容，来看下刚刚提到的holes对象。 holes （空洞）对象指的是数组中分配了空间，但是没有存放元素的位置。对于holes，快数组中有个专门的模式，在 Fast Elements 模式中有一个扩展，是Fast Holey Elements模式。 Fast Holey Elements 模式适合于数组中的 holes （空洞）情况，即只有某些索引存有数据，而其他的索引都没有赋值的情况。 那什么时候会是Fast Holey Elements 模式呢？ 当数组中有空洞，没有赋值的数组索引将会存储一个特殊的值，这样在访问这些位置时就可以得到 undefined。这种情况下就会是 Fast Holey Elements 模式。 Fast Holey Elements 模式与Fast Elements 模式一样，会动态分配连续的存储空间，分配空间的大小由最大的索引值决定。 新建数组时，如果没有设置容量，V8会默认使用 Fast Elements 模式实现。 如果要对数组设置容量，但并没有进行内部元素的初始化，例如let a &#x3D; new Array(10);，这样的话数组内部就存在了空洞，就会以Fast Holey Elements 模式实现。 使用jsvu调用v8-debug版本的底层实现来验证一下： 一目了然，HOLEY_SMI_ELEMENTS 就是Fast Holey Elements 模式 。 如果对数组进行了初始化，比如let a &#x3D; new Array(1,2,3);，这种就不存在空洞，就是以Fast Elements 模式实现。 验证： 这个PACKED_SMI_ELEMENTS就是Fast Elements 模式。 快数组先到这，再来看下慢数组： 2、慢数组（DICTIONARY ELEMENTS）慢数组是一种字典的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，其效率会比快数组低。 源码中 Dictionary 的结构 可以看到，内部是一个HashTable，然后定义了一些操作方法，和 Java 的 HashMap类似，没有什么特别之处。 了解了数组的两种实现方式，我们来总结下两者的区别。 3、快数组、慢数组的区别 存储方式方面：快数组内存中是连续的，慢数组在内存中是零散分配的。 内存使用方面：由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还可能有很多空洞，是比较费内存的。慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。 遍历效率方面：快数组由于是空间连续的，遍历速度很快，而慢数组每次都要寻找 key 的位置，遍历效率会差一些。 既然有快数组和慢数组，两者的也有各自的特点，每个数组的存储结构不会是一成不变的，会有具体情况下的快慢数组转换，下面来看一下什么情况下会发生转换。 五、快数组慢数组之间的转换1、快 -&gt; 慢首先来看 V8 中判断快数组是否应该转为慢数组的源码： 关键代码： 新容量 &gt;&#x3D; 3 * 扩容后的容量 * 2 ，会转变为慢数组。 当加入的 index- 当前capacity &gt;&#x3D; kMaxGap（1024） 时（也就是至少有了 1024 个空洞），会转变为慢数组。 我们主要来看下第二种关键代码的情况。 kMaxGap 是源码中的一个常量，值为1024。 也就是说，当对数组赋值时使用远超当前数组的容量+ 1024时（这样出现了大于等于 1024 个空洞，这时候要对数组分配大量空间则将可能造成存储空间的浪费，为了空间的优化，会转化为慢数组。 代码实锤： 12let a = [1, 2]a[1030] = 1; 数组中只有三个元素，但是却在 1030 的位置存放了一个值，那么中间会有多于1024个空洞，这时就会变为慢数组。 来验证一下： 可以看到，此时的数组确实是字典类型了，成功！ 好了，看完了快数组转慢数组，再反过来看下慢数组转换为快数组。 2、慢 -&gt; 快处于哈希表实现的数组，在每次空间增长时， V8 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。 V8中是否应该转为快数组的判断源码： 关键代码： 当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间,则会转变为快数组 来写代码验证一下： 12345let a = [1,2];a[1030] = 1;for (let i = 200; i &lt; 1030; i++) &#123; a[i] = i;&#125; 上面我们说过的，在 1030 的位置上面添加一个值，会造成多于 1024 个空洞，数组会使用为 Dictionary 模式来实现。 那么我们现在往这个数组中再添加几个值来填补空洞，往 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，会发生什么神奇的事情呢？ 可以看到，数组变成了快数组的 Fast Holey Elements 模式，验证成功。 那是不是快数组存储空间连续，效率高，就一定更好呢？其实不然。 3、各有优势快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。 六、扩展：ArrayBufferJS在ES6也推出了可以按照需要分配连续内存的数组，这就是ArrayBuffer。 ArrayBuffer会从内存中申请设定的二进制大小的空间，但是并不能直接操作它，需要通过ArrayBuffer构建一个视图，通过视图来操作这个内存。 1let buffer = new ArrayBuffer(1024); 这行代码就申请了 1kb 的内存区域。但是并不能对 arrayBuffer 直接操作，需要将它赋给一个视图来操作内存。 1let intArray = new Int32Array(bf); 这行代码创建了有符号的32位的整数数组，每个数占 4 字节，长度也就是 1024 &#x2F; 4 &#x3D; 256 个。 代码验证： 七、总结看到这，脑瓜子是不是嗡嗡的？喘口气，我们来回顾一下，这篇文章我们主要讨论了这几件事： 传统意义上的数组是怎么样的 JavaScript 中的数组有哪些特别之处 从V8源码下研究 JS 数组的底层实现 JS 数组的两种模式是如何转换的 ArrayBuffer 总的来说，JS 的数组看似与传统数组不一样，其实只是 V8 在底层实现上做了一层封装，使用两种数据结构实现数组，通过时间和空间纬度的取舍，优化数组的性能。 了解数组的底层实现，可以帮助我们写出执行效率更高的代码 链接： js 数组 改变长度_探究JS V8引擎下的“数组”底层实现_weixin_39992312的博客-CSDN博客","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/categories/JavaScript/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://xiaozhouguo.github.io/tags/Array/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/categories/JavaScript/"}]},{"title":"一窥 nextTick","slug":"vue/nextTick","date":"2022-05-21T12:13:31.000Z","updated":"2022-06-02T04:59:47.426Z","comments":true,"path":"2022/05/21/vue/nextTick/","link":"","permalink":"https://xiaozhouguo.github.io/2022/05/21/vue/nextTick/","excerpt":"简而言之，vue 通过异步队列的方式控制DOM更新，而 nextTick 则是在下一次 DOM 更新之后执行其回调函数。","text":"简而言之，vue 通过异步队列的方式控制DOM更新，而 nextTick 则是在下一次 DOM 更新之后执行其回调函数。 前提JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，事件循环 Event Loop应运而生。 事件循环是通过任务队列的机制来进行协调。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。setTimeout&#x2F;Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 在此次 tick 中选择最先进入队列的任务(oldest task)，如果有则执行(一次) 检查是否存在 Microtasks，如果存在则不停地执行，直至清空 Microtasks Queue 更新 render 主线程重复执行上述步骤 在上诉tick的基础上需要了解几点： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 宏任务 (macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。 浏览器为了能够使得 JS 内部 (macro)task 与 DOM 任务能够有序的执行，会在一个 (macro)task 执行结束后，在下一个 (macro)task 执行开始前，对页面进行重新渲染，流程如下： (macro)task -&gt; 渲染 -&gt; (macro)task -&gt; … 常见的宏任务有：script(整体代码)、setTimeout、setInterval、I&#x2F;O、UI交互、 postMessage、MessageChannel、setImmediate(node环境)。 微任务 microtask，可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比 setTimeout 等宏任务会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。 常见的微任务有：Promise.then、Object.observe、MutationObserver、process.nextTick(node环境) 在事件循环中，每进行一次循环操作称为 tick，无论是执行宏任务还是微任务，完成后都会进入到下一tick，并在两个tick之间进行UI渲染。每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） vue 中的 nextTickvue2 中，nextTick 的实现单独有一个JS文件来维护它，在src/core/util/next-tick.js中。nextTick 源码主要分为两块：能力检测和根据能力检测以不同方式执行回调队列。 优先级：Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout 2.6 版本优先使用 microtask 作为异步延迟包装器，且写法相对简单。而2.5 版本中，nextTick 的实现是 microTimerFunc、macroTimerFunc 组合实现的，延迟调用优先级是：Promise &gt; setImmediate &gt; MessageChannel &gt; setTimeout。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* @flow *//* globals MutationObserver */import &#123; noop &#125; from &#x27;shared/util&#x27;import &#123; handleError &#125; from &#x27;./error&#x27;import &#123; isIE, isIOS, isNative &#125; from &#x27;./env&#x27;export let isUsingMicroTask = falseconst callbacks = []let pending = falsefunction flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;// Here we have async deferring wrappers using microtasks.// In 2.5 we used (macro) tasks (in combination with microtasks).// However, it has subtle problems when state is changed right before repaint// (e.g. #6813, out-in transitions).// Also, using (macro) tasks in event handler would cause some weird behaviors// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).// So we now use microtasks everywhere, again.// A major drawback of this tradeoff is that there are some scenarios// where microtasks have too high a priority and fire in between supposedly// sequential events (e.g. #4521, #6690, which have workarounds)// or even between bubbling of the same event (#6566).let timerFunc// The nextTick behavior leverages the microtask queue, which can be accessed// via either native Promise.then or MutationObserver.// MutationObserver has wider support, however it is seriously bugged in// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It// completely stops working after triggering a few times... so, if native// Promise is available, we will use it:/* istanbul ignore next, $flow-disable-line */if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#x27;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Technically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 部分翻译如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 空函数，可用作函数占位符import &#123; noop &#125; from &#x27;shared/util&#x27; // 错误处理函数import &#123; handleError &#125; from &#x27;./error&#x27; // 是否是IE、IOS、内置函数import &#123; isIE, isIOS, isNative &#125; from &#x27;./env&#x27;// 使用 MicroTask 的标识符，这里是因为火狐在&lt;=53时 无法触发微任务，在modules/events.js文件中引用进行安全排除export let isUsingMicroTask = false // 用来存储所有需要执行的回调函数const callbacks = []// 用来标志是否正在执行回调函数let pending = false// 对callbacks进行遍历，然后执行相应的回调函数function flushCallbacks () &#123; pending = false // 这里拷贝的原因是： // 有的cb 执行过程中又会往callbacks中加入内容 // 比如 $nextTick的回调函数里还有$nextTick // 后者的应该放到下一轮的nextTick 中执行 // 所以拷贝一份当前的，遍历执行完当前的即可，避免无休止的执行下去 const copies = callbcks.slice(0) callbacks.length = 0 for(let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;let timerFunc // 异步执行函数 用于异步延迟调用 flushCallbacks 函数// 在2.5中，我们使用(宏)任务(与微任务结合使用)。// 然而，当状态在重新绘制之前发生变化时，就会出现一些微妙的问题// (例如#6813,out-in转换)。// 同样，在事件处理程序中使用(宏)任务会导致一些奇怪的行为// 因此，我们现在再次在任何地方使用微任务。// 优先使用 Promiseif(typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // IOS 的UIWebView, Promise.then 回调被推入 microTask 队列，但是队列可能不会如期执行 // 因此，添加一个空计时器强制执行 microTask if(isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if(!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; (isNative(MutationObserver) || MutationObserver.toString === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; // 当 原生Promise 不可用时，使用 原生MutationObserver // e.g. PhantomJS, iOS7, Android 4.4 let counter = 1 // 创建MO实例，监听到DOM变动后会执行回调flushCallbacks const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true // 设置true 表示观察目标的改变 &#125;) // 每次执行timerFunc 都会让文本节点的内容在 0/1之间切换 // 切换之后将新值复制到 MO 观测的文本节点上 // 节点内容变化会触发回调 timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) // 触发回调 &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;// next-tick.js 对外暴露了nextTick这一个函数export function nextTick(cb? Function, ctx: Object) &#123; let _resolve // cb 回调函数会统一处理压入callbacks数组 callbacks.push(() =&gt; &#123; if(cb) &#123; try &#123; cb.call(ctx) &#125; catch(e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) // pending 为false 说明本轮事件循环中没有执行过timerFunc() if(!pending) &#123; pending = true timerFunc() &#125; // 当不传入 cb 参数时，提供一个promise化的调用 // 如nextTick().then(() =&gt; &#123;&#125;) // 当_resolve执行时，就会跳转到then逻辑中 if(!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125;","categories":[{"name":"Vue2","slug":"Vue2","permalink":"https://xiaozhouguo.github.io/categories/Vue2/"}],"tags":[{"name":"nextTick","slug":"nextTick","permalink":"https://xiaozhouguo.github.io/tags/nextTick/"},{"name":"Promise","slug":"Promise","permalink":"https://xiaozhouguo.github.io/tags/Promise/"}],"keywords":[{"name":"Vue2","slug":"Vue2","permalink":"https://xiaozhouguo.github.io/categories/Vue2/"}]},{"title":"正则表达式","slug":"regular-expression","date":"2018-05-31T02:16:50.000Z","updated":"2022-05-25T09:35:02.293Z","comments":true,"path":"2018/05/31/regular-expression/","link":"","permalink":"https://xiaozhouguo.github.io/2018/05/31/regular-expression/","excerpt":"好久没有更新自己的博客了，今天恰好空闲，看了表哥的正则表达式，故作下记录，便于记忆和以后的查看。表哥链接，工具网站。","text":"好久没有更新自己的博客了，今天恰好空闲，看了表哥的正则表达式，故作下记录，便于记忆和以后的查看。表哥链接，工具网站。 匹配任意字符 . 匹配任意一个非断行字符，如 /./g。 匹配数字和字母 \\w 匹配阿拉伯数字和英文大小写字母和下划线。注意w为小写字母。如 /\\W/g。\\W 匹配那些 \\w 不能匹配到的字符(\\w的补集),如 /\\W/。 匹配数字 \\d 匹配阿拉伯数字，如 /\\d/g。\\D 匹配非阿拉伯数字(\\d的补集)，如 /\\D/g。 匹配空白字符 \\s 匹配空白字符，如空格、制表符、换行等，如 /\\s/g。 匹配字符集 [???] 其中???为任意的字符(集)或数字或 unicode等。如 /[a-z]/g /[A-Z]/g 分别匹配的是小写或大写的全部英文字符 /[\\u4e00-\\u9fa5]/g 匹配中文 重复一次或几次 [范围]+ 如 /[aA]+/g /[Aa][cC]+/g 重复零次或多次 [范围]* 如 /[aA][cC]+[!~\\.]*/g 重复零次或一次 [范围]? 如 /[Yy][oO]+[p]?[!~\\.]*/g 指定重复范围 /&#123;&#125;/ 如 /ab&#123;2,5&#125;/g /ab&#123;2,&#125;/g /ab&#123;2&#125;/g 分组匹配 文字不太好描述，链接到表哥！","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://xiaozhouguo.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"},{"name":"regular expression","slug":"regular-expression","permalink":"https://xiaozhouguo.github.io/tags/regular-expression/"}],"keywords":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://xiaozhouguo.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"javascript string、array常用API练习","slug":"javascript01","date":"2017-08-18T08:45:21.000Z","updated":"2022-05-25T09:31:06.181Z","comments":true,"path":"2017/08/18/javascript01/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/18/javascript01/","excerpt":"在 freeCodeCamp 做了一些练习，因此来总结一下有关javascript中常用的有关字符串和数组处理的官方API。","text":"在 freeCodeCamp 做了一些练习，因此来总结一下有关javascript中常用的有关字符串和数组处理的官方API。 1. Reverse a String又名 翻转字符串 ，其要求如下：将给定的字符串进行翻转，并进行返回。 提示：先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。 123456function reverseString(str) &#123; str=str.split(&quot;&quot;).reverse().join(&quot;&quot;); return str;&#125;reverseString(&quot;hello&quot;); 其中应用到了 split() reverse() join() 方法。 split() : string对象方法，将字符串分割成字符串数组。如果把空字符串 (&quot;&quot;) 用作 separator，那么字符串中的每个字符之间都会被分割。此方法不改变原始字符串。 reverse() : array对象方法，颠倒数组元素的顺序。 join() : array对象方法，将数组的所有元素放到一个字符串里。元素是通过指定的分隔符进行分隔的。 2. Factorialize a Number计算一个整数的阶乘。阶乘通常简写成 n!，例如: 5! &#x3D; 1 * 2 * 3 * 4 * 5 &#x3D; 120。要求返回运算结果。 方法一：for循环 123456789101112131415function factorialize(num) &#123; if(num&lt;0)&#123; return false; &#125;else if(num === 0 || num === 1)&#123; return 1; &#125;else&#123; for(var i=num-1;i&gt;0;i--)&#123; num*=i; &#125; &#125; return num;&#125;factorialize(5); 方法二：递归 将for循环改为：return factorialize(num-1)*num; 3. Check for Palindromes又名 检查回文字符串 ，要求：如果给定的字符串是回文，返回true，反之，返回false。 如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。提示：去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。 1234567891011function palindrome(str) &#123; str=str.replace(/[\\W_]/g,&#x27;&#x27;).toLowerCase(); var str2 = str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); if(str === str2)&#123; return true; &#125;else&#123; return false; &#125;&#125;palindrome(&quot;1 eye for of 1 eye.&quot;); 其中新应用到了 replace() toLowerCase() 方法。 replace() : string对象方法，在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。 toLowerCase() : string对象方法，将字符串中的字符全部转换为小写。同理 `toUpperCase()` 转换为大写。 4. Find the Longest Word in a String找出最长单词，在句子中找出最长的单词，并返回它的长度。函数的返回值应该是一个数字。 123456789function findLongestWord(str) &#123; str=str.split(&#x27; &#x27;).sort(function(a,b)&#123; return b.length-a.length; // 降序排列，return a.length - b.length 为升序 &#125;); return str[0].length; //return &#x27;最长的单词：&#x27;+str[0]+&#x27; 长度：&#x27;+str[0].length;&#125;findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;); 其中新应用到了 sort() 方法。 sort() ：array对象方法，对数组的元素进行排序。排序顺序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。 5. Title Case a Sentence又名 首字母大写 ，要求：确保字符串的每个单词首字母都大写，其余部分小写。 1234567891011121314151617 function titleCase(str) &#123; var arr = str.toLowerCase().split(&quot; &quot;); for(var i=0;i&lt;arr.length;i++)&#123; arr[i] = arr[i][0].toUpperCase() + arr[i].slice(1); &#125; return arr.join(&quot; &quot;); /*方法二： str=str.toLowerCase().split(&#x27; &#x27;); var newstr=&#x27;&#x27;; for(var i in str)&#123; newstr+=str[i].substring(0,1).toUpperCase()+str[i].substring(1)+&#x27; &#x27;; &#125; return newstr;*/&#125;titleCase(&quot;HERE IS MY HANDLE HERE IS MY SPOUT&quot;); 其中新应用到了 slice() substring() 方法。 slice() ：array对象方法，选取数组的的一部分，并返回一个新数组，不改变原数组。array.slice(start, end) 返回start和end之间的内容，如果没有指定end参数，那么返回包含从 start 到数组结束的所有元素。 substring() : string对象方法，返回字符串中介于两个指定下标之间的字符。string.substring(from, to)，如果没有 to 参数，则从 from 一直到 结束。 6. Return Largest Numbers in Arrays找出多个数组中的最大数形成一个新数组返回之。 123456789101112function largestOfFour(arr) &#123; var newarr=[]; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].sort(function(a,b)&#123; return b-a; &#125;); newarr.push(arr[i][0]); &#125; return newarr;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); 其中新应用到了 push() 方法。 push() : array对象方法，向数组的末尾添加一个或更多元素，并返回新的长度。此方法改变数组的长度。同理 `pop()` 删除数组的最后一个元素并返回删除的元素。 7. Confirm the Ending又名 检查字符串末尾 。判断一个字符串是否以给定的字符串结尾，是true，否false。 123456789101112function confirmEnding(str, target) &#123; var len=target.length; var strfrom=str.length-len; if(str.substr(strfrom,len)===target)&#123; return true; &#125;else&#123; return false; &#125;&#125;confirmEnding(&quot;Bastian&quot;, &quot;n&quot;); 其中新应用到了 substr() 方法。 substr() : string对象方法，从起始索引号提取字符串中指定数目的字符。string.substr(start,length)，如果省略了length参数，那么返回从 start 到结尾的字串。 8. Repeat a string repeat a string又名 重复输出字符串 ，要求：重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。 12345678910111213141516function repeat(str, num) &#123; // 请把你的代码写在这里 var newstr=&#x27;&#x27;; if(num&lt;0)&#123; return newstr; &#125;else if(num==1)&#123; return str; &#125;else&#123; for(var i=0;i&lt;num;i++)&#123; newstr+=str; &#125; return newstr; &#125;&#125;repeat(&quot;abc&quot;, 3); 9. Truncate a string又名 截断字符串 ，如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 1234567891011function truncate(str, num) &#123; if(str.length &lt;= num)&#123; return str; &#125;else if(num &lt;= 3)&#123; return str.replace(str.substring(num,str.length),&#x27;...&#x27;); &#125;else&#123; return str.replace(str.substring(num-3,str.length),&#x27;...&#x27;); &#125;&#125;truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, 11); 10. Chunky Monkey猴子吃香蕉, 分割数组。把一个数组arr按照指定的数组大小size分割成若干个数组块。例如: chunk([1,2,3,4],2)=[[1,2],[3,4]]; chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]; 123456789101112131415function chunk(arr, size) &#123; var newarr=[]; if(size&lt;0)&#123; return false; &#125;else if(size === 1)&#123; return arr; &#125;else&#123; for(var i=0;i&lt;arr.length;i=i+size)&#123; newarr.push(arr.slice(i,i+size)); &#125; return newarr; &#125;&#125;chunk([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], 2); 11. Slasher Flick截断数组 ，返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。 1234567891011121314function slasher(arr, howMany) &#123; var newarr=[]; if(howMany === 0)&#123; return arr; &#125;else if(arr.length &lt;= howMany)&#123; return newarr; &#125;else&#123; arr.splice(0,howMany); //var haha=arr.slice(howMany,arr.length); return arr; &#125;&#125;slasher([1, 2, 3], 2); 其中新应用到了 splice() 方法。 splice() : array对象方法，从数组中添加或删除元素。这种方法会改变原始数组！。 array.splice(index,howmany,item1,.....,itemX)，参数依次为：规定从何处添加/删除元素，规定应该删除多少元素，要添加到数组的新元素。 12. Mutations又名 比较字符串 ，如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。 12345678910function mutation(arr) &#123; for(var i=0;i&lt;arr[1].length;i++)&#123; if(arr[0].toLowerCase().indexOf(arr[1].toLowerCase().charAt(i)) == -1)&#123; return false; &#125; &#125; return true;&#125;mutation([&quot;hello&quot;, &quot;hey&quot;]); 其中新应用到了 indexOf() charAt() 方法。 indexOf() : string对象方法，返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。array对象也有这个方法，搜索数组中的元素，并返回它首次所在的位置。如果在数组中没找到字符串则返回 -1。 charAt() : string对象方法，返回在指定位置的字符。 13. Falsy Bouncer又名 过滤假值 。删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。 1234567891011function bouncer(arr) &#123; var a =[]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i])&#123; a.push(arr[i]); &#125; &#125; return a;&#125;bouncer([7, &quot;ate&quot;, &quot;&quot;, false, 9]); 14. Seek and Destroy实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 123456789101112function destroyer(arr) &#123; var arg = []; for(var i=1;i&lt;arguments.length;i++)&#123; arg.push(arguments[i]); &#125; var temp = arr.filter(function(item)&#123; return arg.indexOf(item) === -1; &#125;); return temp;&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); 其中新应用到了 filter() 方法。 filter() : array对象方法，检测数值元素，并返回符合条件所有元素的数组。filter() 不会改变原始数组。 arguments 是一个类似数组的对象, 对应于传递给函数的参数。它类似于数组，但除了 length 之外没有任何数组属性。 15. Where do I belong我身在何处？先插入数组后给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。 1234567891011121314151617function where(arr, num) &#123; // 请把你的代码写在这里 arr.push(num); arr.sort(function(a,b)&#123; return a-b; &#125;); return arr.indexOf(num); /*方法二 for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] === num)&#123; return i; &#125; &#125;*/&#125;where([40, 60], 50); 16. Caesars Cipher凯撒密码 ，下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。写一个ROT13函数，实现输入加密字符串，输出解密字符串。 12345678910111213141516function rot13(str) &#123; var newStr = &quot;&quot;; for (var i in str) &#123; var temp = str.charCodeAt(i); if (temp &lt; 65 || temp &gt; 91) &#123; newStr+= str[i]; &#125; else if (temp &gt; 77) &#123; newStr += String.fromCharCode(temp - 13); &#125; else &#123; newStr += String.fromCharCode(temp + 13); &#125; &#125; return newStr;&#125;rot13(&quot;SERR PBQR PNZC&quot;); // 你可以修改这一行来测试你的代码 其中新应用到了 charCodeAt() fromCharCode() 方法。 charCodeAt() : 返回在指定的位置的字符的 Unicode 编码。 fromCharCode() : 将 Unicode 编码转为字符。 17. other importentmap() 方法可以方便的迭代数组，它会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。注意，这个方法不会改变原始数组。 123456//示例var oldArray = [1,2,3,4,5];var newArray = oldArray.map(function (val)&#123; return val+3;&#125;);// [4,5,6,7,8] 数组方法 reduce() 用来迭代一个数组，并且把它累积到一个值中。使用 reduce() 时，你要传入一个回调函数，这个回调函数的参数是一个 累加(减)器 （比如例子中的 previousVal) 和当前值 (currentVal）。 reduce() 有一个可选的第二参数，它可以被用来设置累加器的初始值。如果没有在这定义初始值，那么初始值将变成数组中的第一项，而 currentVal 将从数组的第二项开始。 123456var array = [4,5,6,7,8];var singleVal = 0;singleVal = array.reduce(function (previousVal,currentVal)&#123; return previousVal+currentVal;&#125;,0);//30 concat() 方法可以用来把两个数组的内容合并到一个数组中。concat 方法的参数应该是一个数组。参数中的数组会拼接在原数组的后面，并作为一个新数组返回。 12345var oldArray = [1,2,3];var newArray = [];var concatMe = [4,5,6];newArray = oldArray.concat(concatMe); // [1,2,3,4,5,6]","categories":[{"name":"小窥 javascript","slug":"小窥-javascript","permalink":"https://xiaozhouguo.github.io/categories/%E5%B0%8F%E7%AA%A5-javascript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"小窥 javascript","slug":"小窥-javascript","permalink":"https://xiaozhouguo.github.io/categories/%E5%B0%8F%E7%AA%A5-javascript/"}]},{"title":"MongoDB 基础命令语法","slug":"DataBase01","date":"2017-08-14T13:04:20.000Z","updated":"2022-07-01T06:50:35.317Z","comments":true,"path":"2017/08/14/DataBase01/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/14/DataBase01/","excerpt":"MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。","text":"MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 前言今天我们来简单梳理一下其基础的命令语法。顺带与SQL做个简单的对比。 1. 基础概念我们先来了解一下基础概念： | SQL 术语&#x2F;概念 | MongoDB 术语&#x2F;概念 | 解释&#x2F;说明 || : — : | : —- : | : —– :|| database | database | 数据库 || table | collection | 数据库 表&#x2F;集合 || row | document | 数据表 行&#x2F;文档 || column | field | 数据 字段&#x2F;域 || index | index | 索引 || primary key | primary key | 主键，MongoDB自动将 _id 置为主键 | 2. 查询2.1 查询所有结果 select * from table_name db.collection_name.find() 下面的 table_name 和 collection_name 都以 article 代替 2.2 指定返回 select title , auther from article db.article.find({ },{‘title’: 1,’auther’: 1})&#x2F;&#x2F;find的第一个参数为查询条件，第二个参数是用来控制输出的，1表示返回，而0则不返回。默认值是0，但_id是例外，当 &#39;_id&#39;: 0 时，默认才不会显示_id。 2.3 where select * from article where title &#x3D; ‘mongodb’ db.article.find({‘title’ : ‘mongodb’}) 2.4 and (与) select * from article where title &#x3D; “mongodb” and author &#x3D; “god” db.article.find({‘title’:’mongodb’,’author’:’god’}) 2.5 or (或) select * from article where title &#x3D; “mongodb” or author &#x3D; “god” db.article.find({‘$or’: [{‘title’:’mongodb’},{‘author’:’god’}]}) 2.6 比较 select * form article where read &lt;&#x3D; 100 db.article.find({‘read’:{‘$lte’:100}})&#x2F;&#x2F;其中 $gt (&gt;),$lt (&lt;),$gte (&gt;&#x3D;),$lte (&lt;&#x3D;) 2.7 in select * from article where author in (‘a’,’b’,’c’) db.article.find({‘auther’: {‘$in’:[‘a’,’b’,’c’]}}) 2.8 like select * from article where title like ‘%mongodb%’ db.article.find({‘title’:&#x2F;mongodb&#x2F;}) 2.9 count select count(*) from article db.article.count() 2.10 不等于 select * from article where author !&#x3D; ‘a’ db.article.find({‘author’:{‘$ne’: ‘a’}}) 2.11 排序 &#x2F;&#x2F; 降序&#x2F;升序select * from article where type &#x3D; ‘mongodb’ order by read desc&#x2F;asc db.article.find({‘type’:’mongodb’}).sort({‘read’: -1&#x2F;1}) &#x2F;&#x2F;默认为1 findOne() 查询返回一条数据，其余使用方式和 find() 一直 3. insert（插入） insert into artical (author,content,types) values (park’,’helloworld’,’mongodb’)db.article.insert({‘author’:’park’,’content’,’helloworld’,’types’:’mongodb’}) 4. update（更新） &#x2F;&#x2F;语法db.collection_name.update(query,update[,options]) query: 必选，查询条件，类似find中的查询条件。 update : 必选，update的对象和一些更新的操作符（如$,$inc…）等 options：可选，一些更新配置的对象。 upsert：可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi：可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true, 就把按条件查出来多条记录全部更新。 writeConcern：可选，抛出异常的级别。 &#x2F;&#x2F;简单更新update article set title &#x3D; “mongodb” where read &gt; 100 db.article.update({“read”: {“$gt”: 100}}, {“$set”: { “title”: “mongodb”}}) 更新特定字段 $set update game set count &#x3D; 10000 where id &#x3D; 123 db.game.update({“_id”: 123}, { “$set”: {“count”: 10000}}) 删除特定字段 $unset db.game.update({“_id”:123}, {“$unset”: {“author”:1}}) $unset 指定字段的值是合法值即可 db.article.update({title:’Seven’}, {$set:{read:134371}})&#x2F;&#x2F;递增 $incdb.article.update({title:’Seven’}, {$inc:{read:2}}) &#x2F;&#x2F; 每次加2 多个同时更新，要设置 &#123;multi:true&#125; 如： db.article.update({ }, {$inc:{read:10}},{multi:true}) 数组追加，则应该用 $push 如： db.article.update({‘title’:’Seven’}, {$push:{‘types’:’mysql’}})db.article.update({‘title’:’Seven’}, {$push:{‘types’:[‘mysql’,’nosql’]}})&#x2F;&#x2F;注：追加字段必须是数组。如果数组字段不存在，则自动新增，然后追加。 5. 删除 &#x2F;&#x2F;删除所有文档delete from article db.article.remove() db.article.drop() &#x2F;&#x2F;当删除一个集合中的所有文档时，直接删除一个集合效率更高 &#x2F;&#x2F;删除指定文档delete from artical where title &#x3D; ‘seven’ db.article.remove({‘title’: ‘seven’})db.article.remove({‘title’: ‘seven’},1) &#x2F;&#x2F;删除第一个 6. 建立索引为文档中的一些key加上索引(index)可以加快搜索速度。 db.article.ensureIndex({‘title’:1}) &#x2F;&#x2F;升序1，降序-1 db.article.getIndexs() &#x2F;&#x2F;将返回所有索引，包括其名字。 db.article.dropIndex(‘index_name’) &#x2F;&#x2F;删除索引 7. 文本搜索对文本搜索之前，我们需要先对要搜索的key建立一个text索引。假定我们要对标题进行文本搜索，我们可以先这样： db.article.ensureIndex({title:’text’}) 比如，查找带有”seven”的标题： db.article.find({text:{‘$search’:’seven’}})&#x2F;&#x2F;MongoDB目前支持15种语言的文本搜索，暂不支持中文。 8. 常用命令第一组： db.article.find().limit(20) &#x2F;&#x2F; limit() 返回限制的数量 &#x2F;&#x2F; skip() 跳过数据条数，此处从第六条开始返回db.article.find().skip(5) 第二组： &#x2F;&#x2F;可以结合limit()和skip()来达到分页效果：select * from article limit 10, 20 db.article.find().skip(10).limit(20) 第三组： db.article.find().skip(5).limit(10).sort({‘title’:1}) 第四组： &#x2F;&#x2F;pretty() 输出的是经格式美化后的数据db.article.find().pretty() 第五组： show databases &#x2F;&#x2F;显示数据库use database_name &#x2F;&#x2F;切换&#x2F;新建数据库show collections &#x2F;&#x2F; 显示当前数据库下的集合db &#x2F;&#x2F; 显示当前数据库 参考资料:[参考资料1] (http://ghmagical.com/article/page/id/Bj7qgmJ3CJUE)参考资料2","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://xiaozhouguo.github.io/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://xiaozhouguo.github.io/tags/MongoDB/"},{"name":"MySQL","slug":"MySQL","permalink":"https://xiaozhouguo.github.io/tags/MySQL/"}],"keywords":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://xiaozhouguo.github.io/categories/MongoDB/"}]},{"title":"前端基础进阶10 详解面向对象、构造函数、原型与原型链","slug":"WebJs10","date":"2017-08-13T09:09:01.000Z","updated":"2022-05-25T09:33:07.996Z","comments":true,"path":"2017/08/13/WebJs10/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/13/WebJs10/","excerpt":"面向对象可以说是JavaScript中很重要的一个部分，也是很难理解的重点，我们先来看一看关于面向对象的一些基本功。","text":"面向对象可以说是JavaScript中很重要的一个部分，也是很难理解的重点，我们先来看一看关于面向对象的一些基本功。 1. 对象的定义ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲， 这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射 到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。 也就是说，在JavaScript中，对象无非就是由一些列无序的key-value对组成。其中value可以是基本值，对象或者函数。 1234567// 这里的person就是一个对象var person = &#123; name: &#x27;Tom&#x27;, age: 18, getName: function() &#123;&#125;, parent: &#123;&#125;&#125; 1.1 创建对象创建对象的方式有很多种，我们可以通过new的方式创建一个对象。 var obj &#x3D; new Object(); 也可以通过对象字面量的方式来创建一个对象。 var obj &#x3D; {}; 当我们想要给我们创建的简单对象添加方法时，可以这样表示。 12345678910111213// 可以这样var person = &#123;&#125;;person.name = &quot;TOM&quot;;person.getName = function() &#123; return this.name;&#125;// 也可以这样var person = &#123; name: &quot;TOM&quot;, getName: function() &#123; return this.name; &#125;&#125; 1.2 访问对象的属性和方法假如我们有一个简单的对象如下： 1234567var person = &#123; name: &#x27;TOM&#x27;, age: &#x27;20&#x27;, getName: function() &#123; return this.name &#125;&#125; 当我们想要访问他的name属性时，可以用如下两种方式访问： person.name 或者 person[‘name’] 如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写： 123[&#x27;name&#x27;, &#x27;age&#x27;].forEach(function(item) &#123; console.log(person[item]);&#125;) 这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。 2. 工厂模式虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。 1234567891011121314var perTom = &#123; name: &#x27;TOM&#x27;, age: 20, getName: function() &#123; return this.name &#125;&#125;;var perJake = &#123; name: &#x27;Jake&#x27;, age: 22, getName: function() &#123; return this.name &#125;&#125; 为解决这个问题，人们开始使用工厂模式的一种变体。顾名思义，工厂模式 就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节,如下面的例子所示。 1234567891011121314var createPerson = function(name, age) &#123; // 声明一个中间对象，该对象就是工厂模式的模子 var o = new Object(); // 依次添加我们需要的属性与方法 o.name = name; o.age = age; o.getName = function() &#123; return this.name; &#125; return o;&#125;// 创建两个实例var perTom = createPerson(&#x27;TOM&#x27;, 20);var PerJake = createPerson(&#x27;Jake&#x27;, 22); 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。使用 instanceof 可以识别对象的类型，如下例子： 1234var obj = &#123;&#125;;var foo = function() &#123;&#125;;console.log(obj instanceof Object); // trueconsole.log(foo instanceof Function); // true 随着 JavaScript 的发展，又一个新模式出现了。在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。 3. 构造函数模式为了能够判断实例与对象的关系,可以使用构造函数模式将前面的例子重写如下： 1234567891011var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; return this.name; &#125;&#125;var p1 = new Person(&#x27;Ness&#x27;, 20);console.log(p1.getName()); // Nessconsole.log(p1 instanceof Person); // trueconsole.log(p1 instanceof Object); // true 在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码 除了与 createPerson()中相同的部分外，还存在以下不同之处： 没有显式地创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。 new关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程： 声明一个中间对象 将该中间对象的原型指向构造函数的原型 将构造函数的this，指向该中间对象 返回该中间对象，即返回实例对象 3.1 将构造函数当做函数构造函数与其他函数的唯一区别，就在于调用它们的方式不同。 12345678910// 当作构造函数使用var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);person.getName(); //&quot;Nicholas&quot;// 作为普通函数调用Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到 windowwindow.getName(); //&quot;Greg&quot;// 在另一个对象的作用域中调用var o = new Object();Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);o.getName(); //&quot;Kristen&quot; 这个例子中的前两行代码展示了构造函数的典型用法，即使用new操作符来创建一个新对象。接下来的两行代码展示了不使用new操作符调用Person()会出现什么结果：属性和方法都被添加给window对象了。有读者可能还记得，当在全局作用域中调用一个函数时，this对象总是指向Global对象（在浏览器中就是window对象）。因此，在调用完函数之后，可以通过window对象来调用sayName()方法，并且还返回了”Greg”。最后，也可以使用call()或者apply()在某个特殊对象的作用域中调用Person函数，这里是在对象o的作用域中调用的，因此调用后o就拥有了所有属性和sayName()方法。 3.2 构造函数的问题构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为 getName()的方法，但那 两个方法不是同一个 Function 的实例。不要忘了——ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。 不同实例上的同名函数是不相等的console.log(p1.getName &#x3D;&#x3D;&#x3D; p2.getName); &#x2F;&#x2F;false 要解决这个问题，通过把函数定义转移到构造函数外部来解决这个问题： 1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.getName = getName;&#125;function getName()&#123; console.log(this.name);&#125;var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 在这个例子中，我们把 sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数 的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。这 样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只 能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型模式来解决。 4. 原型我们创建的每一个函数，都可以有一个 prototype（原型） 属性，该属性指向一个对象。这个对象，就是我们这里说的原型。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而 每一个new出来的实例，都有一个 __proto__ 属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过__proto__访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性，它们可以被所有的实例对象访问。 123456789101112// 声明构造函数function Person(name, age) &#123; this.name = name; this.age = age;&#125;// 通过prototye属性，将方法挂载到原型对象上Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person(&#x27;tim&#x27;, 10);var p2 = new Person(&#x27;jak&#x27;, 22);console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的__proto__都指向原型对象。而原型对象的 constructor 指向构造函数。 当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age; this.getName = function() &#123; console.log(&#x27;this is constructor.&#x27;); &#125;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person(&#x27;tim&#x27;, 10);p1.getName(); // this is constructor. 在这个例子中，我们同时在原型与构造函数中都声明了一个getName函数，运行代码的结果表示原型中的访问并没有被访问。 我们还可以通过 in 来判断，一个对象是否拥有某一个属性&#x2F;方法，无论是该属性&#x2F;方法存在与实例对象还是原型对象。另外使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不 要忘了它是从Object 继承来的）只在给定属性存在于对象实例中时，才会返回true。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;var p1 = new Person(&#x27;tim&#x27;, 10);console.log(&#x27;name&#x27; in p1); // trueconsole.log(&#x27;getName&#x27; in p1); // trueconsole.log(p1.hasOwnProperty(&#x27;name&#x27;)); //trueconsole.log(p1.hasOwnProperty(&#x27;getName&#x27;)); // false in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。 isMobile &#x3D; ‘ontouchstart’ in document;&#x2F;&#x2F; 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式。 4.1 简单的原型语法根据前面例子的写法，如果我们要在原型上添加更多的方法，可以这样写： 12345function Person() &#123;&#125;;Person.prototype.getName = function() &#123;&#125;Person.prototype.getAge = function() &#123;&#125;Person.prototype.sayHello = function() &#123;&#125;... ... 除此之外，我还可以使用更为简单的写法。 1234567function Person() &#123;&#125;;Person.prototype = &#123; constructor: Person, getName: function() &#123;&#125;, getAge: function() &#123;&#125;, sayHello: function() &#123;&#125;&#125; 这种字面量的写法看上去简单很多，但是有一个需要特别注意的地方。Person.prototype &#x3D; {}实际上是重新创建了一个{}对象并赋值给Person.prototype，这里的{}并不是最初的那个原型对象。因此它里面并不包含constructor属性。为了保证正确性，我们必须在新创建的{}对象中显示的设置constructor的指向。即上面的constructor: Person。 5. 原型链原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象，而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。因此理解了原型，那么原型链并不是一个多么复杂的概念。 我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？先随意声明一个函数： function foo() {} 那么我们可以用如下的图来表示这个函数的原型链:其中foo是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 基于原型链的特性，我们可以很轻松的实现继承。 6. 继承ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 我们常常结合构造函数与原型来创建一个对象。因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须得根据构造函数与原型的不同而采取不同的策略。 我们声明一个Person对象，该对象将作为父级，而子级cPerson将要继承Person的所有属性与方法。 1234567function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; return this.name;&#125; 首先我们来看构造函数的继承。在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。 12345// 构造函数的继承function cPerson(name, age, job) &#123; Person.call(this, name, age); this.job = job;&#125; 而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。 1234// 继承原型cPerson.prototype = new Person(name, age);// 添加更多方法cPerson.prototype.getLive = function() &#123;&#125; 当然关于继承还有更好的方式，这里就不做深入介绍了，以后有机会再详细解读吧。 7. 小结ECMAScript支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来 被构造函数模式所取代。 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局 限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 原型模式，使用构造函数的 prototype属性来指定那些应该共享的属性和方法。组合使用构造 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。 参考來源：简书 过去式丶 http://www.jianshu.com/p/15ac7393bc1f著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处参考书籍：JavaScript高级程序设计（第三版）第六章 面向对象的程序设计","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶09 记忆","slug":"WebJs09","date":"2017-08-12T02:17:06.000Z","updated":"2022-05-25T09:32:43.361Z","comments":true,"path":"2017/08/12/WebJs09/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/12/WebJs09/","excerpt":"函数可以将先前操作的结果记录在某个对象中，从而避免无谓的重复计算。这种优化被称之为 记忆(Memorization) 。JavaScript的数组和对象要实现这种优化是很方便的。","text":"函数可以将先前操作的结果记录在某个对象中，从而避免无谓的重复计算。这种优化被称之为 记忆(Memorization) 。JavaScript的数组和对象要实现这种优化是很方便的。 在计算机领域，记忆主要用于加速程序计算的一种优化技术，它使得函数避免重复验算之前已被处理的输入，而返回已经缓存的结果。 比如说，我们用 递归 的方式来计算 斐波那契（fibonacci）数列。这种数列的特点是，前面相邻的两项之和等于后一项的值，最前面的两项是 0 和 1。 1234567891011121314151617var fibonacci = function (n) &#123; return n &lt; 2 ? n : fibonacci (n-1) + fibonacci (n-2);&#125;;for( var i=0; i &lt;= 10; i++) &#123; console.log(&#x27;//&#x27; + i + &#x27;:&#x27; + fibonacci (i));&#125;//0:0//1:1//2:1//3:2//4:3//5:5//6:8//7:13//8:21//9:34//10:55 这样是正确运行的，但是却做了很多无谓的工作，fibonacci 函数调用自身很多次去计算可能已经被计算过的值。如果增加了记忆功能，就可以显著减少运算量。 我们在一个名为 memo 的数组中存放我们的存储结果，存储结果是可以隐藏在 闭包 中。当函数被调用时，这个函数首先检查运算结果是否已经存在，如果已经存在，就立即返回这个结果。 123456789101112131415var fibonacci = function () &#123; var memo = [0,1]; var fib = function (n) &#123; var result = memo[n]; if (typeof result !== &#x27;number&#x27;) &#123; result = fib (n-1) + fib (n-2); memo[n] = result; &#125; return result; &#125;; return fib;&#125;();for( var i=0; i &lt;= 10; i++) &#123; console.log(&#x27;//&#x27; + i + &#x27;:&#x27; + fibonacci (i));&#125; 这个函数返回了同样的结果，但调用自身的次数大为减少，仅仅是为了去取得存储。 我们可以将这种技术推而广之，编写一个函数来帮助我们来构造带记忆功能的函数。如下：memoizer 函数取得一个初始的 memo 数组和 formula 函数。它返回一个管理 memo 存储和在需要时间调用 formula 函数的 recur 函数。我们把这个 recur 函数和它的参数传递给 formula 函数。 1234567891011var memoizer = function (memo,formula) &#123; var recur = function (n) &#123; var result = memo[n]; if (typeof result !== &#x27;number&#x27;) &#123; result = formula (recur,n); memo[n] = result; &#125; return result; &#125;; return recur;&#125; 现在，我们可以使用 memoizer 函数来定义 fibonacci 函数，提供初始的 memo数组和 formula函数： 1234567var fibonacci = memoizer ([0,1], function (recur,n) &#123; return recur (n-1) + recur (n-2);&#125;);//来调用for( var i=0; i &lt;= 10; i++) &#123; console.log(&#x27;//&#x27; + i + &#x27;:&#x27; + fibonacci (i));&#125; 通过设计这种产生另一个函数的函数，极大的减少了工作量。例如，要产生一个可记忆的阶乘函数，我们只需要提供基本的阶乘公式即可： 123var factorial = memoizer([1,1],function (recur,n) &#123; return n * recur (n-1);&#125;) 完整代码如下： 1234567891011121314151617var memoizer = function (memo,formula) &#123; var recur = function (n) &#123; var result = memo[n]; if (typeof result !== &#x27;number&#x27;) &#123; result = formula (recur,n); memo[n] = result; &#125; return result; &#125;; return recur;&#125;;var factorial = memoizer([1,1],function (recur,n) &#123; return n * recur (n-1);&#125;);for( var i=0; i &lt;= 10; i++) &#123; console.log(&#x27;//&#x27; + i + &#x27;:&#x27; + factorial (i));&#125; 参考书籍：JavaScript语言精粹（修订版）第四章","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶08 柯里化","slug":"WebJs08","date":"2017-08-12T02:01:41.000Z","updated":"2022-05-25T09:32:36.461Z","comments":true,"path":"2017/08/12/WebJs08/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/12/WebJs08/","excerpt":"柯里化（Currying），也被翻译为“局部套用”，是把多参数函数转换为一系列单参数函数并进行调用的技术。函数也是值，从而我们可以用有趣的方式去操作函数值。柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。","text":"柯里化（Currying），也被翻译为“局部套用”，是把多参数函数转换为一系列单参数函数并进行调用的技术。函数也是值，从而我们可以用有趣的方式去操作函数值。柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。 柯里化是函数的一个比较高级的应用，想要理解它并不简单。因此我一直在思考应该如何更加表达才能让大家理解起来更加容易。想了很久，决定先抛开柯里化这个概念不管，补充两个重要、但是容易被忽略的知识点。 1. 补充知识点1.1 函数的隐式转换JavaScript作为一种 弱类型语言 ，它的 隐式转换 是非常灵活有趣的。当我们没有深入了解隐式转换的时候可能会对一些运算的结果会感动困惑，比如4 + true &#x3D; 5。当然，如果对隐式转换了解足够深刻，肯定是能够很大程度上提高对js的使用能力。只是我没有打算将所有的隐式转换规则分享给大家，这里暂时只分享一下，函数在隐式转换中的一些规则。 12345function fn() &#123; return 20;&#125;console.log(fn + 10); // 输出结果是多少？ 稍微修改一下，再想想输出结果会是什么？ 123456789function fn() &#123; return 20;&#125;fn.toString = function() &#123; return 10;&#125;console.log(fn + 10); // 输出结果是多少 还可以继续修改一下。 12345678910111213function fn() &#123; return 20;&#125;fn.toString = function() &#123; return 10;&#125;fn.valueOf = function() &#123; return 5;&#125;console.log(fn + 10); // 输出结果是多少？ 运行结果 12345678// 输出结果分别为function fn() &#123; return 20;&#125;102015 当使用console.log，或者进行运算时，隐式转换就可能会发生。从上面三个例子中我们可以得出一些关于函数隐式转换的结论。 当我们没有重新定义toString与valueOf时，函数的隐式转换会调用默认的toString方法，它会将函数的定义内容作为字符串返回。而当我们主动定义了toString&#x2F;vauleOf方法时，那么隐式转换的返回结果则由我们自己控制了。其中valueOf会比toString后执行。 1.2 利用call&#x2F;apply封数组的map方法 map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 通俗来说，就是遍历数组的每一项元素，并且在map的第一个参数（回调函数）中进行运算处理后返回计算结果。返回一个由所有计算结果组成的新数组。 12345678910// 回调函数中有三个参数// 第一个参数表示newArr的每一项，第二个参数表示该项在数组中的索引值// 第三个表示数组本身// 除此之外，回调函数中的this，当map不存在第二参数时，this指向丢失，当存在第二个参数时，指向改参数所设定的对象var newArr = [1, 2, 3, 4].map(function(item, i, arr) &#123; //console.log(item, i, arr, this); // 可运行试试看 return item + 1; // 每一项加1&#125;, &#123; a: 1 &#125;)console.log(newArr); // [2, 3, 4, 5] 在上面例子的注释中详细阐述了map方法的细节。现在要面临一个难题，就是如何封装map。 可以先想想for循环。我们可以使用for循环来实现一个map，但是在封装的时候，我们会考虑一些问题。我们在使用for循环的时候，一个循环过程确实很好封装，但是我们在for循环里面要对每一项做的事情却很难用一个固定的东西去把它封装起来。因为每一个场景，for循环里对数据的处理肯定都是不一样的。 于是大家就想了一个很好的办法，将这些不一样的操作单独用一个函数来处理，让这个函数成为map方法的第一个参数，具体这个回调函数中会是什么样的操作，则由我们自己在使用时决定。因此，根据这个思路的封装实现如下。 12345678910111213141516171819202122Array.prototype._map = function(fn, context) &#123; var temp = []; if(typeof fn == &#x27;function&#x27;) &#123; var k = 0; var len = this.length; // 封装for循环过程 for(; k &lt; len; k++) &#123; // 将每一项的运算操作丢进fn里，利用call方法指定fn的this指向与具体参数 temp.push(fn.call(context, this[k], k, this)) &#125; &#125; else &#123; console.error(&#x27;TypeError: &#x27;+ fn +&#x27; is not a function.&#x27;); &#125; // 返回每一项运算结果组成的新数组 return temp;&#125;var newArr = [1, 2, 3, 4]._map(function(item) &#123; return item + 1;&#125;)// [2, 3, 4, 5] 在理解了map的封装过程之后，我们就能够明白为什么我们在使用map时，总是期望能够在第一个回调函数中有一个返回值了。在eslint的规则中，如果我们在使用map时没有设置一个返回值，就会被判定为错误。 明白了函数的隐式转换规则与call&#x2F;apply在这种场景的使用方式，我们就可以尝试通过简单的例子来了解一下柯里化了。 3. 柯里化在前端面试中有一个关于柯里化的面试题，流传甚广。 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) &#x3D; 6add(1, 2, 3)(4) &#x3D; 10add(1)(2)(3)(4)(5) &#x3D; 15 很明显，计算结果正是所有参数的和，add方法每运行一次，肯定返回了一个同样的函数，继续计算剩下的参数。 当我们只调用两次时，可以这样封装： 1234567function add(a) &#123; return function(b) &#123; return a + b; &#125;&#125;console.log(add(1)(2)); // 3 如果只调用三次： 123456789function add(a) &#123; return function(b) &#123; return function (c) &#123; return a + b + c; &#125; &#125;&#125;console.log(add(1)(2)(3)); // 6 上面的封装看上去跟我们想要的结果有点类似，但是参数的使用被限制得很死，因此并不是我们想要的最终结果，我们需要通用的封装。应该怎么办？总结一下上面2个例子，其实我们是利用闭包的特性，将所有的参数，集中到最后返回的函数里进行计算并返回结果。因此我们在封装时，主要的目的，就是将参数集中起来计算。 123456789101112131415161718192021222324252627function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () &#123; var _adder = function() &#123; [].push.apply(_args, [].slice.call(arguments)); return _adder; &#125;; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; return adder.apply(null, [].slice.call(arguments));&#125;// 输出结果，可自由组合的参数console.log(add(1, 2, 3, 4, 5)); // 15console.log(add(1, 2, 3, 4)(5)); // 15console.log(add(1)(2)(3)(4)(5)); // 15 上面的实现，利用闭包的特性，主要目的是想通过一些巧妙的方法将所有的参数收集在一个数组里，并在最终隐式转换时将数组里的所有项加起来。因此我们在调用add方法的时候，参数就显得非常灵活。当然，也就很轻松的满足了我们的需求。 那么读懂了上面的demo，然后我们再来看看柯里化的特点，相信大家就会更加容易理解了。 柯里化（英语：Currying），又称为部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。 接收单一参数，因为要携带不少信息，因此常常以回调函数的理由来解决。 将部分参数通过回调函数等方式传入函数中 返回一个新函数，用于处理所有的想要传入的参数 在上面的例子中，我们可以将add(1, 2, 3, 4)转换为add(1)(2)(3)(4)。这就是部分求值。每次传入的参数都只是我们想要传入的所有参数中的一部分。当然实际应用中，并不会常常这么复杂的去处理参数，很多时候也仅仅只是分成两部分而已。 咱们再来一起思考一个与柯里化相关的问题。 假如有一个计算要求，需要我们将数组里面的每一项用我们自己想要的字符给连起来。我们应该怎么做？想到使用join方法，就很简单。 1234567891011var arr = [1, 2, 3, 4, 5];// 实际开发中并不建议直接给Array扩展新的方法// 只是用这种方式演示能够更加清晰一点Array.prototype.merge = function(chars) &#123; return this.join(chars);&#125;var string = arr.merge(&#x27;-&#x27;)console.log(string); // 1-2-3-4-5 增加难度，将每一项加一个数后再连起来。那么这里就需要map来帮助我们对每一项进行特殊的运算处理，生成新的数组然后用字符连接起来了。实现如下： 1234567891011var arr = [1, 2, 3, 4, 5];Array.prototype.merge = function(chars, number) &#123; return this.map(function(item) &#123; return item + number; &#125;).join(chars);&#125;var string = arr.merge(&#x27;-&#x27;, 1);console.log(string); // 2-3-4-5-6 同理，但是如果我们又想要让数组每一项都减去一个数之后再连起来呢？ 1234567891011var arr = [1, 2, 3, 4, 5];Array.prototype.merge = function(chars, number) &#123; return this.map(function(item) &#123; return item - number; &#125;).join(chars);&#125;var string = arr.merge(&#x27;-&#x27;, 1);console.log(string); // 0-1-2-3-4 机智的小伙伴肯定发现困惑所在了。我们期望封装一个函数，能同时处理不同的运算过程，但是我们并不能使用一个固定的套路将对每一项的操作都封装起来。于是问题就变成了和封装map的时候所面临的问题一样了。我们可以借助柯里化来搞定。 与map封装同样的道理，既然我们事先并不确定我们将要对每一项数据进行怎么样的处理，我只是知道我们需要将他们处理之后然后用字符连起来，所以不妨将处理内容保存在一个函数里。而仅仅固定封装连起来的这一部分需求。 123456789101112131415161718192021222324252627282930313233343536// 封装很简单，一句话搞定Array.prototype.merge = function(fn, chars) &#123; return this.map(fn).join(chars);&#125;var arr = [1, 2, 3, 4];// 难点在于，在实际使用的时候，操作怎么来定义，利用闭包保存于传递num参数var add = function(num) &#123; return function(item) &#123; return item + num; &#125;&#125;var red = function(num) &#123; return function(item) &#123; return item - num; &#125;&#125;// 每一项加2后合并var res1 = arr.merge(add(2), &#x27;-&#x27;);// 每一项减1后合并var res2 = arr.merge(red(1), &#x27;-&#x27;);// 也可以直接使用回调函数，每一项乘2后合并var res3 = arr.merge((function(num) &#123; return function(item) &#123; return item * num &#125;&#125;)(2), &#x27;-&#x27;)console.log(res1); // 3-4-5-6console.log(res2); // 0-1-2-3console.log(res3); // 2-4-6-8 4. 柯里化通用式通用的柯里化写法其实比我们上边封装的add方法要简单许多: 123456789101112131415161718192021var currying = function(fn) &#123; var args = [].slice.call(arguments, 1); return function() &#123; // 主要还是收集所有需要的参数到一个数组中，便于统一计算 var _args = args.concat([].slice.call(arguments)); return fn.apply(null, _args); &#125;&#125;var sum = currying(function() &#123; var args = [].slice.call(arguments); return args.reduce(function(a, b) &#123; return a + b; &#125;)&#125;, 10)console.log(sum(20, 10)); // 40console.log(sum(10, 5)); // 25 5. 柯里化与bind12345678910Object.prototype.bind = function(context) &#123; var _this = this; var args = [].slice.call(arguments, 1); return function() &#123; return _this.apply(context, args) &#125;&#125; 这个例子利用call与apply的灵活运用，实现了bind的功能。在前面的几个例子中，我们可以总结一下柯里化的特点： 接收单一参数，将更多的参数通过回调函数来搞定; 返回一个新函数，用于处理所有的想要传入的参数; 需要利用call&#x2F;apply与arguments对象收集参数； 返回的这个函数正是用来处理收集起来的参数。 参考來源：简书 过去式丶 http://www.jianshu.com/p/5e1899fe7d6b著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶07 函数与函数式编程","slug":"WebJs07","date":"2017-08-10T09:06:24.000Z","updated":"2022-05-25T09:32:24.639Z","comments":true,"path":"2017/08/10/WebJs07/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/10/WebJs07/","excerpt":"纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。所以大家一定要重视函数。","text":"纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。所以大家一定要重视函数。 1.函数声明、函数表达式、匿名函数、函数自执行1.1 函数声明我们知道，JavaScript中，有两种声明方式，一个是使用var的变量声明，另一个是使用function的函数声明。 在 变量对象详解 中我有提到过，变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。 因此我们在执行上下文中，无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数。 12345fn(); //functionfunction fn()&#123; console.log(&#x27;function&#x27;);&#125; 1.2 函数表达式与函数声明不同，函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了两步操作。 123456// 变量声明var a = 20;// 实际执行顺序var a = undefined; // 变量声明，初始值undefined，变量提升，提升顺序次于function声明a = 20; // 变量赋值，该操作不会提升 同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。 1234fn(); // 报错var fn = function() &#123; console.log(&#x27;function&#x27;);&#125; 上例子的执行顺序为： 12345var fn = undefined; // 变量声明提升fn(); // 执行报错fn = function() &#123; // 赋值操作，此时将后边函数的引用赋值给fn console.log(&#x27;function&#x27;);&#125; 因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。 关于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。 12345678910111213141516171819202122在构造函数中添加方法function Person(name) &#123; this.name = name; this.age = age; // 在构造函数内部中添加方法 this.getAge = function() &#123; return this.age; &#125;&#125;// 给原型添加方法Person.prototype.getName = function() &#123; return this.name;&#125;// 在对象中添加方法var a = &#123; m: 20, getM: function() &#123; return this.m; &#125;&#125; 1.3 匿名函数在上面我们大概讲述了函数表达式中的赋值操作。而 匿名函数，顾名思义，就是指的没有被显式进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。 12345678var a = 10;var fn = function(bar, num) &#123; return bar() + num;&#125;fn(function() &#123; return a;&#125;, 20) //30 在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的 arguments对象 中。 1234567891011121314151617181920// 变量对象在fn上下文执行过程中的创建阶段VO(fn) = &#123; arguments: &#123; bar: undefined, num: undefined, length: 2 &#125;&#125;// 变量对象在fn上下文执行过程中的执行阶段// 变量对象变为活动对象，并完成赋值操作与执行可执行代码VO -&gt; AOAO(fn) = &#123; arguments: &#123; bar: function() &#123; return a &#125;, num: 20, length: 2 &#125;&#125; 由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为回调函数。关于匿名函数更多的内容，我会在下一篇深入探讨柯里化的文章中进行更加详细讲解。 匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点，因此我们一定要对它的这些细节了解的足够清楚，如果对于变量对象的演变过程你还看不太明白，一定要回过头去看这篇文章：前端基础进阶03：变量对象详解 1.4 函数自执行和块级作用域在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。 123(function ()&#123; // ......&#125;)(); 一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。 根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。 12345678910(function() &#123; // 私有变量 var age = 20; var name = &#x27;Tom&#x27;; // 私有方法 function getName() &#123; return `your name is ` + name; &#125;&#125;)(); 但是共有方法和变量应该怎么办？大家还记得我们前面讲到过的闭包的特性吗？没错，利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。 如果你对闭包了解不够，前端基础进阶04 详细图解作用域链与闭包 应该可以帮到你。 123456789101112131415161718(function() &#123; // 私有变量 var age = 20; var name = &#x27;Tom&#x27;; // 私有方法 function getName() &#123; return `your name is ` + name; &#125; // 共有方法 function getAge() &#123; return age; &#125; // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收 window.getAge = getAge;&#125;)(); 当然，闭包在模块中的重要作用，我们也在讲解闭包的时候已经强调过，但是这个知识点真的太重要，需要我们反复理解并且彻底掌握，因此为了帮助大家进一步理解闭包，我们来看看jQuery中，是如何利用我们模块与闭包的。 123456789101112131415161718192021222324// 使用函数自执行的方式创建模块(function(window, undefined) &#123; // 声明jQuery构造函数 var jQuery = function(name) &#123; // 主动在构造函数中，返回一个jQuery实例 return new jQuery.fn.init(name); &#125; // 添加原型方法 jQuery.prototype = jQuery.fn = &#123; constructor: jQuery, init:function() &#123; ... &#125;, css: function() &#123; ... &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了 window.jQuery = window.$ = jQuery; &#125;)(window);// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了$(&#x27;#div1&#x27;); 在这里，我们只需要看懂闭包与模块的部分就行了，至于内部的原型链是如何绕的，为什么会这样写，我在讲面向对象的时候会为大家慢慢分析。举这个例子的目的所在，就是希望大家能够重视函数，因为在实际开发中，它无处不在。 接下来我要分享一个高级的，非常有用的模块的应用。当我们的项目越来越大，那么需要保存的数据与状态就越来越多，因此，我们需要一个专门的模块来维护这些数据，这个时候，有一个叫做 状态管理器 的东西就应运而生。对于状态管理器，最出名的话，我想非 redux 莫属了。虽然对于还在学习中的大家来说，redux是一个有点高深莫测的东西，但是在我们学习之前，可以先通过简单的方式，让大家大致了解状态管理器的实现原理，为我们未来的学习奠定坚实的基础。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 自执行创建模块(function() &#123; // states 结构预览 // states = &#123; // a: 1, // b: 2, // m: 30, // o: &#123;&#125; // &#125; var states = &#123;&#125;; // 私有变量，用来存储状态与数据 // 判断数据类型 function type(elem) &#123; if(elem == null) &#123; return elem + &#x27;&#x27;; &#125; return toString.call(elem).replace(/[\\[\\]]/g, &#x27;&#x27;).split(&#x27; &#x27;)[1].toLowerCase(); &#125; /** * @Param name 属性名 * @Description 通过属性名获取保存在states中的值 */ function get(name) &#123; return states[name] ? states[name] : &#x27;&#x27;; &#125; function getStates() &#123; return states; &#125; /* * @param options &#123;object&#125; 键值对 * @param target &#123;object&#125; 属性值为对象的属性，只在函数实现时递归中传入 * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似 */ function set(options, target) &#123; var keys = Object.keys(options); var o = target ? target : states; keys.map(function(item) &#123; if(typeof o[item] == &#x27;undefined&#x27;) &#123; o[item] = options[item]; &#125; else &#123; type(o[item]) == &#x27;object&#x27; ? set(options[item], o[item]) : o[item] = options[item]; &#125; return item; &#125;) &#125; // 对外提供接口 window.get = get; window.set = set; window.getStates = getStates;&#125;)()// 具体使用如下set(&#123; a: 20 &#125;); // 保存 属性aset(&#123; b: 100 &#125;); // 保存属性bset(&#123; c: 10 &#125;); // 保存属性c// 保存属性o, 它的值为一个对象set(&#123; o: &#123; m: 10, n: 20 &#125;&#125;)// 修改对象o 的m值set(&#123; o: &#123; m: 1000 &#125;&#125;)// 给对象o中增加一个c属性set(&#123; o: &#123; c: 100 &#125;&#125;)console.log(getStates()) 项目预览 我之所以说这是一个高级应用，是因为在单页应用中，我们很可能会用到这样的思路。根据我们提到过的知识，理解这个例子其实很简单，其中的难点估计就在于set方法的处理上，因为为了具有更多的适用性，因此做了很多适配，用到了递归等知识。如果你暂时看不懂，没有关系，知道如何使用就行了，上面的代码可以直接运用于实际开发。记住，当你需要保存的状态太多的时候，你就想到这一段代码就行了。 函数自执行的方式另外还有其他几种写法，诸如!function(){}()，+function(){}() 2. 函数参数传递方式：按值传递还记得基本数据类型与引用数据类型在复制上的差异吗？基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。 123456789var a = 20;var b = a;b = 10;console.log(a); // 20var m = &#123; a: 1, b: 2 &#125;var n = m;n.a = 5;console.log(m.a) // 5 当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。如下例。 12345678var a = 20;function fn(a) &#123; a = a + 10; return a;&#125;console.log(a); // 20 12345678var a = &#123; m: 10, n: 20 &#125;function fn(a) &#123; a.m = 20; return a;&#125;fn(a);console.log(a); // &#123; m: 20, n: 20 &#125; 正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。 123456789101112var person = &#123; name: &#x27;Nicholas&#x27;, age: 20&#125;function setName(obj) &#123; // 传入一个引用 obj = &#123;&#125;; // 将传入的引用指向另外的值 obj.name = &#x27;Greg&#x27;; // 修改引用的name属性&#125;setName(person);console.log(person.name); // Nicholas 未被改变 在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。 3. 函数式编程虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己写的代码。 3.1 函数是第一等公民所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多。 123456789var a = function foo() &#123;&#125; // 赋值function fn(function() &#123;&#125;, num) &#123;&#125; // 函数作为参数// 函数作为返回值function var() &#123; return function() &#123; ... ... &#125;&#125; 3.2 只用”表达式”，不用”语句”“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 了解这一点，可以让我们自己在封装函数的时候养成良好的习惯。借助这个特性，我们在学习其他API的时候，了解函数的返回值也是一个十分重要的习惯。 3.3 没有副作用所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。 函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 即所谓的只要是同样的参数传入，返回的结果一定是相等的。 3.4 闭包闭包是函数式编程语言的重要特性，我也在前面几篇文章中说了很多关于闭包的内容。这里不再赘述。 3.5 柯里化理解柯里化稍微有点难，我在下一篇文章里专门单独来深入分析。 4. 函数封装在我们自己封装函数时，最好尽量根据函数式编程的特点来编写。当然在许多情况下并不能完全做到，比如函数中我们常常会利用模块中的私有变量等。 4.1 普通封装12345function add(num1, num2) &#123; return num1 + num2;&#125;add(20, 10); // 30 4.2 挂载在对象上1234567891011121314if(typeof Array.prototype.add !== &#x27;function&#x27;) &#123; Array.prototype.add = function() &#123; var i = 0, len = this.length, result = 0; for( ; i &lt; len; i++) &#123; result += this[i] &#125; return result; &#125;&#125;[1, 2, 3, 4].add() // 10 修改数组对象的例子，常在面试中被问到类似的，但是并不建议在实际开发中扩展原生对象。与普通封装不一样的是，因为挂载在对象的原型上我们可以通过this来访问对象的属性和方法，所以这种封装在实际使用时会有许多的难点，因此我们一定要掌握好this。 参考來源：简书 过去式丶 http://www.jianshu.com/p/69dede6f7e5f著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶06 Chrome开发者工具调试","slug":"WebJs06","date":"2017-08-09T09:02:20.000Z","updated":"2022-05-25T09:32:11.481Z","comments":true,"path":"2017/08/09/WebJs06/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/09/WebJs06/","excerpt":"在chrome的开发者工具中，通过断点调试，我们能够非常方便的一步一步的观察JavaScript的执行过程，直观感知函数调用栈，作用域链，变量对象，闭包，this等关键信息的变化。","text":"在chrome的开发者工具中，通过断点调试，我们能够非常方便的一步一步的观察JavaScript的执行过程，直观感知函数调用栈，作用域链，变量对象，闭包，this等关键信息的变化。 Chrome开发者工具调试快点我，快点我，带你飞到一个神奇的地方！","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶05 this小解","slug":"WebJs05","date":"2017-08-09T09:00:39.000Z","updated":"2022-05-25T09:32:03.289Z","comments":true,"path":"2017/08/09/WebJs05/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/09/WebJs05/","excerpt":"我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。","text":"我们在学习JavaScript的过程中，由于对一些概念理解得不是很清楚，但是又想要通过一些方式把它记下来，于是就很容易草率的给这些概念定下一些方便自己记忆的有偏差的结论。 所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。 回顾在这之前，我们需要来回顾一下执行上下文。在执行上下文的创建阶段，会分别生成 变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定this指向。 在这里，我们需要得出一个非常重要一定要牢记于心的结论，this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。因此我们可以很容易就能理解到，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。 123456789var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a);&#125;fn(); // 10fn.call(obj); // 20 除此之外，在函数执行过程中，this一旦被确定，就不可更改了。 123456789var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; this = obj; // 这句话试图修改this，运行后会报错 console.log(this.a);&#125;fn(); 1. 全局对象中的this关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。 12345678910// 通过this绑定到全局对象this.a2 = 20;// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身var a1 = 10;// 仅仅只有赋值操作，标识符会隐式绑定到全局对象a3 = 30;// 输出结果会全部符合预期console.log(a1); //10console.log(a2); //20console.log(a3); //30 2.函数中的this在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。 123456// demo01var a = 20;function fn() &#123; console.log(this.a);&#125;fn(); //20，但在严格模式下出错 123456789// demo02var a = 20;function fn() &#123; function foo() &#123; console.log(this.a); &#125; foo();&#125;fn(); //20，但在严格模式下出错 123456789101112// demo03var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c); //40（对象在全局环境下定义）console.log(obj.fn()); //10 分析之前，我们先直接了当抛出结论。 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。 1234567// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局function fn() &#123; &#x27;use strict&#x27;; console.log(this);&#125;fn(); // fn是调用者，独立调用window.fn(); // fn是调用者，被window所拥有 在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。 那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加&#x2F;去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。 但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a + 20来计算，而他的调用者obj.c并非是一个函数。因此他不适用于上面的规则，我们要对这种方式单独下一个结论。 当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。可运行下面的例子查看区别。 1234567891011121314&#x27;use strict&#x27;;var a = 20;function foo () &#123; var a = 1; var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125; &#125; return obj.c;&#125;console.log(foo()); // 运行会报错 实际开发中，并不推荐这样使用this； 上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。 再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。 12345678910var a = 20;var foo = &#123; a: 10, getA: function () &#123; return this.a; &#125;&#125;console.log(foo.getA()); // 10var test = foo.getA;console.log(test()); // 20 foo.getA() 中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而 test() 作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。 稍微修改一下代码，大家自行理解。 123456789var a = 20;function getA() &#123; return this.a;&#125;var foo = &#123; a: 10, getA: getA&#125;console.log(foo.getA()); // 10 再来一个例子： 123456789101112function foo() &#123; console.log(this.a)&#125;function active(fn) &#123; fn(); // 真实调用者，为独立调用&#125;var a = 20;var obj = &#123; a: 10, getA: foo&#125;active(obj.getA); //20 3. 使用call，apply显示指定thisJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的 第一个参数都为this将要指向的对象。 如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call&#x2F;apply的用法。 1234567function fn() &#123; console.log(this.a);&#125;var obj = &#123; a: 20&#125;fn.call(obj); 而call与applay后面的参数，都是向将要执行的函数传递参数。其中 call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。 123456789function fn(num1, num2) &#123; console.log(this.a + num1 + num2);&#125;var obj = &#123; a: 20&#125;fn.call(obj, 100, 10); // 130fn.apply(obj, [20, 10]); // 50 因为call&#x2F;apply的存在，这让JavaScript变得十分灵活。因此就让call&#x2F;apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。 将类数组对象转换为数组 123456789101112131415function exam(a, b, c, d, e) &#123; // 先看看函数的自带属性 arguments 什么是样子的 console.log(arguments); // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变 var arg = [].slice.call(arguments); console.log(arg);&#125;exam(2, 8, 9, 10, 3);// result:// &#123; &#x27;0&#x27;: 2, &#x27;1&#x27;: 8, &#x27;2&#x27;: 9, &#x27;3&#x27;: 10, &#x27;4&#x27;: 3 &#125;// [ 2, 8, 9, 10, 3 ]//// 也常常使用该方法将DOM中的nodelist转换为数组// [].slice.call( document.getElementsByTagName(&#x27;li&#x27;) ); 根据自己的需要灵活修改this指向 12345678910var foo = &#123; name: &#x27;joker&#x27;, showName: function() &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: &#x27;rose&#x27;&#125;foo.showName.call(bar); //rose 实现继承 123456789101112131415161718// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = [&#x27;man&#x27;, &#x27;woman&#x27;];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log(&#x27;name:&#x27;+this.name+&#x27;, age:&#x27;+this.age+&#x27;, high:&#x27;+this.high+&#x27;, gender:&#x27;+this.gender[0]+&#x27;;&#x27;);&#125;new Student(&#x27;xiaom&#x27;, 12, &#x27;150cm&#x27;).message();// name:xiaom, age:12, high:150cm, gender:man; 简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了基层。Student的构造函数等同于下。 1234567var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = [&#x27;man&#x27;, &#x27;woman&#x27;]; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 在向其他执行上下文的传递中，确保this的指向保持不变 12345678910var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA(); 常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。 123456789var obj = &#123; a: 20, getA: function() &#123; var self = this; setTimeout(function() &#123; console.log(self.a) &#125;, 1000) &#125;&#125; 也可以使用ES5中已经自带的bind方法 12345678obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 4. 构造函数与原型方法上的this在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。 结合下面的例子，我在例子抛出几个问题大家思考一下。 12345678910111213function Person(name, age) &#123; // 这里的this指向了谁? this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; // 这里的this又指向了谁？ return this.name;&#125;// 上面的2个this，是同一个吗，他们是否指向了原型对象？var p1 = new Person(&#x27;Nick&#x27;, 20);p1.getName(); 我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。 通过new操作符调用构造函数，会经历以下4个阶段。 创建一个新的对象； 将构造函数的this指向这个新对象； 指向构造函数的代码，为这个对象添加属性，方法等； 返回新对象。 因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。 而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。 参考來源：简书 过去式丶 http://www.jianshu.com/p/d647aa6d1ae6著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶04 详细图解作用域链与闭包","slug":"WebJs04","date":"2017-08-08T08:35:38.000Z","updated":"2022-05-25T09:31:55.885Z","comments":true,"path":"2017/08/08/WebJs04/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/08/WebJs04/","excerpt":"初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。","text":"初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。 1. 作用域与作用域链在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。 基础数据类型与引用数据类型 内存空间 垃圾回收机制 执行上下文 变量对象和活动对象 如果你暂时还没有明白，可以去看本系列的前三篇文章。 1.1 作用域 在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 这里的标识符，指的是变量名或者函数名。 JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。 注意：在ES6中新增了块级作用域 作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 1.2 作用域链回顾一下上一篇文章我们分析的执行上下文的生命周期，如下图。 我们发现，作用域链是在执行上下文的创建阶段生成的。这个就奇怪了。上面我们刚刚说作用域在编译阶段确定规则，可是为什么作用域链却在执行阶段确定呢？ 之所以有这个疑问，是因为大家对作用域和作用域链有一个误解。我们上面说了，作用域是一套规则，那么作用域链是什么呢？是这套规则的具体实现。所以这就是作用域与作用域链的关系，相信大家都应该明白了吧。 我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 12345678910var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 12345innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链 this: &#123;&#125;&#125; 是的，你没有看错，我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object。 是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。 2. 闭包对于那些有一点 JavaScript使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包与作用域链息息相关 闭包是在函数执行该过程中确定的 先直截了当的抛出闭包的定义：当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。 简单来说，假设函数A在函数B的内部进行定义了，并且当函数A在执行时，访问了函数B内部的变量对象，那么B就是一个闭包。 同时也可以参考这个在前几张博文中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。 而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 12345678910111213var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过 fn=innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。这样，我们就可以称foo为闭包。 上图为 闭包foo 的作用域链 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。 关于如何在chrome中观察闭包，以及更多闭包的例子，看后续更博。 从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的innerFoo 在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。 虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。 123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); 3. 闭包的应用场景 setTimeOut()延迟函数我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，12345function fn() &#123; console.log(&#x27;this is test.&#x27;)&#125;var timer = setTimeout(fn, 1000);console.log(timer); 执行上面的代码，变量timer的值，会立即输出出来，表示setTimeout这个函数本身已经执行完毕了。但是一秒钟之后，fn才会被执行。这是为什么？ 按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。 柯里化在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化算是其中一种。关于柯里化，我会在以后详解函数式编程的时候仔细总结。 模块在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。 123456789101112(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数。 4. setTimeOut()在最初学习setTimeout的时候，我们很容易知道setTimeout有两个参数，第一个参数为一个函数，我们通过该函数定义将要执行的操作。第二个参数为一个时间毫秒数，表示延迟执行的时间。 123setTimeout(function() &#123; console.log(&#x27;一秒钟之后我将被打印出来&#x27;);&#125;, 1000) 可能不少人对于setTimeout的理解止步于此，但还是有不少人发现了一些其他的东西，并在评论里提出了疑问。比如上图中的这个数字7，是什么？ 每一个setTimeout在执行时，会返回一个唯一ID，上图中的数字7，就是这个唯一ID。我们在使用时，常常会使用一个变量将这个唯一ID保存起来，用以传入clearTimeout，清除定时器。 12345var timer = setTimeout(function() &#123; console.log(&#x27;如果不清除我，我将会一秒之后出现。&#x27;);&#125;, 1000)clearTimeout(timer); // 清除之后，通过setTimeout定义的操作并不会执行 接下来，我们还需要考虑另外一个重要的问题，那就是setTimeout中定义的操作，在什么时候执行？为了引起大家的重视，我们来看看下面的例子。 12345var timer = setTimeout(function() &#123; console.log(&#x27;setTimeout actions.&#x27;);//second&#125;, 0);console.log(&#x27;other actions.&#x27;);//first// 思考一下，当我将setTimeout的延迟时间设置为0时，上面的执行顺序会是什么？ 在对于执行上下文的介绍中，我与大家分享了函数调用栈这种特殊数据结构的调用特性。在这里，将会介绍另外一个特殊的队列结构，页面中所有由setTimeout定义的操作，都将放在同一个队列中依次执行。 而这个队列执行的时间，需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。而这些操作进入队列的顺序，则由设定的延迟时间来决定。 因此在上面这个例子中，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。所以上面的例子执行结果就非常容易理解了。 为了帮助大家理解，再来一个结合变量提升的更加复杂的例子。如果你能够正确看出执行顺序，那么你对于函数的执行就有了比较正确的认识了，如果还不能，就回过头去看看其他几篇文章。 1234567891011121314151617181920setTimeout(function() &#123; console.log(a);&#125;, 0);var a = 10;console.log(b);console.log(fn);var b = 20;function fn() &#123; setTimeout(function() &#123; console.log(&#x27;setTImeout 10ms.&#x27;); &#125;, 10);&#125;fn.toString = function() &#123; return 30;&#125;console.log(fn);setTimeout(function() &#123; console.log(&#x27;setTimeout 20ms.&#x27;);&#125;, 20);fn(); 5. 思考题为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 如果我们直接这样写，根据setTimeout定义的操作在函数调用栈清空之后才会执行的特点，for循环里定义了5个setTimeout操作。而当这些操作开始执行时，for循环的i值，已经先一步变成了6。因此输出结果总为6。而我们想要让输出结果依次执行，我们就必须借助闭包的特性，每次循环时，将i值保存在一个闭包中，当setTimeout中定义的操作执行时，则访问对应闭包保存的i值即可。 思考题方法一： 1234567for (var i=1; i&lt;=5; i++) &#123; (function (i) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 ) &#125;)(i);&#125; 我们知道在函数中闭包判定的准则，即执行时是否在内部定义的函数中访问了上层作用域的变量。因此我们需要包裹一层自执行函数为闭包的形成提供条件。因此，我们只需要2个操作就可以完成题目需求，一是使用自执行函数提供闭包条件，二是传入i值并保存在闭包中。 方法二： 12345678for (var i=1; i&lt;=5; i++) &#123; setTimeout( (function(i)&#123; return function()&#123; console.log(i); &#125; &#125;)(i), i*1000 );&#125;//当然，也可以在setTimeout的第一个参数处利用闭包。 把内部函数return出去的作用是因为可以在其他执行环境中很容易的把return出来的函数引用保存起来，这就形成了闭包，所以这算是闭包的其中一种情况。也是很常用的情况。 方法三： 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer(i) &#123; console.log(i); &#125;, i*1000,i );&#125; 利用setTimeout第三个参数其实，setTimeout可以传入第三个参数、第四个参数….，它们表示神马呢？其实是用来表示第一个参数（回调函数）传入的参数。 方法四： 123456for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer(i) &#123; console.log(i); &#125;.bind(null,i), i*1000 );&#125;//利用了ES5中新增的 bind ,作用是修改 this 指向 方法五： 12345for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 利用了ES6中新增的 let ，let 只是在 for 循环中， var 却是在整个函数都是可见的。其他情况如 全局作用域和函数块作用域时 var 和 let 是等价的 参考來源：简书 过去式丶 http://www.jianshu.com/p/21a16d44f150著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶03 变量对象详解","slug":"WebJs03","date":"2017-08-08T07:31:45.000Z","updated":"2022-05-25T09:31:46.771Z","comments":true,"path":"2017/08/08/WebJs03/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/08/WebJs03/","excerpt":"在JavaScript中，我们肯定不可避免的需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。","text":"在JavaScript中，我们肯定不可避免的需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。 回顾在上一篇文章中，我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。 创建阶段在这个阶段中，执行上下文会分别创建 变量对象，建立 作用域链，以及 确定this指向 代码执行阶段创建完成之后，就会开始执行代码，这个时候，会完成 变量赋值，函数引用，以及 执行其他代码。 从这里我们就可以看出详细了解执行上下文极为重要，因为其中涉及到了变量对象，作用域链，this等很多人没有怎么弄明白，但是却极为重要的概念，因此它关系到我们能不能真正理解JavaScript。在后面的文章中我们会一一详细总结，这里我们先重点了解变量对象。 1. 变量对象变量对象（Variable Object）的创建，依次经历了以下几个过程。 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。 根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。 在上面的规则中我们看出，function声明会比var声明 优先级 更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。 123456789101112// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示： 12345678910111213141516创建过程testEC = &#123; // 变量对象 VO: &#123;&#125;, scopeChain: &#123;&#125;, this: &#123;&#125;&#125;// 因为本文暂时不详细解释作用域链和this，所以把变量对象专门提出来说明// VO 为 Variable Object的缩写，即变量对象VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt;; // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 这样，如果再面试的时候被问到 变量对象 和 活动对象 有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。 1234567// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1&#125; 因此，上面的例子demo1，执行顺序就变成了这样： 1234567891011function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 再来一个例子，巩固一下我们的理解。 1234567891011121314151617// demo2function test() &#123; console.log(foo); console.log(bar); var foo = &#x27;Hello&#x27;; console.log(foo); var bar = function () &#123; return &#x27;world&#x27;; &#125; function foo() &#123; return &#x27;hello&#x27;; &#125;&#125;test(); 1234567// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖 1234567// 执行阶段VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: &#x27;Hello&#x27;, bar: &lt;bar reference&gt;&#125; 需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。 2. 全局上下文的变量对象以浏览器中为例，全局对象为window。全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。 1234567// 以浏览器中为例，全局对象为window// 全局上下文windowEC = &#123; VO: window, scopeChain: &#123;&#125;, this: window&#125; 除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。 参考來源：简书 过去式丶 http://www.jianshu.com/p/330b1505e41d著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶02 执行上下文详细图解","slug":"WebJs02","date":"2017-08-05T09:51:17.000Z","updated":"2022-05-25T09:31:40.622Z","comments":true,"path":"2017/08/05/WebJs02/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/05/WebJs02/","excerpt":"今天我们来梳理一下有关 执行上下文（execution context） 的有关问题。","text":"今天我们来梳理一下有关 执行上下文（execution context） 的有关问题。 小例子我们先来看一个有关于 变量提升 的小例子： 12console.log(a);var a=666; 暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念 执行上下文（Execution Context）。 每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。 JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval 因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以堆栈的方式来处理它们，这个堆栈，我们称其为 函数调用栈 (call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而 处于栈顶的上下文执行完毕之后，就会自动出栈。 为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。 1234567891011var color = &#x27;blue&#x27;;function changeColor() &#123; var anotherColor = &#x27;red&#x27;; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了changeColor()，这一句激活函数changeColor创建它自己的执行上下文，因此第二步就是changeColor的执行上下文入栈。changeColor的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors的执行上下文入栈。在swapColors的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors的上下文从栈中弹出。swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。 全局上下文在浏览器窗口关闭后出栈。 注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。 详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。 单线程 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。 我们来个闭包的例子来看一看： 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1（第8行代码）时，f2不会创建新的上下文，而直到 result（第9行）执行时，才创建了一个新的。具体演变过程如下。 下一篇文章继续总结执行上下文的创建过程与变量对象。 参考來源：简书 过去式丶 http://www.jianshu.com/p/a6d37c77e8db著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"前端基础进阶01 内存空间详细图解","slug":"WebJs01","date":"2017-08-04T09:00:58.000Z","updated":"2022-05-25T09:35:34.130Z","comments":true,"path":"2017/08/04/WebJs01/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/04/WebJs01/","excerpt":"因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间 并不是一个经常被提及的概念，很容易被大家忽视。","text":"因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间 并不是一个经常被提及的概念，很容易被大家忽视。 想要对JS的理解更加深刻，就必须对内存空间有一个清晰的认知。发现由于对它们的模糊认知，导致了很多东西我都理解得并不明白。比如最基本的引用数据类型和引用传递到底是怎么回事儿？比如浅复制与深复制有什么不同？还有闭包，原型等等。 1. 堆 与 栈 注：栈（stack），有的地方也叫堆栈。 与C&#x2F;C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以粗浅的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思路进行处理，比如JavaScript的执行上下文（关于执行上下文我会在下一篇文章中总结）。执行上下文在逻辑上实现了堆栈。因此理解堆栈数据结构的原理与特点任然十分重要。 栈的存取方式：先进后出（FILO) 或后进先出。（由此联想到 队列： 先进先出 （FIFO) ） 可以用乒乓球盒子来类比 栈 堆存取数据的方式，则与书架与书非常相似。我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 2. 变量对象与基础数据类型JavaScript的 执行上下文 生成之后，会创建一个叫做 变量对象 的特殊对象（具体会在下一篇文章与执行上下文一起总结），JavaScript的 基础数据类型 往往都会保存在变量对象中。 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。 基础数据类型都是一些简单的数据段，都是按值访问，我们可以直接操作保存在变量中的实际的值。 基础数据类型包括5种类型，分别是 String（字符） Numble（数字） Null（空） Undefined（未定义） Boolean（布尔）。 3. 引用数据类型与堆内存与其他语言不通，JS的 引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 123456var a1 = 0; // 变量对象var a2 = &#x27;this is string&#x27;; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的 地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。理解了JS的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。 &#x2F;&#x2F; demo01.jsvar a &#x3D; 20;var b &#x3D; a;b &#x3D; 30;&#x2F;&#x2F; 这时a的值是多少？ 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b &#x3D; a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。 &#x2F;&#x2F; demo02.jsvar m &#x3D; { a: 10, b: 20 }var n &#x3D; m;n.a &#x3D; 15;&#x2F;&#x2F; 这时m.a的值是多少 在demo02中，我们通过var n &#x3D; m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。因此当我改变n时，m也发生了变化。这就是引用类型的特性。 通过内存的角度来理解，是不是感觉要轻松很多。除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。 4. 内存空间管理因为JavaScript具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理。但是根据我自己的开发经验，了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。因此关心内存是一件非常重要的事情。 JavaScript的内存生命周期： 1.0 分配需要的内存 2.0 使用分配到的内存 3.0 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 123var a = 20; // 在内存中给数值变量分配空间alert(a + 100); // 使用内存a = null; // 使用完毕之后，释放内存空间 第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此a &#x3D; null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。 参考來源：简书 过去式丶 http://www.jianshu.com/p/996671d4dcc4著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xiaozhouguo.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端基础进阶","slug":"前端基础进阶","permalink":"https://xiaozhouguo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"}]},{"title":"MarkDown 基础语法手册","slug":"markdown","date":"2017-08-03T09:36:40.000Z","updated":"2022-05-25T09:31:13.777Z","comments":true,"path":"2017/08/03/markdown/","link":"","permalink":"https://xiaozhouguo.github.io/2017/08/03/markdown/","excerpt":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。","text":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例：这是 斜体，这是 粗体。 2. 分级标题 使用 === 表示一级标题，使用 --- 表示二级标题。你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例：hexo是一个快速、简洁且高效的博客框架。这是去往 hexo 的链接。 4. 无序列表可以使用 *，+，- 这三个中的任何一个表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用 数字和点 如 X. 表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码&#96; 表示行内代码块。 示例：让我们聊聊 HTML和CSS。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： 10.内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 11. 删除线使用 ~~ 表示删除线。 示例：这是一段错误的文本。 12. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0): &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27; if param1 &gt; param2: # interesting print &#x27;Greater&#x27; return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27; JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 13. 表格支持示例 ： 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 14. 待办事项 todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表 嵌套 以及 混用 Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://xiaozhouguo.github.io/categories/MarkDown/"}],"tags":[],"keywords":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://xiaozhouguo.github.io/categories/MarkDown/"}]}]}